/*!
 * ZeroClipboard
 * The ZeroClipboard library provides an easy way to copy text to the clipboard using an invisible Adobe Flash movie and a JavaScript interface.
 * Copyright (c) 2014 Jon Rohan, James M. Greene
 * Licensed MIT
 * http://zeroclipboard.org/
 * v2.1.6
 */
define('lib/ZeroClipboard', function (require,exports,module) {
    (function(window, undefined) {
        "use strict";
        /**
         * Store references to critically important global functions that may be
         * overridden on certain web pages.
         */
        var _window = window, _document = _window.document, _navigator = _window.navigator, _setTimeout = _window.setTimeout, _encodeURIComponent = _window.encodeURIComponent, _ActiveXObject = _window.ActiveXObject, _Error = _window.Error, _parseInt = _window.Number.parseInt || _window.parseInt, _parseFloat = _window.Number.parseFloat || _window.parseFloat, _isNaN = _window.Number.isNaN || _window.isNaN, _round = _window.Math.round, _now = _window.Date.now, _keys = _window.Object.keys, _defineProperty = _window.Object.defineProperty, _hasOwn = _window.Object.prototype.hasOwnProperty, _slice = _window.Array.prototype.slice, _unwrap = function() {
            var unwrapper = function(el) {
                return el;
            };
            if (typeof _window.wrap === "function" && typeof _window.unwrap === "function") {
                try {
                    var div = _document.createElement("div");
                    var unwrappedDiv = _window.unwrap(div);
                    if (div.nodeType === 1 && unwrappedDiv && unwrappedDiv.nodeType === 1) {
                        unwrapper = _window.unwrap;
                    }
                } catch (e) {}
            }
            return unwrapper;
        }();
        /**
         * Convert an `arguments` object into an Array.
         *
         * @returns The arguments as an Array
         * @private
         */
        var _args = function(argumentsObj) {
            return _slice.call(argumentsObj, 0);
        };
        /**
         * Shallow-copy the owned, enumerable properties of one object over to another, similar to jQuery's `$.extend`.
         *
         * @returns The target object, augmented
         * @private
         */
        var _extend = function() {
            var i, len, arg, prop, src, copy, args = _args(arguments), target = args[0] || {};
            for (i = 1, len = args.length; i < len; i++) {
                if ((arg = args[i]) != null) {
                    for (prop in arg) {
                        if (_hasOwn.call(arg, prop)) {
                            src = target[prop];
                            copy = arg[prop];
                            if (target !== copy && copy !== undefined) {
                                target[prop] = copy;
                            }
                        }
                    }
                }
            }
            return target;
        };
        /**
         * Return a deep copy of the source object or array.
         *
         * @returns Object or Array
         * @private
         */
        var _deepCopy = function(source) {
            var copy, i, len, prop;
            if (typeof source !== "object" || source == null) {
                copy = source;
            } else if (typeof source.length === "number") {
                copy = [];
                for (i = 0, len = source.length; i < len; i++) {
                    if (_hasOwn.call(source, i)) {
                        copy[i] = _deepCopy(source[i]);
                    }
                }
            } else {
                copy = {};
                for (prop in source) {
                    if (_hasOwn.call(source, prop)) {
                        copy[prop] = _deepCopy(source[prop]);
                    }
                }
            }
            return copy;
        };
        /**
         * Makes a shallow copy of `obj` (like `_extend`) but filters its properties based on a list of `keys` to keep.
         * The inverse of `_omit`, mostly. The big difference is that these properties do NOT need to be enumerable to
         * be kept.
         *
         * @returns A new filtered object.
         * @private
         */
        var _pick = function(obj, keys) {
            var newObj = {};
            for (var i = 0, len = keys.length; i < len; i++) {
                if (keys[i] in obj) {
                    newObj[keys[i]] = obj[keys[i]];
                }
            }
            return newObj;
        };
        /**
         * Makes a shallow copy of `obj` (like `_extend`) but filters its properties based on a list of `keys` to omit.
         * The inverse of `_pick`.
         *
         * @returns A new filtered object.
         * @private
         */
        var _omit = function(obj, keys) {
            var newObj = {};
            for (var prop in obj) {
                if (keys.indexOf(prop) === -1) {
                    newObj[prop] = obj[prop];
                }
            }
            return newObj;
        };
        /**
         * Remove all owned, enumerable properties from an object.
         *
         * @returns The original object without its owned, enumerable properties.
         * @private
         */
        var _deleteOwnProperties = function(obj) {
            if (obj) {
                for (var prop in obj) {
                    if (_hasOwn.call(obj, prop)) {
                        delete obj[prop];
                    }
                }
            }
            return obj;
        };
        /**
         * Determine if an element is contained within another element.
         *
         * @returns Boolean
         * @private
         */
        var _containedBy = function(el, ancestorEl) {
            if (el && el.nodeType === 1 && el.ownerDocument && ancestorEl && (ancestorEl.nodeType === 1 && ancestorEl.ownerDocument && ancestorEl.ownerDocument === el.ownerDocument || ancestorEl.nodeType === 9 && !ancestorEl.ownerDocument && ancestorEl === el.ownerDocument)) {
                do {
                    if (el === ancestorEl) {
                        return true;
                    }
                    el = el.parentNode;
                } while (el);
            }
            return false;
        };
        /**
         * Get the URL path's parent directory.
         *
         * @returns String or `undefined`
         * @private
         */
        var _getDirPathOfUrl = function(url) {
            var dir;
            if (typeof url === "string" && url) {
                dir = url.split("#")[0].split("?")[0];
                dir = url.slice(0, url.lastIndexOf("/") + 1);
            }
            return dir;
        };
        /**
         * Get the current script's URL by throwing an `Error` and analyzing it.
         *
         * @returns String or `undefined`
         * @private
         */
        var _getCurrentScriptUrlFromErrorStack = function(stack) {
            var url, matches;
            if (typeof stack === "string" && stack) {
                matches = stack.match(/^(?:|[^:@]*@|.+\)@(?=http[s]?|file)|.+?\s+(?: at |@)(?:[^:\(]+ )*[\(]?)((?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/);
                if (matches && matches[1]) {
                    url = matches[1];
                } else {
                    matches = stack.match(/\)@((?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/);
                    if (matches && matches[1]) {
                        url = matches[1];
                    }
                }
            }
            return url;
        };
        /**
         * Get the current script's URL by throwing an `Error` and analyzing it.
         *
         * @returns String or `undefined`
         * @private
         */
        var _getCurrentScriptUrlFromError = function() {
            var url, err;
            try {
                throw new _Error();
            } catch (e) {
                err = e;
            }
            if (err) {
                url = err.sourceURL || err.fileName || _getCurrentScriptUrlFromErrorStack(err.stack);
            }
            return url;
        };
        /**
         * Get the current script's URL.
         *
         * @returns String or `undefined`
         * @private
         */
        var _getCurrentScriptUrl = function() {
            var jsPath, scripts, i;
            if (_document.currentScript && (jsPath = _document.currentScript.src)) {
                return jsPath;
            }
            scripts = _document.getElementsByTagName("script");
            if (scripts.length === 1) {
                return scripts[0].src || undefined;
            }
            if ("readyState" in scripts[0]) {
                for (i = scripts.length; i--; ) {
                    if (scripts[i].readyState === "interactive" && (jsPath = scripts[i].src)) {
                        return jsPath;
                    }
                }
            }
            if (_document.readyState === "loading" && (jsPath = scripts[scripts.length - 1].src)) {
                return jsPath;
            }
            if (jsPath = _getCurrentScriptUrlFromError()) {
                return jsPath;
            }
            return undefined;
        };
        /**
         * Get the unanimous parent directory of ALL script tags.
         * If any script tags are either (a) inline or (b) from differing parent
         * directories, this method must return `undefined`.
         *
         * @returns String or `undefined`
         * @private
         */
        var _getUnanimousScriptParentDir = function() {
            var i, jsDir, jsPath, scripts = _document.getElementsByTagName("script");
            for (i = scripts.length; i--; ) {
                if (!(jsPath = scripts[i].src)) {
                    jsDir = null;
                    break;
                }
                jsPath = _getDirPathOfUrl(jsPath);
                if (jsDir == null) {
                    jsDir = jsPath;
                } else if (jsDir !== jsPath) {
                    jsDir = null;
                    break;
                }
            }
            return jsDir || undefined;
        };
        /**
         * Get the presumed location of the "ZeroClipboard.swf" file, based on the location
         * of the executing JavaScript file (e.g. "ZeroClipboard.js", etc.).
         *
         * @returns String
         * @private
         */
        var _getDefaultSwfPath = function() {
            var jsDir = _getDirPathOfUrl(_getCurrentScriptUrl()) || _getUnanimousScriptParentDir() || "";
            return jsDir + "ZeroClipboard.swf";
        };
        /**
         * Keep track of the state of the Flash object.
         * @private
         */
        var _flashState = {
            bridge: null,
            version: "0.0.0",
            pluginType: "unknown",
            disabled: null,
            outdated: null,
            unavailable: null,
            deactivated: null,
            overdue: null,
            ready: null
        };
        /**
         * The minimum Flash Player version required to use ZeroClipboard completely.
         * @readonly
         * @private
         */
        var _minimumFlashVersion = "11.0.0";
        /**
         * Keep track of all event listener registrations.
         * @private
         */
        var _handlers = {};
        /**
         * Keep track of the currently activated element.
         * @private
         */
        var _currentElement;
        /**
         * Keep track of the element that was activated when a `copy` process started.
         * @private
         */
        var _copyTarget;
        /**
         * Keep track of data for the pending clipboard transaction.
         * @private
         */
        var _clipData = {};
        /**
         * Keep track of data formats for the pending clipboard transaction.
         * @private
         */
        var _clipDataFormatMap = null;
        /**
         * The `message` store for events
         * @private
         */
        var _eventMessages = {
            ready: "Flash communication is established",
            error: {
                "flash-disabled": "Flash is disabled or not installed",
                "flash-outdated": "Flash is too outdated to support ZeroClipboard",
                "flash-unavailable": "Flash is unable to communicate bidirectionally with JavaScript",
                "flash-deactivated": "Flash is too outdated for your browser and/or is configured as click-to-activate",
                "flash-overdue": "Flash communication was established but NOT within the acceptable time limit"
            }
        };
        /**
         * ZeroClipboard configuration defaults for the Core module.
         * @private
         */
        var _globalConfig = {
            swfPath: _getDefaultSwfPath(),
            trustedDomains: window.location.host ? [ window.location.host ] : [],
            cacheBust: true,
            forceEnhancedClipboard: false,
            flashLoadTimeout: 3e4,
            autoActivate: true,
            bubbleEvents: true,
            containerId: "global-zeroclipboard-html-bridge",
            containerClass: "global-zeroclipboard-container",
            swfObjectId: "global-zeroclipboard-flash-bridge",
            hoverClass: "zeroclipboard-is-hover",
            activeClass: "zeroclipboard-is-active",
            forceHandCursor: false,
            title: null,
            zIndex: 999999999
        };
        /**
         * The underlying implementation of `ZeroClipboard.config`.
         * @private
         */
        var _config = function(options) {
            if (typeof options === "object" && options !== null) {
                for (var prop in options) {
                    if (_hasOwn.call(options, prop)) {
                        if (/^(?:forceHandCursor|title|zIndex|bubbleEvents)$/.test(prop)) {
                            _globalConfig[prop] = options[prop];
                        } else if (_flashState.bridge == null) {
                            if (prop === "containerId" || prop === "swfObjectId") {
                                if (_isValidHtml4Id(options[prop])) {
                                    _globalConfig[prop] = options[prop];
                                } else {
                                    throw new Error("The specified `" + prop + "` value is not valid as an HTML4 Element ID");
                                }
                            } else {
                                _globalConfig[prop] = options[prop];
                            }
                        }
                    }
                }
            }
            if (typeof options === "string" && options) {
                if (_hasOwn.call(_globalConfig, options)) {
                    return _globalConfig[options];
                }
                return;
            }
            return _deepCopy(_globalConfig);
        };
        /**
         * The underlying implementation of `ZeroClipboard.state`.
         * @private
         */
        var _state = function() {
            return {
                browser: _pick(_navigator, [ "userAgent", "platform", "appName" ]),
                flash: _omit(_flashState, [ "bridge" ]),
                zeroclipboard: {
                    version: ZeroClipboard.version,
                    config: ZeroClipboard.config()
                }
            };
        };
        /**
         * The underlying implementation of `ZeroClipboard.isFlashUnusable`.
         * @private
         */
        var _isFlashUnusable = function() {
            return !!(_flashState.disabled || _flashState.outdated || _flashState.unavailable || _flashState.deactivated);
        };
        /**
         * The underlying implementation of `ZeroClipboard.on`.
         * @private
         */
        var _on = function(eventType, listener) {
            var i, len, events, added = {};
            if (typeof eventType === "string" && eventType) {
                events = eventType.toLowerCase().split(/\s+/);
            } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") {
                for (i in eventType) {
                    if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") {
                        ZeroClipboard.on(i, eventType[i]);
                    }
                }
            }
            if (events && events.length) {
                for (i = 0, len = events.length; i < len; i++) {
                    eventType = events[i].replace(/^on/, "");
                    added[eventType] = true;
                    if (!_handlers[eventType]) {
                        _handlers[eventType] = [];
                    }
                    _handlers[eventType].push(listener);
                }
                if (added.ready && _flashState.ready) {
                    ZeroClipboard.emit({
                        type: "ready"
                    });
                }
                if (added.error) {
                    var errorTypes = [ "disabled", "outdated", "unavailable", "deactivated", "overdue" ];
                    for (i = 0, len = errorTypes.length; i < len; i++) {
                        if (_flashState[errorTypes[i]] === true) {
                            ZeroClipboard.emit({
                                type: "error",
                                name: "flash-" + errorTypes[i]
                            });
                            break;
                        }
                    }
                }
            }
            return ZeroClipboard;
        };
        /**
         * The underlying implementation of `ZeroClipboard.off`.
         * @private
         */
        var _off = function(eventType, listener) {
            var i, len, foundIndex, events, perEventHandlers;
            if (arguments.length === 0) {
                events = _keys(_handlers);
            } else if (typeof eventType === "string" && eventType) {
                events = eventType.split(/\s+/);
            } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") {
                for (i in eventType) {
                    if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") {
                        ZeroClipboard.off(i, eventType[i]);
                    }
                }
            }
            if (events && events.length) {
                for (i = 0, len = events.length; i < len; i++) {
                    eventType = events[i].toLowerCase().replace(/^on/, "");
                    perEventHandlers = _handlers[eventType];
                    if (perEventHandlers && perEventHandlers.length) {
                        if (listener) {
                            foundIndex = perEventHandlers.indexOf(listener);
                            while (foundIndex !== -1) {
                                perEventHandlers.splice(foundIndex, 1);
                                foundIndex = perEventHandlers.indexOf(listener, foundIndex);
                            }
                        } else {
                            perEventHandlers.length = 0;
                        }
                    }
                }
            }
            return ZeroClipboard;
        };
        /**
         * The underlying implementation of `ZeroClipboard.handlers`.
         * @private
         */
        var _listeners = function(eventType) {
            var copy;
            if (typeof eventType === "string" && eventType) {
                copy = _deepCopy(_handlers[eventType]) || null;
            } else {
                copy = _deepCopy(_handlers);
            }
            return copy;
        };
        /**
         * The underlying implementation of `ZeroClipboard.emit`.
         * @private
         */
        var _emit = function(event) {
            var eventCopy, returnVal, tmp;
            event = _createEvent(event);
            if (!event) {
                return;
            }
            if (_preprocessEvent(event)) {
                return;
            }
            if (event.type === "ready" && _flashState.overdue === true) {
                return ZeroClipboard.emit({
                    type: "error",
                    name: "flash-overdue"
                });
            }
            eventCopy = _extend({}, event);
            _dispatchCallbacks.call(this, eventCopy);
            if (event.type === "copy") {
                tmp = _mapClipDataToFlash(_clipData);
                returnVal = tmp.data;
                _clipDataFormatMap = tmp.formatMap;
            }
            return returnVal;
        };
        /**
         * The underlying implementation of `ZeroClipboard.create`.
         * @private
         */
        var _create = function() {
            if (typeof _flashState.ready !== "boolean") {
                _flashState.ready = false;
            }
            if (!ZeroClipboard.isFlashUnusable() && _flashState.bridge === null) {
                var maxWait = _globalConfig.flashLoadTimeout;
                if (typeof maxWait === "number" && maxWait >= 0) {
                    _setTimeout(function() {
                        if (typeof _flashState.deactivated !== "boolean") {
                            _flashState.deactivated = true;
                        }
                        if (_flashState.deactivated === true) {
                            ZeroClipboard.emit({
                                type: "error",
                                name: "flash-deactivated"
                            });
                        }
                    }, maxWait);
                }
                _flashState.overdue = false;
                _embedSwf();
            }
        };
        /**
         * The underlying implementation of `ZeroClipboard.destroy`.
         * @private
         */
        var _destroy = function() {
            ZeroClipboard.clearData();
            ZeroClipboard.blur();
            ZeroClipboard.emit("destroy");
            _unembedSwf();
            ZeroClipboard.off();
        };
        /**
         * The underlying implementation of `ZeroClipboard.setData`.
         * @private
         */
        var _setData = function(format, data) {
            var dataObj;
            if (typeof format === "object" && format && typeof data === "undefined") {
                dataObj = format;
                ZeroClipboard.clearData();
            } else if (typeof format === "string" && format) {
                dataObj = {};
                dataObj[format] = data;
            } else {
                return;
            }
            for (var dataFormat in dataObj) {
                if (typeof dataFormat === "string" && dataFormat && _hasOwn.call(dataObj, dataFormat) && typeof dataObj[dataFormat] === "string" && dataObj[dataFormat]) {
                    _clipData[dataFormat] = dataObj[dataFormat];
                }
            }
        };
        /**
         * The underlying implementation of `ZeroClipboard.clearData`.
         * @private
         */
        var _clearData = function(format) {
            if (typeof format === "undefined") {
                _deleteOwnProperties(_clipData);
                _clipDataFormatMap = null;
            } else if (typeof format === "string" && _hasOwn.call(_clipData, format)) {
                delete _clipData[format];
            }
        };
        /**
         * The underlying implementation of `ZeroClipboard.getData`.
         * @private
         */
        var _getData = function(format) {
            if (typeof format === "undefined") {
                return _deepCopy(_clipData);
            } else if (typeof format === "string" && _hasOwn.call(_clipData, format)) {
                return _clipData[format];
            }
        };
        /**
         * The underlying implementation of `ZeroClipboard.focus`/`ZeroClipboard.activate`.
         * @private
         */
        var _focus = function(element) {
            if (!(element && element.nodeType === 1)) {
                return;
            }
            if (_currentElement) {
                _removeClass(_currentElement, _globalConfig.activeClass);
                if (_currentElement !== element) {
                    _removeClass(_currentElement, _globalConfig.hoverClass);
                }
            }
            _currentElement = element;
            _addClass(element, _globalConfig.hoverClass);
            var newTitle = element.getAttribute("title") || _globalConfig.title;
            if (typeof newTitle === "string" && newTitle) {
                var htmlBridge = _getHtmlBridge(_flashState.bridge);
                if (htmlBridge) {
                    htmlBridge.setAttribute("title", newTitle);
                }
            }
            var useHandCursor = _globalConfig.forceHandCursor === true || _getStyle(element, "cursor") === "pointer";
            _setHandCursor(useHandCursor);
            _reposition();
        };
        /**
         * The underlying implementation of `ZeroClipboard.blur`/`ZeroClipboard.deactivate`.
         * @private
         */
        var _blur = function() {
            var htmlBridge = _getHtmlBridge(_flashState.bridge);
            if (htmlBridge) {
                htmlBridge.removeAttribute("title");
                htmlBridge.style.left = "0px";
                htmlBridge.style.top = "-9999px";
                htmlBridge.style.width = "1px";
                htmlBridge.style.top = "1px";
            }
            if (_currentElement) {
                _removeClass(_currentElement, _globalConfig.hoverClass);
                _removeClass(_currentElement, _globalConfig.activeClass);
                _currentElement = null;
            }
        };
        /**
         * The underlying implementation of `ZeroClipboard.activeElement`.
         * @private
         */
        var _activeElement = function() {
            return _currentElement || null;
        };
        /**
         * Check if a value is a valid HTML4 `ID` or `Name` token.
         * @private
         */
        var _isValidHtml4Id = function(id) {
            return typeof id === "string" && id && /^[A-Za-z][A-Za-z0-9_:\-\.]*$/.test(id);
        };
        /**
         * Create or update an `event` object, based on the `eventType`.
         * @private
         */
        var _createEvent = function(event) {
            var eventType;
            if (typeof event === "string" && event) {
                eventType = event;
                event = {};
            } else if (typeof event === "object" && event && typeof event.type === "string" && event.type) {
                eventType = event.type;
            }
            if (!eventType) {
                return;
            }
            if (!event.target && /^(copy|aftercopy|_click)$/.test(eventType.toLowerCase())) {
                event.target = _copyTarget;
            }
            _extend(event, {
                type: eventType.toLowerCase(),
                target: event.target || _currentElement || null,
                relatedTarget: event.relatedTarget || null,
                currentTarget: _flashState && _flashState.bridge || null,
                timeStamp: event.timeStamp || _now() || null
            });
            var msg = _eventMessages[event.type];
            if (event.type === "error" && event.name && msg) {
                msg = msg[event.name];
            }
            if (msg) {
                event.message = msg;
            }
            if (event.type === "ready") {
                _extend(event, {
                    target: null,
                    version: _flashState.version
                });
            }
            if (event.type === "error") {
                if (/^flash-(disabled|outdated|unavailable|deactivated|overdue)$/.test(event.name)) {
                    _extend(event, {
                        target: null,
                        minimumVersion: _minimumFlashVersion
                    });
                }
                if (/^flash-(outdated|unavailable|deactivated|overdue)$/.test(event.name)) {
                    _extend(event, {
                        version: _flashState.version
                    });
                }
            }
            if (event.type === "copy") {
                event.clipboardData = {
                    setData: ZeroClipboard.setData,
                    clearData: ZeroClipboard.clearData
                };
            }
            if (event.type === "aftercopy") {
                event = _mapClipResultsFromFlash(event, _clipDataFormatMap);
            }
            if (event.target && !event.relatedTarget) {
                event.relatedTarget = _getRelatedTarget(event.target);
            }
            event = _addMouseData(event);
            return event;
        };
        /**
         * Get a relatedTarget from the target's `data-clipboard-target` attribute
         * @private
         */
        var _getRelatedTarget = function(targetEl) {
            var relatedTargetId = targetEl && targetEl.getAttribute && targetEl.getAttribute("data-clipboard-target");
            return relatedTargetId ? _document.getElementById(relatedTargetId) : null;
        };
        /**
         * Add element and position data to `MouseEvent` instances
         * @private
         */
        var _addMouseData = function(event) {
            if (event && /^_(?:click|mouse(?:over|out|down|up|move))$/.test(event.type)) {
                var srcElement = event.target;
                var fromElement = event.type === "_mouseover" && event.relatedTarget ? event.relatedTarget : undefined;
                var toElement = event.type === "_mouseout" && event.relatedTarget ? event.relatedTarget : undefined;
                var pos = _getDOMObjectPosition(srcElement);
                var screenLeft = _window.screenLeft || _window.screenX || 0;
                var screenTop = _window.screenTop || _window.screenY || 0;
                var scrollLeft = _document.body.scrollLeft + _document.documentElement.scrollLeft;
                var scrollTop = _document.body.scrollTop + _document.documentElement.scrollTop;
                var pageX = pos.left + (typeof event._stageX === "number" ? event._stageX : 0);
                var pageY = pos.top + (typeof event._stageY === "number" ? event._stageY : 0);
                var clientX = pageX - scrollLeft;
                var clientY = pageY - scrollTop;
                var screenX = screenLeft + clientX;
                var screenY = screenTop + clientY;
                var moveX = typeof event.movementX === "number" ? event.movementX : 0;
                var moveY = typeof event.movementY === "number" ? event.movementY : 0;
                delete event._stageX;
                delete event._stageY;
                _extend(event, {
                    srcElement: srcElement,
                    fromElement: fromElement,
                    toElement: toElement,
                    screenX: screenX,
                    screenY: screenY,
                    pageX: pageX,
                    pageY: pageY,
                    clientX: clientX,
                    clientY: clientY,
                    x: clientX,
                    y: clientY,
                    movementX: moveX,
                    movementY: moveY,
                    offsetX: 0,
                    offsetY: 0,
                    layerX: 0,
                    layerY: 0
                });
            }
            return event;
        };
        /**
         * Determine if an event's registered handlers should be execute synchronously or asynchronously.
         *
         * @returns {boolean}
         * @private
         */
        var _shouldPerformAsync = function(event) {
            var eventType = event && typeof event.type === "string" && event.type || "";
            return !/^(?:(?:before)?copy|destroy)$/.test(eventType);
        };
        /**
         * Control if a callback should be executed asynchronously or not.
         *
         * @returns `undefined`
         * @private
         */
        var _dispatchCallback = function(func, context, args, async) {
            if (async) {
                _setTimeout(function() {
                    func.apply(context, args);
                }, 0);
            } else {
                func.apply(context, args);
            }
        };
        /**
         * Handle the actual dispatching of events to client instances.
         *
         * @returns `undefined`
         * @private
         */
        var _dispatchCallbacks = function(event) {
            if (!(typeof event === "object" && event && event.type)) {
                return;
            }
            var async = _shouldPerformAsync(event);
            var wildcardTypeHandlers = _handlers["*"] || [];
            var specificTypeHandlers = _handlers[event.type] || [];
            var handlers = wildcardTypeHandlers.concat(specificTypeHandlers);
            if (handlers && handlers.length) {
                var i, len, func, context, eventCopy, originalContext = this;
                for (i = 0, len = handlers.length; i < len; i++) {
                    func = handlers[i];
                    context = originalContext;
                    if (typeof func === "string" && typeof _window[func] === "function") {
                        func = _window[func];
                    }
                    if (typeof func === "object" && func && typeof func.handleEvent === "function") {
                        context = func;
                        func = func.handleEvent;
                    }
                    if (typeof func === "function") {
                        eventCopy = _extend({}, event);
                        _dispatchCallback(func, context, [ eventCopy ], async);
                    }
                }
            }
            return this;
        };
        /**
         * Preprocess any special behaviors, reactions, or state changes after receiving this event.
         * Executes only once per event emitted, NOT once per client.
         * @private
         */
        var _preprocessEvent = function(event) {
            var element = event.target || _currentElement || null;
            var sourceIsSwf = event._source === "swf";
            delete event._source;
            var flashErrorNames = [ "flash-disabled", "flash-outdated", "flash-unavailable", "flash-deactivated", "flash-overdue" ];
            switch (event.type) {
                case "error":
                    if (flashErrorNames.indexOf(event.name) !== -1) {
                        _extend(_flashState, {
                            disabled: event.name === "flash-disabled",
                            outdated: event.name === "flash-outdated",
                            unavailable: event.name === "flash-unavailable",
                            deactivated: event.name === "flash-deactivated",
                            overdue: event.name === "flash-overdue",
                            ready: false
                        });
                    }
                    break;

                case "ready":
                    var wasDeactivated = _flashState.deactivated === true;
                    _extend(_flashState, {
                        disabled: false,
                        outdated: false,
                        unavailable: false,
                        deactivated: false,
                        overdue: wasDeactivated,
                        ready: !wasDeactivated
                    });
                    break;

                case "beforecopy":
                    _copyTarget = element;
                    break;

                case "copy":
                    var textContent, htmlContent, targetEl = event.relatedTarget;
                    if (!(_clipData["text/html"] || _clipData["text/plain"]) && targetEl && (htmlContent = targetEl.value || targetEl.outerHTML || targetEl.innerHTML) && (textContent = targetEl.value || targetEl.textContent || targetEl.innerText)) {
                        event.clipboardData.clearData();
                        event.clipboardData.setData("text/plain", textContent);
                        if (htmlContent !== textContent) {
                            event.clipboardData.setData("text/html", htmlContent);
                        }
                    } else if (!_clipData["text/plain"] && event.target && (textContent = event.target.getAttribute("data-clipboard-text"))) {
                        event.clipboardData.clearData();
                        event.clipboardData.setData("text/plain", textContent);
                    }
                    break;

                case "aftercopy":
                    ZeroClipboard.clearData();
                    if (element && element !== _safeActiveElement() && element.focus) {
                        element.focus();
                    }
                    break;

                case "_mouseover":
                    ZeroClipboard.focus(element);
                    if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
                        if (element && element !== event.relatedTarget && !_containedBy(event.relatedTarget, element)) {
                            _fireMouseEvent(_extend({}, event, {
                                type: "mouseenter",
                                bubbles: false,
                                cancelable: false
                            }));
                        }
                        _fireMouseEvent(_extend({}, event, {
                            type: "mouseover"
                        }));
                    }
                    break;

                case "_mouseout":
                    ZeroClipboard.blur();
                    if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
                        if (element && element !== event.relatedTarget && !_containedBy(event.relatedTarget, element)) {
                            _fireMouseEvent(_extend({}, event, {
                                type: "mouseleave",
                                bubbles: false,
                                cancelable: false
                            }));
                        }
                        _fireMouseEvent(_extend({}, event, {
                            type: "mouseout"
                        }));
                    }
                    break;

                case "_mousedown":
                    _addClass(element, _globalConfig.activeClass);
                    if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
                        _fireMouseEvent(_extend({}, event, {
                            type: event.type.slice(1)
                        }));
                    }
                    break;

                case "_mouseup":
                    _removeClass(element, _globalConfig.activeClass);
                    if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
                        _fireMouseEvent(_extend({}, event, {
                            type: event.type.slice(1)
                        }));
                    }
                    break;

                case "_click":
                    _copyTarget = null;
                    if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
                        _fireMouseEvent(_extend({}, event, {
                            type: event.type.slice(1)
                        }));
                    }
                    break;

                case "_mousemove":
                    if (_globalConfig.bubbleEvents === true && sourceIsSwf) {
                        _fireMouseEvent(_extend({}, event, {
                            type: event.type.slice(1)
                        }));
                    }
                    break;
            }
            if (/^_(?:click|mouse(?:over|out|down|up|move))$/.test(event.type)) {
                return true;
            }
        };
        /**
         * Dispatch a synthetic MouseEvent.
         *
         * @returns `undefined`
         * @private
         */
        var _fireMouseEvent = function(event) {
            if (!(event && typeof event.type === "string" && event)) {
                return;
            }
            var e, target = event.target || null, doc = target && target.ownerDocument || _document, defaults = {
                view: doc.defaultView || _window,
                canBubble: true,
                cancelable: true,
                detail: event.type === "click" ? 1 : 0,
                button: typeof event.which === "number" ? event.which - 1 : typeof event.button === "number" ? event.button : doc.createEvent ? 0 : 1
            }, args = _extend(defaults, event);
            if (!target) {
                return;
            }
            if (doc.createEvent && target.dispatchEvent) {
                args = [ args.type, args.canBubble, args.cancelable, args.view, args.detail, args.screenX, args.screenY, args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey, args.button, args.relatedTarget ];
                e = doc.createEvent("MouseEvents");
                if (e.initMouseEvent) {
                    e.initMouseEvent.apply(e, args);
                    e._source = "js";
                    target.dispatchEvent(e);
                }
            }
        };
        /**
         * Create the HTML bridge element to embed the Flash object into.
         * @private
         */
        var _createHtmlBridge = function() {
            var container = _document.createElement("div");
            container.id = _globalConfig.containerId;
            container.className = _globalConfig.containerClass;
            container.style.position = "absolute";
            container.style.left = "0px";
            container.style.top = "-9999px";
            container.style.width = "1px";
            container.style.height = "1px";
            container.style.zIndex = "" + _getSafeZIndex(_globalConfig.zIndex);
            return container;
        };
        /**
         * Get the HTML element container that wraps the Flash bridge object/element.
         * @private
         */
        var _getHtmlBridge = function(flashBridge) {
            var htmlBridge = flashBridge && flashBridge.parentNode;
            while (htmlBridge && htmlBridge.nodeName === "OBJECT" && htmlBridge.parentNode) {
                htmlBridge = htmlBridge.parentNode;
            }
            return htmlBridge || null;
        };
        /**
         * Create the SWF object.
         *
         * @returns The SWF object reference.
         * @private
         */
        var _embedSwf = function() {
            var len, flashBridge = _flashState.bridge, container = _getHtmlBridge(flashBridge);
            if (!flashBridge) {
                var allowScriptAccess = _determineScriptAccess(_window.location.host, _globalConfig);
                var allowNetworking = allowScriptAccess === "never" ? "none" : "all";
                var flashvars = _vars(_globalConfig);
                var swfUrl = _globalConfig.swfPath + _cacheBust(_globalConfig.swfPath, _globalConfig);
                container = _createHtmlBridge();
                var divToBeReplaced = _document.createElement("div");
                container.appendChild(divToBeReplaced);
                _document.body.appendChild(container);
                var tmpDiv = _document.createElement("div");
                var oldIE = _flashState.pluginType === "activex";
                tmpDiv.innerHTML = '<object id="' + _globalConfig.swfObjectId + '" name="' + _globalConfig.swfObjectId + '" ' + 'width="100%" height="100%" ' + (oldIE ? 'classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000"' : 'type="application/x-shockwave-flash" data="' + swfUrl + '"') + ">" + (oldIE ? '<param name="movie" value="' + swfUrl + '"/>' : "") + '<param name="allowScriptAccess" value="' + allowScriptAccess + '"/>' + '<param name="allowNetworking" value="' + allowNetworking + '"/>' + '<param name="menu" value="false"/>' + '<param name="wmode" value="transparent"/>' + '<param name="flashvars" value="' + flashvars + '"/>' + "</object>";
                flashBridge = tmpDiv.firstChild;
                tmpDiv = null;
                _unwrap(flashBridge).ZeroClipboard = ZeroClipboard;
                container.replaceChild(flashBridge, divToBeReplaced);
            }
            if (!flashBridge) {
                flashBridge = _document[_globalConfig.swfObjectId];
                if (flashBridge && (len = flashBridge.length)) {
                    flashBridge = flashBridge[len - 1];
                }
                if (!flashBridge && container) {
                    flashBridge = container.firstChild;
                }
            }
            _flashState.bridge = flashBridge || null;
            return flashBridge;
        };
        /**
         * Destroy the SWF object.
         * @private
         */
        var _unembedSwf = function() {
            var flashBridge = _flashState.bridge;
            if (flashBridge) {
                var htmlBridge = _getHtmlBridge(flashBridge);
                if (htmlBridge) {
                    if (_flashState.pluginType === "activex" && "readyState" in flashBridge) {
                        flashBridge.style.display = "none";
                        (function removeSwfFromIE() {
                            if (flashBridge.readyState === 4) {
                                for (var prop in flashBridge) {
                                    if (typeof flashBridge[prop] === "function") {
                                        flashBridge[prop] = null;
                                    }
                                }
                                if (flashBridge.parentNode) {
                                    flashBridge.parentNode.removeChild(flashBridge);
                                }
                                if (htmlBridge.parentNode) {
                                    htmlBridge.parentNode.removeChild(htmlBridge);
                                }
                            } else {
                                _setTimeout(removeSwfFromIE, 10);
                            }
                        })();
                    } else {
                        if (flashBridge.parentNode) {
                            flashBridge.parentNode.removeChild(flashBridge);
                        }
                        if (htmlBridge.parentNode) {
                            htmlBridge.parentNode.removeChild(htmlBridge);
                        }
                    }
                }
                _flashState.ready = null;
                _flashState.bridge = null;
                _flashState.deactivated = null;
            }
        };
        /**
         * Map the data format names of the "clipData" to Flash-friendly names.
         *
         * @returns A new transformed object.
         * @private
         */
        var _mapClipDataToFlash = function(clipData) {
            var newClipData = {}, formatMap = {};
            if (!(typeof clipData === "object" && clipData)) {
                return;
            }
            for (var dataFormat in clipData) {
                if (dataFormat && _hasOwn.call(clipData, dataFormat) && typeof clipData[dataFormat] === "string" && clipData[dataFormat]) {
                    switch (dataFormat.toLowerCase()) {
                        case "text/plain":
                        case "text":
                        case "air:text":
                        case "flash:text":
                            newClipData.text = clipData[dataFormat];
                            formatMap.text = dataFormat;
                            break;

                        case "text/html":
                        case "html":
                        case "air:html":
                        case "flash:html":
                            newClipData.html = clipData[dataFormat];
                            formatMap.html = dataFormat;
                            break;

                        case "application/rtf":
                        case "text/rtf":
                        case "rtf":
                        case "richtext":
                        case "air:rtf":
                        case "flash:rtf":
                            newClipData.rtf = clipData[dataFormat];
                            formatMap.rtf = dataFormat;
                            break;

                        default:
                            break;
                    }
                }
            }
            return {
                data: newClipData,
                formatMap: formatMap
            };
        };
        /**
         * Map the data format names from Flash-friendly names back to their original "clipData" names (via a format mapping).
         *
         * @returns A new transformed object.
         * @private
         */
        var _mapClipResultsFromFlash = function(clipResults, formatMap) {
            if (!(typeof clipResults === "object" && clipResults && typeof formatMap === "object" && formatMap)) {
                return clipResults;
            }
            var newResults = {};
            for (var prop in clipResults) {
                if (_hasOwn.call(clipResults, prop)) {
                    if (prop !== "success" && prop !== "data") {
                        newResults[prop] = clipResults[prop];
                        continue;
                    }
                    newResults[prop] = {};
                    var tmpHash = clipResults[prop];
                    for (var dataFormat in tmpHash) {
                        if (dataFormat && _hasOwn.call(tmpHash, dataFormat) && _hasOwn.call(formatMap, dataFormat)) {
                            newResults[prop][formatMap[dataFormat]] = tmpHash[dataFormat];
                        }
                    }
                }
            }
            return newResults;
        };
        /**
         * Will look at a path, and will create a "?noCache={time}" or "&noCache={time}"
         * query param string to return. Does NOT append that string to the original path.
         * This is useful because ExternalInterface often breaks when a Flash SWF is cached.
         *
         * @returns The `noCache` query param with necessary "?"/"&" prefix.
         * @private
         */
        var _cacheBust = function(path, options) {
            var cacheBust = options == null || options && options.cacheBust === true;
            if (cacheBust) {
                return (path.indexOf("?") === -1 ? "?" : "&") + "noCache=" + _now();
            } else {
                return "";
            }
        };
        /**
         * Creates a query string for the FlashVars param.
         * Does NOT include the cache-busting query param.
         *
         * @returns FlashVars query string
         * @private
         */
        var _vars = function(options) {
            var i, len, domain, domains, str = "", trustedOriginsExpanded = [];
            if (options.trustedDomains) {
                if (typeof options.trustedDomains === "string") {
                    domains = [ options.trustedDomains ];
                } else if (typeof options.trustedDomains === "object" && "length" in options.trustedDomains) {
                    domains = options.trustedDomains;
                }
            }
            if (domains && domains.length) {
                for (i = 0, len = domains.length; i < len; i++) {
                    if (_hasOwn.call(domains, i) && domains[i] && typeof domains[i] === "string") {
                        domain = _extractDomain(domains[i]);
                        if (!domain) {
                            continue;
                        }
                        if (domain === "*") {
                            trustedOriginsExpanded.length = 0;
                            trustedOriginsExpanded.push(domain);
                            break;
                        }
                        trustedOriginsExpanded.push.apply(trustedOriginsExpanded, [ domain, "//" + domain, _window.location.protocol + "//" + domain ]);
                    }
                }
            }
            if (trustedOriginsExpanded.length) {
                str += "trustedOrigins=" + _encodeURIComponent(trustedOriginsExpanded.join(","));
            }
            if (options.forceEnhancedClipboard === true) {
                str += (str ? "&" : "") + "forceEnhancedClipboard=true";
            }
            if (typeof options.swfObjectId === "string" && options.swfObjectId) {
                str += (str ? "&" : "") + "swfObjectId=" + _encodeURIComponent(options.swfObjectId);
            }
            return str;
        };
        /**
         * Extract the domain (e.g. "github.com") from an origin (e.g. "https://github.com") or
         * URL (e.g. "https://github.com/zeroclipboard/zeroclipboard/").
         *
         * @returns the domain
         * @private
         */
        var _extractDomain = function(originOrUrl) {
            if (originOrUrl == null || originOrUrl === "") {
                return null;
            }
            originOrUrl = originOrUrl.replace(/^\s+|\s+$/g, "");
            if (originOrUrl === "") {
                return null;
            }
            var protocolIndex = originOrUrl.indexOf("//");
            originOrUrl = protocolIndex === -1 ? originOrUrl : originOrUrl.slice(protocolIndex + 2);
            var pathIndex = originOrUrl.indexOf("/");
            originOrUrl = pathIndex === -1 ? originOrUrl : protocolIndex === -1 || pathIndex === 0 ? null : originOrUrl.slice(0, pathIndex);
            if (originOrUrl && originOrUrl.slice(-4).toLowerCase() === ".swf") {
                return null;
            }
            return originOrUrl || null;
        };
        /**
         * Set `allowScriptAccess` based on `trustedDomains` and `window.location.host` vs. `swfPath`.
         *
         * @returns The appropriate script access level.
         * @private
         */
        var _determineScriptAccess = function() {
            var _extractAllDomains = function(origins) {
                var i, len, tmp, resultsArray = [];
                if (typeof origins === "string") {
                    origins = [ origins ];
                }
                if (!(typeof origins === "object" && origins && typeof origins.length === "number")) {
                    return resultsArray;
                }
                for (i = 0, len = origins.length; i < len; i++) {
                    if (_hasOwn.call(origins, i) && (tmp = _extractDomain(origins[i]))) {
                        if (tmp === "*") {
                            resultsArray.length = 0;
                            resultsArray.push("*");
                            break;
                        }
                        if (resultsArray.indexOf(tmp) === -1) {
                            resultsArray.push(tmp);
                        }
                    }
                }
                return resultsArray;
            };
            return function(currentDomain, configOptions) {
                var swfDomain = _extractDomain(configOptions.swfPath);
                if (swfDomain === null) {
                    swfDomain = currentDomain;
                }
                var trustedDomains = _extractAllDomains(configOptions.trustedDomains);
                var len = trustedDomains.length;
                if (len > 0) {
                    if (len === 1 && trustedDomains[0] === "*") {
                        return "always";
                    }
                    if (trustedDomains.indexOf(currentDomain) !== -1) {
                        if (len === 1 && currentDomain === swfDomain) {
                            return "sameDomain";
                        }
                        return "always";
                    }
                }
                return "never";
            };
        }();
        /**
         * Get the currently active/focused DOM element.
         *
         * @returns the currently active/focused element, or `null`
         * @private
         */
        var _safeActiveElement = function() {
            try {
                return _document.activeElement;
            } catch (err) {
                return null;
            }
        };
        /**
         * Add a class to an element, if it doesn't already have it.
         *
         * @returns The element, with its new class added.
         * @private
         */
        var _addClass = function(element, value) {
            if (!element || element.nodeType !== 1) {
                return element;
            }
            if (element.classList) {
                if (!element.classList.contains(value)) {
                    element.classList.add(value);
                }
                return element;
            }
            if (value && typeof value === "string") {
                var classNames = (value || "").split(/\s+/);
                if (element.nodeType === 1) {
                    if (!element.className) {
                        element.className = value;
                    } else {
                        var className = " " + element.className + " ", setClass = element.className;
                        for (var c = 0, cl = classNames.length; c < cl; c++) {
                            if (className.indexOf(" " + classNames[c] + " ") < 0) {
                                setClass += " " + classNames[c];
                            }
                        }
                        element.className = setClass.replace(/^\s+|\s+$/g, "");
                    }
                }
            }
            return element;
        };
        /**
         * Remove a class from an element, if it has it.
         *
         * @returns The element, with its class removed.
         * @private
         */
        var _removeClass = function(element, value) {
            if (!element || element.nodeType !== 1) {
                return element;
            }
            if (element.classList) {
                if (element.classList.contains(value)) {
                    element.classList.remove(value);
                }
                return element;
            }
            if (typeof value === "string" && value) {
                var classNames = value.split(/\s+/);
                if (element.nodeType === 1 && element.className) {
                    var className = (" " + element.className + " ").replace(/[\n\t]/g, " ");
                    for (var c = 0, cl = classNames.length; c < cl; c++) {
                        className = className.replace(" " + classNames[c] + " ", " ");
                    }
                    element.className = className.replace(/^\s+|\s+$/g, "");
                }
            }
            return element;
        };
        /**
         * Attempt to interpret the element's CSS styling. If `prop` is `"cursor"`,
         * then we assume that it should be a hand ("pointer") cursor if the element
         * is an anchor element ("a" tag).
         *
         * @returns The computed style property.
         * @private
         */
        var _getStyle = function(el, prop) {
            var value = _window.getComputedStyle(el, null).getPropertyValue(prop);
            if (prop === "cursor") {
                if (!value || value === "auto") {
                    if (el.nodeName === "A") {
                        return "pointer";
                    }
                }
            }
            return value;
        };
        /**
         * Get the zoom factor of the browser. Always returns `1.0`, except at
         * non-default zoom levels in IE<8 and some older versions of WebKit.
         *
         * @returns Floating unit percentage of the zoom factor (e.g. 150% = `1.5`).
         * @private
         */
        var _getZoomFactor = function() {
            var rect, physicalWidth, logicalWidth, zoomFactor = 1;
            if (typeof _document.body.getBoundingClientRect === "function") {
                rect = _document.body.getBoundingClientRect();
                physicalWidth = rect.right - rect.left;
                logicalWidth = _document.body.offsetWidth;
                zoomFactor = _round(physicalWidth / logicalWidth * 100) / 100;
            }
            return zoomFactor;
        };
        /**
         * Get the DOM positioning info of an element.
         *
         * @returns Object containing the element's position, width, and height.
         * @private
         */
        var _getDOMObjectPosition = function(obj) {
            var info = {
                left: 0,
                top: 0,
                width: 0,
                height: 0
            };
            if (obj.getBoundingClientRect) {
                var rect = obj.getBoundingClientRect();
                var pageXOffset, pageYOffset, zoomFactor;
                if ("pageXOffset" in _window && "pageYOffset" in _window) {
                    pageXOffset = _window.pageXOffset;
                    pageYOffset = _window.pageYOffset;
                } else {
                    zoomFactor = _getZoomFactor();
                    pageXOffset = _round(_document.documentElement.scrollLeft / zoomFactor);
                    pageYOffset = _round(_document.documentElement.scrollTop / zoomFactor);
                }
                var leftBorderWidth = _document.documentElement.clientLeft || 0;
                var topBorderWidth = _document.documentElement.clientTop || 0;
                info.left = rect.left + pageXOffset - leftBorderWidth;
                info.top = rect.top + pageYOffset - topBorderWidth;
                info.width = "width" in rect ? rect.width : rect.right - rect.left;
                info.height = "height" in rect ? rect.height : rect.bottom - rect.top;
            }
            return info;
        };
        /**
         * Reposition the Flash object to cover the currently activated element.
         *
         * @returns `undefined`
         * @private
         */
        var _reposition = function() {
            var htmlBridge;
            if (_currentElement && (htmlBridge = _getHtmlBridge(_flashState.bridge))) {
                var pos = _getDOMObjectPosition(_currentElement);
                _extend(htmlBridge.style, {
                    width: pos.width + "px",
                    height: pos.height + "px",
                    top: pos.top + "px",
                    left: pos.left + "px",
                    zIndex: "" + _getSafeZIndex(_globalConfig.zIndex)
                });
            }
        };
        /**
         * Sends a signal to the Flash object to display the hand cursor if `true`.
         *
         * @returns `undefined`
         * @private
         */
        var _setHandCursor = function(enabled) {
            if (_flashState.ready === true) {
                if (_flashState.bridge && typeof _flashState.bridge.setHandCursor === "function") {
                    _flashState.bridge.setHandCursor(enabled);
                } else {
                    _flashState.ready = false;
                }
            }
        };
        /**
         * Get a safe value for `zIndex`
         *
         * @returns an integer, or "auto"
         * @private
         */
        var _getSafeZIndex = function(val) {
            if (/^(?:auto|inherit)$/.test(val)) {
                return val;
            }
            var zIndex;
            if (typeof val === "number" && !_isNaN(val)) {
                zIndex = val;
            } else if (typeof val === "string") {
                zIndex = _getSafeZIndex(_parseInt(val, 10));
            }
            return typeof zIndex === "number" ? zIndex : "auto";
        };
        /**
         * Detect the Flash Player status, version, and plugin type.
         *
         * @see {@link https://code.google.com/p/doctype-mirror/wiki/ArticleDetectFlash#The_code}
         * @see {@link http://stackoverflow.com/questions/12866060/detecting-pepper-ppapi-flash-with-javascript}
         *
         * @returns `undefined`
         * @private
         */
        var _detectFlashSupport = function(ActiveXObject) {
            var plugin, ax, mimeType, hasFlash = false, isActiveX = false, isPPAPI = false, flashVersion = "";
            /**
             * Derived from Apple's suggested sniffer.
             * @param {String} desc e.g. "Shockwave Flash 7.0 r61"
             * @returns {String} "7.0.61"
             * @private
             */
            function parseFlashVersion(desc) {
                var matches = desc.match(/[\d]+/g);
                matches.length = 3;
                return matches.join(".");
            }
            function isPepperFlash(flashPlayerFileName) {
                return !!flashPlayerFileName && (flashPlayerFileName = flashPlayerFileName.toLowerCase()) && (/^(pepflashplayer\.dll|libpepflashplayer\.so|pepperflashplayer\.plugin)$/.test(flashPlayerFileName) || flashPlayerFileName.slice(-13) === "chrome.plugin");
            }
            function inspectPlugin(plugin) {
                if (plugin) {
                    hasFlash = true;
                    if (plugin.version) {
                        flashVersion = parseFlashVersion(plugin.version);
                    }
                    if (!flashVersion && plugin.description) {
                        flashVersion = parseFlashVersion(plugin.description);
                    }
                    if (plugin.filename) {
                        isPPAPI = isPepperFlash(plugin.filename);
                    }
                }
            }
            if (_navigator.plugins && _navigator.plugins.length) {
                plugin = _navigator.plugins["Shockwave Flash"];
                inspectPlugin(plugin);
                if (_navigator.plugins["Shockwave Flash 2.0"]) {
                    hasFlash = true;
                    flashVersion = "2.0.0.11";
                }
            } else if (_navigator.mimeTypes && _navigator.mimeTypes.length) {
                mimeType = _navigator.mimeTypes["application/x-shockwave-flash"];
                plugin = mimeType && mimeType.enabledPlugin;
                inspectPlugin(plugin);
            } else if (typeof ActiveXObject !== "undefined") {
                isActiveX = true;
                try {
                    ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.7");
                    hasFlash = true;
                    flashVersion = parseFlashVersion(ax.GetVariable("$version"));
                } catch (e1) {
                    try {
                        ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.6");
                        hasFlash = true;
                        flashVersion = "6.0.21";
                    } catch (e2) {
                        try {
                            ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
                            hasFlash = true;
                            flashVersion = parseFlashVersion(ax.GetVariable("$version"));
                        } catch (e3) {
                            isActiveX = false;
                        }
                    }
                }
            }
            _flashState.disabled = hasFlash !== true;
            _flashState.outdated = flashVersion && _parseFloat(flashVersion) < _parseFloat(_minimumFlashVersion);
            _flashState.version = flashVersion || "0.0.0";
            _flashState.pluginType = isPPAPI ? "pepper" : isActiveX ? "activex" : hasFlash ? "netscape" : "unknown";
        };
        /**
         * Invoke the Flash detection algorithms immediately upon inclusion so we're not waiting later.
         */
        _detectFlashSupport(_ActiveXObject);
        /**
         * A shell constructor for `ZeroClipboard` client instances.
         *
         * @constructor
         */
        var ZeroClipboard = function() {
            if (!(this instanceof ZeroClipboard)) {
                return new ZeroClipboard();
            }
            if (typeof ZeroClipboard._createClient === "function") {
                ZeroClipboard._createClient.apply(this, _args(arguments));
            }
        };
        /**
         * The ZeroClipboard library's version number.
         *
         * @static
         * @readonly
         * @property {string}
         */
        _defineProperty(ZeroClipboard, "version", {
            value: "2.1.6",
            writable: false,
            configurable: true,
            enumerable: true
        });
        /**
         * Update or get a copy of the ZeroClipboard global configuration.
         * Returns a copy of the current/updated configuration.
         *
         * @returns Object
         * @static
         */
        ZeroClipboard.config = function() {
            return _config.apply(this, _args(arguments));
        };
        /**
         * Diagnostic method that describes the state of the browser, Flash Player, and ZeroClipboard.
         *
         * @returns Object
         * @static
         */
        ZeroClipboard.state = function() {
            return _state.apply(this, _args(arguments));
        };
        /**
         * Check if Flash is unusable for any reason: disabled, outdated, deactivated, etc.
         *
         * @returns Boolean
         * @static
         */
        ZeroClipboard.isFlashUnusable = function() {
            return _isFlashUnusable.apply(this, _args(arguments));
        };
        /**
         * Register an event listener.
         *
         * @returns `ZeroClipboard`
         * @static
         */
        ZeroClipboard.on = function() {
            return _on.apply(this, _args(arguments));
        };
        /**
         * Unregister an event listener.
         * If no `listener` function/object is provided, it will unregister all listeners for the provided `eventType`.
         * If no `eventType` is provided, it will unregister all listeners for every event type.
         *
         * @returns `ZeroClipboard`
         * @static
         */
        ZeroClipboard.off = function() {
            return _off.apply(this, _args(arguments));
        };
        /**
         * Retrieve event listeners for an `eventType`.
         * If no `eventType` is provided, it will retrieve all listeners for every event type.
         *
         * @returns array of listeners for the `eventType`; if no `eventType`, then a map/hash object of listeners for all event types; or `null`
         */
        ZeroClipboard.handlers = function() {
            return _listeners.apply(this, _args(arguments));
        };
        /**
         * Event emission receiver from the Flash object, forwarding to any registered JavaScript event listeners.
         *
         * @returns For the "copy" event, returns the Flash-friendly "clipData" object; otherwise `undefined`.
         * @static
         */
        ZeroClipboard.emit = function() {
            return _emit.apply(this, _args(arguments));
        };
        /**
         * Create and embed the Flash object.
         *
         * @returns The Flash object
         * @static
         */
        ZeroClipboard.create = function() {
            return _create.apply(this, _args(arguments));
        };
        /**
         * Self-destruct and clean up everything, including the embedded Flash object.
         *
         * @returns `undefined`
         * @static
         */
        ZeroClipboard.destroy = function() {
            return _destroy.apply(this, _args(arguments));
        };
        /**
         * Set the pending data for clipboard injection.
         *
         * @returns `undefined`
         * @static
         */
        ZeroClipboard.setData = function() {
            return _setData.apply(this, _args(arguments));
        };
        /**
         * Clear the pending data for clipboard injection.
         * If no `format` is provided, all pending data formats will be cleared.
         *
         * @returns `undefined`
         * @static
         */
        ZeroClipboard.clearData = function() {
            return _clearData.apply(this, _args(arguments));
        };
        /**
         * Get a copy of the pending data for clipboard injection.
         * If no `format` is provided, a copy of ALL pending data formats will be returned.
         *
         * @returns `String` or `Object`
         * @static
         */
        ZeroClipboard.getData = function() {
            return _getData.apply(this, _args(arguments));
        };
        /**
         * Sets the current HTML object that the Flash object should overlay. This will put the global
         * Flash object on top of the current element; depending on the setup, this may also set the
         * pending clipboard text data as well as the Flash object's wrapping element's title attribute
         * based on the underlying HTML element and ZeroClipboard configuration.
         *
         * @returns `undefined`
         * @static
         */
        ZeroClipboard.focus = ZeroClipboard.activate = function() {
            return _focus.apply(this, _args(arguments));
        };
        /**
         * Un-overlays the Flash object. This will put the global Flash object off-screen; depending on
         * the setup, this may also unset the Flash object's wrapping element's title attribute based on
         * the underlying HTML element and ZeroClipboard configuration.
         *
         * @returns `undefined`
         * @static
         */
        ZeroClipboard.blur = ZeroClipboard.deactivate = function() {
            return _blur.apply(this, _args(arguments));
        };
        /**
         * Returns the currently focused/"activated" HTML element that the Flash object is wrapping.
         *
         * @returns `HTMLElement` or `null`
         * @static
         */
        ZeroClipboard.activeElement = function() {
            return _activeElement.apply(this, _args(arguments));
        };
        /**
         * Keep track of the ZeroClipboard client instance counter.
         */
        var _clientIdCounter = 0;
        /**
         * Keep track of the state of the client instances.
         *
         * Entry structure:
         *   _clientMeta[client.id] = {
 *     instance: client,
 *     elements: [],
 *     handlers: {}
 *   };
         */
        var _clientMeta = {};
        /**
         * Keep track of the ZeroClipboard clipped elements counter.
         */
        var _elementIdCounter = 0;
        /**
         * Keep track of the state of the clipped element relationships to clients.
         *
         * Entry structure:
         *   _elementMeta[element.zcClippingId] = [client1.id, client2.id];
         */
        var _elementMeta = {};
        /**
         * Keep track of the state of the mouse event handlers for clipped elements.
         *
         * Entry structure:
         *   _mouseHandlers[element.zcClippingId] = {
 *     mouseover:  function(event) {},
 *     mouseout:   function(event) {},
 *     mouseenter: function(event) {},
 *     mouseleave: function(event) {},
 *     mousemove:  function(event) {}
 *   };
         */
        var _mouseHandlers = {};
        /**
         * Extending the ZeroClipboard configuration defaults for the Client module.
         */
        _extend(_globalConfig, {
            autoActivate: true
        });
        /**
         * The real constructor for `ZeroClipboard` client instances.
         * @private
         */
        var _clientConstructor = function(elements) {
            var client = this;
            client.id = "" + _clientIdCounter++;
            _clientMeta[client.id] = {
                instance: client,
                elements: [],
                handlers: {}
            };
            if (elements) {
                client.clip(elements);
            }
            ZeroClipboard.on("*", function(event) {
                return client.emit(event);
            });
            ZeroClipboard.on("destroy", function() {
                client.destroy();
            });
            ZeroClipboard.create();
        };
        /**
         * The underlying implementation of `ZeroClipboard.Client.prototype.on`.
         * @private
         */
        var _clientOn = function(eventType, listener) {
            var i, len, events, added = {}, handlers = _clientMeta[this.id] && _clientMeta[this.id].handlers;
            if (typeof eventType === "string" && eventType) {
                events = eventType.toLowerCase().split(/\s+/);
            } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") {
                for (i in eventType) {
                    if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") {
                        this.on(i, eventType[i]);
                    }
                }
            }
            if (events && events.length) {
                for (i = 0, len = events.length; i < len; i++) {
                    eventType = events[i].replace(/^on/, "");
                    added[eventType] = true;
                    if (!handlers[eventType]) {
                        handlers[eventType] = [];
                    }
                    handlers[eventType].push(listener);
                }
                if (added.ready && _flashState.ready) {
                    this.emit({
                        type: "ready",
                        client: this
                    });
                }
                if (added.error) {
                    var errorTypes = [ "disabled", "outdated", "unavailable", "deactivated", "overdue" ];
                    for (i = 0, len = errorTypes.length; i < len; i++) {
                        if (_flashState[errorTypes[i]]) {
                            this.emit({
                                type: "error",
                                name: "flash-" + errorTypes[i],
                                client: this
                            });
                            break;
                        }
                    }
                }
            }
            return this;
        };
        /**
         * The underlying implementation of `ZeroClipboard.Client.prototype.off`.
         * @private
         */
        var _clientOff = function(eventType, listener) {
            var i, len, foundIndex, events, perEventHandlers, handlers = _clientMeta[this.id] && _clientMeta[this.id].handlers;
            if (arguments.length === 0) {
                events = _keys(handlers);
            } else if (typeof eventType === "string" && eventType) {
                events = eventType.split(/\s+/);
            } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") {
                for (i in eventType) {
                    if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") {
                        this.off(i, eventType[i]);
                    }
                }
            }
            if (events && events.length) {
                for (i = 0, len = events.length; i < len; i++) {
                    eventType = events[i].toLowerCase().replace(/^on/, "");
                    perEventHandlers = handlers[eventType];
                    if (perEventHandlers && perEventHandlers.length) {
                        if (listener) {
                            foundIndex = perEventHandlers.indexOf(listener);
                            while (foundIndex !== -1) {
                                perEventHandlers.splice(foundIndex, 1);
                                foundIndex = perEventHandlers.indexOf(listener, foundIndex);
                            }
                        } else {
                            perEventHandlers.length = 0;
                        }
                    }
                }
            }
            return this;
        };
        /**
         * The underlying implementation of `ZeroClipboard.Client.prototype.handlers`.
         * @private
         */
        var _clientListeners = function(eventType) {
            var copy = null, handlers = _clientMeta[this.id] && _clientMeta[this.id].handlers;
            if (handlers) {
                if (typeof eventType === "string" && eventType) {
                    copy = handlers[eventType] ? handlers[eventType].slice(0) : [];
                } else {
                    copy = _deepCopy(handlers);
                }
            }
            return copy;
        };
        /**
         * The underlying implementation of `ZeroClipboard.Client.prototype.emit`.
         * @private
         */
        var _clientEmit = function(event) {
            if (_clientShouldEmit.call(this, event)) {
                if (typeof event === "object" && event && typeof event.type === "string" && event.type) {
                    event = _extend({}, event);
                }
                var eventCopy = _extend({}, _createEvent(event), {
                    client: this
                });
                _clientDispatchCallbacks.call(this, eventCopy);
            }
            return this;
        };
        /**
         * The underlying implementation of `ZeroClipboard.Client.prototype.clip`.
         * @private
         */
        var _clientClip = function(elements) {
            elements = _prepClip(elements);
            for (var i = 0; i < elements.length; i++) {
                if (_hasOwn.call(elements, i) && elements[i] && elements[i].nodeType === 1) {
                    if (!elements[i].zcClippingId) {
                        elements[i].zcClippingId = "zcClippingId_" + _elementIdCounter++;
                        _elementMeta[elements[i].zcClippingId] = [ this.id ];
                        if (_globalConfig.autoActivate === true) {
                            _addMouseHandlers(elements[i]);
                        }
                    } else if (_elementMeta[elements[i].zcClippingId].indexOf(this.id) === -1) {
                        _elementMeta[elements[i].zcClippingId].push(this.id);
                    }
                    var clippedElements = _clientMeta[this.id] && _clientMeta[this.id].elements;
                    if (clippedElements.indexOf(elements[i]) === -1) {
                        clippedElements.push(elements[i]);
                    }
                }
            }
            return this;
        };
        /**
         * The underlying implementation of `ZeroClipboard.Client.prototype.unclip`.
         * @private
         */
        var _clientUnclip = function(elements) {
            var meta = _clientMeta[this.id];
            if (!meta) {
                return this;
            }
            var clippedElements = meta.elements;
            var arrayIndex;
            if (typeof elements === "undefined") {
                elements = clippedElements.slice(0);
            } else {
                elements = _prepClip(elements);
            }
            for (var i = elements.length; i--; ) {
                if (_hasOwn.call(elements, i) && elements[i] && elements[i].nodeType === 1) {
                    arrayIndex = 0;
                    while ((arrayIndex = clippedElements.indexOf(elements[i], arrayIndex)) !== -1) {
                        clippedElements.splice(arrayIndex, 1);
                    }
                    var clientIds = _elementMeta[elements[i].zcClippingId];
                    if (clientIds) {
                        arrayIndex = 0;
                        while ((arrayIndex = clientIds.indexOf(this.id, arrayIndex)) !== -1) {
                            clientIds.splice(arrayIndex, 1);
                        }
                        if (clientIds.length === 0) {
                            if (_globalConfig.autoActivate === true) {
                                _removeMouseHandlers(elements[i]);
                            }
                            delete elements[i].zcClippingId;
                        }
                    }
                }
            }
            return this;
        };
        /**
         * The underlying implementation of `ZeroClipboard.Client.prototype.elements`.
         * @private
         */
        var _clientElements = function() {
            var meta = _clientMeta[this.id];
            return meta && meta.elements ? meta.elements.slice(0) : [];
        };
        /**
         * The underlying implementation of `ZeroClipboard.Client.prototype.destroy`.
         * @private
         */
        var _clientDestroy = function() {
            this.unclip();
            this.off();
            delete _clientMeta[this.id];
        };
        /**
         * Inspect an Event to see if the Client (`this`) should honor it for emission.
         * @private
         */
        var _clientShouldEmit = function(event) {
            if (!(event && event.type)) {
                return false;
            }
            if (event.client && event.client !== this) {
                return false;
            }
            var clippedEls = _clientMeta[this.id] && _clientMeta[this.id].elements;
            var hasClippedEls = !!clippedEls && clippedEls.length > 0;
            var goodTarget = !event.target || hasClippedEls && clippedEls.indexOf(event.target) !== -1;
            var goodRelTarget = event.relatedTarget && hasClippedEls && clippedEls.indexOf(event.relatedTarget) !== -1;
            var goodClient = event.client && event.client === this;
            if (!(goodTarget || goodRelTarget || goodClient)) {
                return false;
            }
            return true;
        };
        /**
         * Handle the actual dispatching of events to a client instance.
         *
         * @returns `this`
         * @private
         */
        var _clientDispatchCallbacks = function(event) {
            if (!(typeof event === "object" && event && event.type)) {
                return;
            }
            var async = _shouldPerformAsync(event);
            var wildcardTypeHandlers = _clientMeta[this.id] && _clientMeta[this.id].handlers["*"] || [];
            var specificTypeHandlers = _clientMeta[this.id] && _clientMeta[this.id].handlers[event.type] || [];
            var handlers = wildcardTypeHandlers.concat(specificTypeHandlers);
            if (handlers && handlers.length) {
                var i, len, func, context, eventCopy, originalContext = this;
                for (i = 0, len = handlers.length; i < len; i++) {
                    func = handlers[i];
                    context = originalContext;
                    if (typeof func === "string" && typeof _window[func] === "function") {
                        func = _window[func];
                    }
                    if (typeof func === "object" && func && typeof func.handleEvent === "function") {
                        context = func;
                        func = func.handleEvent;
                    }
                    if (typeof func === "function") {
                        eventCopy = _extend({}, event);
                        _dispatchCallback(func, context, [ eventCopy ], async);
                    }
                }
            }
            return this;
        };
        /**
         * Prepares the elements for clipping/unclipping.
         *
         * @returns An Array of elements.
         * @private
         */
        var _prepClip = function(elements) {
            if (typeof elements === "string") {
                elements = [];
            }
            return typeof elements.length !== "number" ? [ elements ] : elements;
        };
        /**
         * Add a `mouseover` handler function for a clipped element.
         *
         * @returns `undefined`
         * @private
         */
        var _addMouseHandlers = function(element) {
            if (!(element && element.nodeType === 1)) {
                return;
            }
            var _suppressMouseEvents = function(event) {
                if (!(event || (event = _window.event))) {
                    return;
                }
                if (event._source !== "js") {
                    event.stopImmediatePropagation();
                    event.preventDefault();
                }
                delete event._source;
            };
            var _elementMouseOver = function(event) {
                if (!(event || (event = _window.event))) {
                    return;
                }
                _suppressMouseEvents(event);
                ZeroClipboard.focus(element);
            };
            element.addEventListener("mouseover", _elementMouseOver, false);
            element.addEventListener("mouseout", _suppressMouseEvents, false);
            element.addEventListener("mouseenter", _suppressMouseEvents, false);
            element.addEventListener("mouseleave", _suppressMouseEvents, false);
            element.addEventListener("mousemove", _suppressMouseEvents, false);
            _mouseHandlers[element.zcClippingId] = {
                mouseover: _elementMouseOver,
                mouseout: _suppressMouseEvents,
                mouseenter: _suppressMouseEvents,
                mouseleave: _suppressMouseEvents,
                mousemove: _suppressMouseEvents
            };
        };
        /**
         * Remove a `mouseover` handler function for a clipped element.
         *
         * @returns `undefined`
         * @private
         */
        var _removeMouseHandlers = function(element) {
            if (!(element && element.nodeType === 1)) {
                return;
            }
            var mouseHandlers = _mouseHandlers[element.zcClippingId];
            if (!(typeof mouseHandlers === "object" && mouseHandlers)) {
                return;
            }
            var key, val, mouseEvents = [ "move", "leave", "enter", "out", "over" ];
            for (var i = 0, len = mouseEvents.length; i < len; i++) {
                key = "mouse" + mouseEvents[i];
                val = mouseHandlers[key];
                if (typeof val === "function") {
                    element.removeEventListener(key, val, false);
                }
            }
            delete _mouseHandlers[element.zcClippingId];
        };
        /**
         * Creates a new ZeroClipboard client instance.
         * Optionally, auto-`clip` an element or collection of elements.
         *
         * @constructor
         */
        ZeroClipboard._createClient = function() {
            _clientConstructor.apply(this, _args(arguments));
        };
        /**
         * Register an event listener to the client.
         *
         * @returns `this`
         */
        ZeroClipboard.prototype.on = function() {
            return _clientOn.apply(this, _args(arguments));
        };
        /**
         * Unregister an event handler from the client.
         * If no `listener` function/object is provided, it will unregister all handlers for the provided `eventType`.
         * If no `eventType` is provided, it will unregister all handlers for every event type.
         *
         * @returns `this`
         */
        ZeroClipboard.prototype.off = function() {
            return _clientOff.apply(this, _args(arguments));
        };
        /**
         * Retrieve event listeners for an `eventType` from the client.
         * If no `eventType` is provided, it will retrieve all listeners for every event type.
         *
         * @returns array of listeners for the `eventType`; if no `eventType`, then a map/hash object of listeners for all event types; or `null`
         */
        ZeroClipboard.prototype.handlers = function() {
            return _clientListeners.apply(this, _args(arguments));
        };
        /**
         * Event emission receiver from the Flash object for this client's registered JavaScript event listeners.
         *
         * @returns For the "copy" event, returns the Flash-friendly "clipData" object; otherwise `undefined`.
         */
        ZeroClipboard.prototype.emit = function() {
            return _clientEmit.apply(this, _args(arguments));
        };
        /**
         * Register clipboard actions for new element(s) to the client.
         *
         * @returns `this`
         */
        ZeroClipboard.prototype.clip = function() {
            return _clientClip.apply(this, _args(arguments));
        };
        /**
         * Unregister the clipboard actions of previously registered element(s) on the page.
         * If no elements are provided, ALL registered elements will be unregistered.
         *
         * @returns `this`
         */
        ZeroClipboard.prototype.unclip = function() {
            return _clientUnclip.apply(this, _args(arguments));
        };
        /**
         * Get all of the elements to which this client is clipped.
         *
         * @returns array of clipped elements
         */
        ZeroClipboard.prototype.elements = function() {
            return _clientElements.apply(this, _args(arguments));
        };
        /**
         * Self-destruct and clean up everything for a single client.
         * This will NOT destroy the embedded Flash object.
         *
         * @returns `undefined`
         */
        ZeroClipboard.prototype.destroy = function() {
            return _clientDestroy.apply(this, _args(arguments));
        };
        /**
         * Stores the pending plain text to inject into the clipboard.
         *
         * @returns `this`
         */
        ZeroClipboard.prototype.setText = function(text) {
            ZeroClipboard.setData("text/plain", text);
            return this;
        };
        /**
         * Stores the pending HTML text to inject into the clipboard.
         *
         * @returns `this`
         */
        ZeroClipboard.prototype.setHtml = function(html) {
            ZeroClipboard.setData("text/html", html);
            return this;
        };
        /**
         * Stores the pending rich text (RTF) to inject into the clipboard.
         *
         * @returns `this`
         */
        ZeroClipboard.prototype.setRichText = function(richText) {
            ZeroClipboard.setData("application/rtf", richText);
            return this;
        };
        /**
         * Stores the pending data to inject into the clipboard.
         *
         * @returns `this`
         */
        ZeroClipboard.prototype.setData = function() {
            ZeroClipboard.setData.apply(this, _args(arguments));
            return this;
        };
        /**
         * Clears the pending data to inject into the clipboard.
         * If no `format` is provided, all pending data formats will be cleared.
         *
         * @returns `this`
         */
        ZeroClipboard.prototype.clearData = function() {
            ZeroClipboard.clearData.apply(this, _args(arguments));
            return this;
        };
        /**
         * Gets a copy of the pending data to inject into the clipboard.
         * If no `format` is provided, a copy of ALL pending data formats will be returned.
         *
         * @returns `String` or `Object`
         */
        ZeroClipboard.prototype.getData = function() {
            return ZeroClipboard.getData.apply(this, _args(arguments));
        };
        if (typeof define === "function" && define.amd) {
            define(function() {
                return ZeroClipboard;
            });
        } else if (typeof module === "object" && module && typeof module.exports === "object" && module.exports) {
            module.exports = ZeroClipboard;
        } else {
            window.ZeroClipboard = ZeroClipboard;
        }
    })(function() {
        return this || window;
    }());
});
/*!
 * clipboard.js v1.6.0
 * https://zenorocha.github.io/clipboard.js
 *
 * Licensed MIT  Zeno Rocha
 */
define('clipboard', function() {
    return f();
    function f(){var e,t,n;return function e(t,n,o){function i(a,c){if(!n[a]){if(!t[a]){var l="function"==typeof require&&require;if(!c&&l)return l(a,!0);if(r)return r(a,!0);var u=new Error("Cannot find module '"+a+"'");throw u.code="MODULE_NOT_FOUND",u}var s=n[a]={exports:{}};t[a][0].call(s.exports,function(e){var n=t[a][1][e];return i(n?n:e)},s,s.exports,e,t,n,o)}return n[a].exports}for(var r="function"==typeof require&&require,a=0;a<o.length;a++)i(o[a]);return i}({1:[function(e,t,n){function o(e,t){for(;e&&e.nodeType!==i;){if(e.matches(t))return e;e=e.parentNode}}var i=9;if(Element&&!Element.prototype.matches){var r=Element.prototype;r.matches=r.matchesSelector||r.mozMatchesSelector||r.msMatchesSelector||r.oMatchesSelector||r.webkitMatchesSelector}t.exports=o},{}],2:[function(e,t,n){function o(e,t,n,o,r){var a=i.apply(this,arguments);return e.addEventListener(n,a,r),{destroy:function(){e.removeEventListener(n,a,r)}}}function i(e,t,n,o){return function(n){n.delegateTarget=r(n.target,t),n.delegateTarget&&o.call(e,n)}}var r=e("./closest");t.exports=o},{"./closest":1}],3:[function(e,t,n){n.node=function(e){return void 0!==e&&e instanceof HTMLElement&&1===e.nodeType},n.nodeList=function(e){var t=Object.prototype.toString.call(e);return void 0!==e&&("[object NodeList]"===t||"[object HTMLCollection]"===t)&&"length"in e&&(0===e.length||n.node(e[0]))},n.string=function(e){return"string"==typeof e||e instanceof String},n.fn=function(e){var t=Object.prototype.toString.call(e);return"[object Function]"===t}},{}],4:[function(e,t,n){function o(e,t,n){if(!e&&!t&&!n)throw new Error("Missing required arguments");if(!c.string(t))throw new TypeError("Second argument must be a String");if(!c.fn(n))throw new TypeError("Third argument must be a Function");if(c.node(e))return i(e,t,n);if(c.nodeList(e))return r(e,t,n);if(c.string(e))return a(e,t,n);throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList")}function i(e,t,n){return e.addEventListener(t,n),{destroy:function(){e.removeEventListener(t,n)}}}function r(e,t,n){return Array.prototype.forEach.call(e,function(e){e.addEventListener(t,n)}),{destroy:function(){Array.prototype.forEach.call(e,function(e){e.removeEventListener(t,n)})}}}function a(e,t,n){return l(document.body,e,t,n)}var c=e("./is"),l=e("delegate");t.exports=o},{"./is":3,delegate:2}],5:[function(e,t,n){function o(e){var t;if("SELECT"===e.nodeName)e.focus(),t=e.value;else if("INPUT"===e.nodeName||"TEXTAREA"===e.nodeName){var n=e.hasAttribute("readonly");n||e.setAttribute("readonly",""),e.select(),e.setSelectionRange(0,e.value.length),n||e.removeAttribute("readonly"),t=e.value}else{e.hasAttribute("contenteditable")&&e.focus();var o=window.getSelection(),i=document.createRange();i.selectNodeContents(e),o.removeAllRanges(),o.addRange(i),t=o.toString()}return t}t.exports=o},{}],6:[function(e,t,n){function o(){}o.prototype={on:function(e,t,n){var o=this.e||(this.e={});return(o[e]||(o[e]=[])).push({fn:t,ctx:n}),this},once:function(e,t,n){function o(){i.off(e,o),t.apply(n,arguments)}var i=this;return o._=t,this.on(e,o,n)},emit:function(e){var t=[].slice.call(arguments,1),n=((this.e||(this.e={}))[e]||[]).slice(),o=0,i=n.length;for(o;o<i;o++)n[o].fn.apply(n[o].ctx,t);return this},off:function(e,t){var n=this.e||(this.e={}),o=n[e],i=[];if(o&&t)for(var r=0,a=o.length;r<a;r++)o[r].fn!==t&&o[r].fn._!==t&&i.push(o[r]);return i.length?n[e]=i:delete n[e],this}},t.exports=o},{}],7:[function(t,n,o){!function(i,r){if("function"==typeof e&&e.amd)e(["module","select"],r);else if("undefined"!=typeof o)r(n,t("select"));else{var a={exports:{}};r(a,i.select),i.clipboardAction=a.exports}}(this,function(e,t){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var i=n(t),r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},a=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),c=function(){function e(t){o(this,e),this.resolveOptions(t),this.initSelection()}return a(e,[{key:"resolveOptions",value:function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.action=t.action,this.emitter=t.emitter,this.target=t.target,this.text=t.text,this.trigger=t.trigger,this.selectedText=""}},{key:"initSelection",value:function e(){this.text?this.selectFake():this.target&&this.selectTarget()}},{key:"selectFake",value:function e(){var t=this,n="rtl"==document.documentElement.getAttribute("dir");this.removeFake(),this.fakeHandlerCallback=function(){return t.removeFake()},this.fakeHandler=document.body.addEventListener("click",this.fakeHandlerCallback)||!0,this.fakeElem=document.createElement("textarea"),this.fakeElem.style.fontSize="12pt",this.fakeElem.style.border="0",this.fakeElem.style.padding="0",this.fakeElem.style.margin="0",this.fakeElem.style.position="absolute",this.fakeElem.style[n?"right":"left"]="-9999px";var o=window.pageYOffset||document.documentElement.scrollTop;this.fakeElem.style.top=o+"px",this.fakeElem.setAttribute("readonly",""),this.fakeElem.value=this.text,document.body.appendChild(this.fakeElem),this.selectedText=(0,i.default)(this.fakeElem),this.copyText()}},{key:"removeFake",value:function e(){this.fakeHandler&&(document.body.removeEventListener("click",this.fakeHandlerCallback),this.fakeHandler=null,this.fakeHandlerCallback=null),this.fakeElem&&(document.body.removeChild(this.fakeElem),this.fakeElem=null)}},{key:"selectTarget",value:function e(){this.selectedText=(0,i.default)(this.target),this.copyText()}},{key:"copyText",value:function e(){var t=void 0;try{t=document.execCommand(this.action)}catch(e){t=!1}this.handleResult(t)}},{key:"handleResult",value:function e(t){this.emitter.emit(t?"success":"error",{action:this.action,text:this.selectedText,trigger:this.trigger,clearSelection:this.clearSelection.bind(this)})}},{key:"clearSelection",value:function e(){this.target&&this.target.blur(),window.getSelection().removeAllRanges()}},{key:"destroy",value:function e(){this.removeFake()}},{key:"action",set:function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"copy";if(this._action=t,"copy"!==this._action&&"cut"!==this._action)throw new Error('Invalid "action" value, use either "copy" or "cut"')},get:function e(){return this._action}},{key:"target",set:function e(t){if(void 0!==t){if(!t||"object"!==("undefined"==typeof t?"undefined":r(t))||1!==t.nodeType)throw new Error('Invalid "target" value, use a valid Element');if("copy"===this.action&&t.hasAttribute("disabled"))throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');if("cut"===this.action&&(t.hasAttribute("readonly")||t.hasAttribute("disabled")))throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');this._target=t}},get:function e(){return this._target}}]),e}();e.exports=c})},{select:5}],8:[function(t,n,o){!function(i,r){if("function"==typeof e&&e.amd)e(["module","./clipboard-action","tiny-emitter","good-listener"],r);else if("undefined"!=typeof o)r(n,t("./clipboard-action"),t("tiny-emitter"),t("good-listener"));else{var a={exports:{}};r(a,i.clipboardAction,i.tinyEmitter,i.goodListener),i.clipboard=a.exports}}(this,function(e,t,n,o){"use strict";function i(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function a(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function c(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}function l(e,t){var n="data-clipboard-"+e;if(t.hasAttribute(n))return t.getAttribute(n)}var u=i(t),s=i(n),f=i(o),d=function(){function e(e,t){for(var n=0;n<t.length;n++){var o=t[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}return function(t,n,o){return n&&e(t.prototype,n),o&&e(t,o),t}}(),h=function(e){function t(e,n){r(this,t);var o=a(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return o.resolveOptions(n),o.listenClick(e),o}return c(t,e),d(t,[{key:"resolveOptions",value:function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.action="function"==typeof t.action?t.action:this.defaultAction,this.target="function"==typeof t.target?t.target:this.defaultTarget,this.text="function"==typeof t.text?t.text:this.defaultText}},{key:"listenClick",value:function e(t){var n=this;this.listener=(0,f.default)(t,"click",function(e){return n.onClick(e)})}},{key:"onClick",value:function e(t){var n=t.delegateTarget||t.currentTarget;this.clipboardAction&&(this.clipboardAction=null),this.clipboardAction=new u.default({action:this.action(n),target:this.target(n),text:this.text(n),trigger:n,emitter:this})}},{key:"defaultAction",value:function e(t){return l("action",t)}},{key:"defaultTarget",value:function e(t){var n=l("target",t);if(n)return document.querySelector(n)}},{key:"defaultText",value:function e(t){return l("text",t)}},{key:"destroy",value:function e(){this.listener.destroy(),this.clipboardAction&&(this.clipboardAction.destroy(),this.clipboardAction=null)}}],[{key:"isSupported",value:function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:["copy","cut"],n="string"==typeof t?[t]:t,o=!!document.queryCommandSupported;return n.forEach(function(e){o=o&&!!document.queryCommandSupported(e)}),o}}]),t}(s.default);e.exports=h})},{"./clipboard-action":7,"good-listener":4,"tiny-emitter":6}]},{},[8])(8)}
});
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
 * @version   2.3.0
 */

define('es6-promise', function(require, exports, module) {
    "use strict";
    function lib$es6$promise$utils$$objectOrFunction(x) {
        return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }

    function lib$es6$promise$utils$$isFunction(x) {
        return typeof x === 'function';
    }

    function lib$es6$promise$utils$$isMaybeThenable(x) {
        return typeof x === 'object' && x !== null;
    }

    var lib$es6$promise$utils$$_isArray;
    if (!Array.isArray) {
        lib$es6$promise$utils$$_isArray = function (x) {
            return Object.prototype.toString.call(x) === '[object Array]';
        };
    } else {
        lib$es6$promise$utils$$_isArray = Array.isArray;
    }

    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
    var lib$es6$promise$asap$$len = 0;
    var lib$es6$promise$asap$$toString = {}.toString;
    var lib$es6$promise$asap$$vertxNext;
    var lib$es6$promise$asap$$customSchedulerFn;

    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
        lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
        lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
        lib$es6$promise$asap$$len += 2;
        if (lib$es6$promise$asap$$len === 2) {
            // If len is 2, that means that we need to schedule an async flush.
            // If additional callbacks are queued before the queue is flushed, they
            // will be processed by this flush that we are scheduling.
            if (lib$es6$promise$asap$$customSchedulerFn) {
                lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
            } else {
                lib$es6$promise$asap$$scheduleFlush();
            }
        }
    }

    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
        lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
    }

    function lib$es6$promise$asap$$setAsap(asapFn) {
        lib$es6$promise$asap$$asap = asapFn;
    }

    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

    // test for web worker but not in IE10
    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
        typeof importScripts !== 'undefined' &&
        typeof MessageChannel !== 'undefined';

    // node
    function lib$es6$promise$asap$$useNextTick() {
        var nextTick = process.nextTick;
        // node version 0.10.x displays a deprecation warning when nextTick is used recursively
        // setImmediate should be used instead instead
        var version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
        if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {
            nextTick = setImmediate;
        }
        return function() {
            nextTick(lib$es6$promise$asap$$flush);
        };
    }

    // vertx
    function lib$es6$promise$asap$$useVertxTimer() {
        return function() {
            lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
        };
    }

    function lib$es6$promise$asap$$useMutationObserver() {
        var iterations = 0;
        var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
        var node = document.createTextNode('');
        observer.observe(node, { characterData: true });

        return function() {
            node.data = (iterations = ++iterations % 2);
        };
    }

    // web worker
    function lib$es6$promise$asap$$useMessageChannel() {
        var channel = new MessageChannel();
        channel.port1.onmessage = lib$es6$promise$asap$$flush;
        return function () {
            channel.port2.postMessage(0);
        };
    }

    function lib$es6$promise$asap$$useSetTimeout() {
        return function() {
            setTimeout(lib$es6$promise$asap$$flush, 1);
        };
    }

    var lib$es6$promise$asap$$queue = new Array(1000);
    function lib$es6$promise$asap$$flush() {
        for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
            var callback = lib$es6$promise$asap$$queue[i];
            var arg = lib$es6$promise$asap$$queue[i+1];

            callback(arg);

            lib$es6$promise$asap$$queue[i] = undefined;
            lib$es6$promise$asap$$queue[i+1] = undefined;
        }

        lib$es6$promise$asap$$len = 0;
    }

    function lib$es6$promise$asap$$attemptVertex() {
        try {
            var r = require;
            var vertx = r('vertx');
            lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
            return lib$es6$promise$asap$$useVertxTimer();
        } catch(e) {
            return lib$es6$promise$asap$$useSetTimeout();
        }
    }

    var lib$es6$promise$asap$$scheduleFlush;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (lib$es6$promise$asap$$isNode) {
        lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
        lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
    } else if (lib$es6$promise$asap$$isWorker) {
        lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {
        lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertex();
    } else {
        lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
    }

    function lib$es6$promise$$internal$$noop() {}

    var lib$es6$promise$$internal$$PENDING   = void 0;
    var lib$es6$promise$$internal$$FULFILLED = 1;
    var lib$es6$promise$$internal$$REJECTED  = 2;

    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$selfFullfillment() {
        return new TypeError("You cannot resolve a promise with itself");
    }

    function lib$es6$promise$$internal$$cannotReturnOwn() {
        return new TypeError('A promises callback cannot return that same promise.');
    }

    function lib$es6$promise$$internal$$getThen(promise) {
        try {
            return promise.then;
        } catch(error) {
            lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
            return lib$es6$promise$$internal$$GET_THEN_ERROR;
        }
    }

    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
        try {
            then.call(value, fulfillmentHandler, rejectionHandler);
        } catch(e) {
            return e;
        }
    }

    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
        lib$es6$promise$asap$$asap(function(promise) {
            var sealed = false;
            var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
                if (sealed) { return; }
                sealed = true;
                if (thenable !== value) {
                    lib$es6$promise$$internal$$resolve(promise, value);
                } else {
                    lib$es6$promise$$internal$$fulfill(promise, value);
                }
            }, function(reason) {
                if (sealed) { return; }
                sealed = true;

                lib$es6$promise$$internal$$reject(promise, reason);
            }, 'Settle: ' + (promise._label || ' unknown promise'));

            if (!sealed && error) {
                sealed = true;
                lib$es6$promise$$internal$$reject(promise, error);
            }
        }, promise);
    }

    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
        if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
            lib$es6$promise$$internal$$fulfill(promise, thenable._result);
        } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
            lib$es6$promise$$internal$$reject(promise, thenable._result);
        } else {
            lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
                lib$es6$promise$$internal$$resolve(promise, value);
            }, function(reason) {
                lib$es6$promise$$internal$$reject(promise, reason);
            });
        }
    }

    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {
        if (maybeThenable.constructor === promise.constructor) {
            lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
        } else {
            var then = lib$es6$promise$$internal$$getThen(maybeThenable);

            if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
                lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
            } else if (then === undefined) {
                lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
            } else if (lib$es6$promise$utils$$isFunction(then)) {
                lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
            } else {
                lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
            }
        }
    }

    function lib$es6$promise$$internal$$resolve(promise, value) {
        if (promise === value) {
            lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFullfillment());
        } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
            lib$es6$promise$$internal$$handleMaybeThenable(promise, value);
        } else {
            lib$es6$promise$$internal$$fulfill(promise, value);
        }
    }

    function lib$es6$promise$$internal$$publishRejection(promise) {
        if (promise._onerror) {
            promise._onerror(promise._result);
        }

        lib$es6$promise$$internal$$publish(promise);
    }

    function lib$es6$promise$$internal$$fulfill(promise, value) {
        if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }

        promise._result = value;
        promise._state = lib$es6$promise$$internal$$FULFILLED;

        if (promise._subscribers.length !== 0) {
            lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
        }
    }

    function lib$es6$promise$$internal$$reject(promise, reason) {
        if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
        promise._state = lib$es6$promise$$internal$$REJECTED;
        promise._result = reason;

        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
    }

    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
        var subscribers = parent._subscribers;
        var length = subscribers.length;

        parent._onerror = null;

        subscribers[length] = child;
        subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
        subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;

        if (length === 0 && parent._state) {
            lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
        }
    }

    function lib$es6$promise$$internal$$publish(promise) {
        var subscribers = promise._subscribers;
        var settled = promise._state;

        if (subscribers.length === 0) { return; }

        var child, callback, detail = promise._result;

        for (var i = 0; i < subscribers.length; i += 3) {
            child = subscribers[i];
            callback = subscribers[i + settled];

            if (child) {
                lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
            } else {
                callback(detail);
            }
        }

        promise._subscribers.length = 0;
    }

    function lib$es6$promise$$internal$$ErrorObject() {
        this.error = null;
    }

    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
        try {
            return callback(detail);
        } catch(e) {
            console.error(e)
            lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
            return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
        }
    }

    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
        var hasCallback = lib$es6$promise$utils$$isFunction(callback),
            value, error, succeeded, failed;

        if (hasCallback) {
            value = lib$es6$promise$$internal$$tryCatch(callback, detail);

            if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
                failed = true;
                error = value.error;
                value = null;
            } else {
                succeeded = true;
            }

            if (promise === value) {
                lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
                return;
            }

        } else {
            value = detail;
            succeeded = true;
        }

        if (promise._state !== lib$es6$promise$$internal$$PENDING) {
            // noop
        } else if (hasCallback && succeeded) {
            lib$es6$promise$$internal$$resolve(promise, value);
        } else if (failed) {
            lib$es6$promise$$internal$$reject(promise, error);
        } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
            lib$es6$promise$$internal$$fulfill(promise, value);
        } else if (settled === lib$es6$promise$$internal$$REJECTED) {
            lib$es6$promise$$internal$$reject(promise, value);
        }
    }

    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
        try {
            resolver(function resolvePromise(value){
                lib$es6$promise$$internal$$resolve(promise, value);
            }, function rejectPromise(reason) {
                lib$es6$promise$$internal$$reject(promise, reason);
            });
        } catch(e) {
            lib$es6$promise$$internal$$reject(promise, e);
        }
    }

    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
        var enumerator = this;

        enumerator._instanceConstructor = Constructor;
        enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);

        if (enumerator._validateInput(input)) {
            enumerator._input     = input;
            enumerator.length     = input.length;
            enumerator._remaining = input.length;

            enumerator._init();

            if (enumerator.length === 0) {
                lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
            } else {
                enumerator.length = enumerator.length || 0;
                enumerator._enumerate();
                if (enumerator._remaining === 0) {
                    lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
                }
            }
        } else {
            lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());
        }
    }

    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {
        return lib$es6$promise$utils$$isArray(input);
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {
        return new Error('Array Methods must be provided an Array');
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {
        this._result = new Array(this.length);
    };

    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;

    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
        var enumerator = this;

        var length  = enumerator.length;
        var promise = enumerator.promise;
        var input   = enumerator._input;

        for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
            enumerator._eachEntry(input[i], i);
        }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
        var enumerator = this;
        var c = enumerator._instanceConstructor;

        if (lib$es6$promise$utils$$isMaybeThenable(entry)) {
            if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {
                entry._onerror = null;
                enumerator._settledAt(entry._state, i, entry._result);
            } else {
                enumerator._willSettleAt(c.resolve(entry), i);
            }
        } else {
            enumerator._remaining--;
            enumerator._result[i] = entry;
        }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
        var enumerator = this;
        var promise = enumerator.promise;

        if (promise._state === lib$es6$promise$$internal$$PENDING) {
            enumerator._remaining--;

            if (state === lib$es6$promise$$internal$$REJECTED) {
                lib$es6$promise$$internal$$reject(promise, value);
            } else {
                enumerator._result[i] = value;
            }
        }

        if (enumerator._remaining === 0) {
            lib$es6$promise$$internal$$fulfill(promise, enumerator._result);
        }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
        var enumerator = this;

        lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
            enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
        }, function(reason) {
            enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
        });
    };
    function lib$es6$promise$promise$all$$all(entries) {
        return new lib$es6$promise$enumerator$$default(this, entries).promise;
    }
    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
    function lib$es6$promise$promise$race$$race(entries) {
        /*jshint validthis:true */
        var Constructor = this;

        var promise = new Constructor(lib$es6$promise$$internal$$noop);

        if (!lib$es6$promise$utils$$isArray(entries)) {
            lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
            return promise;
        }

        var length = entries.length;

        function onFulfillment(value) {
            lib$es6$promise$$internal$$resolve(promise, value);
        }

        function onRejection(reason) {
            lib$es6$promise$$internal$$reject(promise, reason);
        }

        for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
            lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
        }

        return promise;
    }
    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
    function lib$es6$promise$promise$resolve$$resolve(object) {
        /*jshint validthis:true */
        var Constructor = this;

        if (object && typeof object === 'object' && object.constructor === Constructor) {
            return object;
        }

        var promise = new Constructor(lib$es6$promise$$internal$$noop);
        lib$es6$promise$$internal$$resolve(promise, object);
        return promise;
    }
    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
    function lib$es6$promise$promise$reject$$reject(reason) {
        /*jshint validthis:true */
        var Constructor = this;
        var promise = new Constructor(lib$es6$promise$$internal$$noop);
        lib$es6$promise$$internal$$reject(promise, reason);
        return promise;
    }
    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;

    var lib$es6$promise$promise$$counter = 0;

    function lib$es6$promise$promise$$needsResolver() {
        throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function lib$es6$promise$promise$$needsNew() {
        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
    /**
     Promise objects represent the eventual result of an asynchronous operation. The
     primary way of interacting with a promise is through its `then` method, which
     registers callbacks to receive either a promise's eventual value or the reason
     why the promise cannot be fulfilled.

     Terminology
     -----------

     - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
     - `thenable` is an object or function that defines a `then` method.
     - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
     - `exception` is a value that is thrown using the throw statement.
     - `reason` is a value that indicates why a promise was rejected.
     - `settled` the final resting state of a promise, fulfilled or rejected.

     A promise can be in one of three states: pending, fulfilled, or rejected.

     Promises that are fulfilled have a fulfillment value and are in the fulfilled
     state.  Promises that are rejected have a rejection reason and are in the
     rejected state.  A fulfillment value is never a thenable.

     Promises can also be said to *resolve* a value.  If this value is also a
     promise, then the original promise's settled state will match the value's
     settled state.  So a promise that *resolves* a promise that rejects will
     itself reject, and a promise that *resolves* a promise that fulfills will
     itself fulfill.


     Basic Usage:
     ------------

     ```js
     var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

     promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
     ```

     Advanced Usage:
     ---------------

     Promises shine when abstracting away asynchronous interactions such as
     `XMLHttpRequest`s.

     ```js
     function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

     getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
     ```

     Unlike callbacks, promises are great composable primitives.

     ```js
     Promise.all([
     getJSON('/posts'),
     getJSON('/comments')
     ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
     ```

     @class Promise
     @param {function} resolver
     Useful for tooling.
     @constructor
     */
    function lib$es6$promise$promise$$Promise(resolver) {
        this._id = lib$es6$promise$promise$$counter++;
        this._state = undefined;
        this._result = undefined;
        this._subscribers = [];

        if (lib$es6$promise$$internal$$noop !== resolver) {
            if (!lib$es6$promise$utils$$isFunction(resolver)) {
                lib$es6$promise$promise$$needsResolver();
            }

            if (!(this instanceof lib$es6$promise$promise$$Promise)) {
                lib$es6$promise$promise$$needsNew();
            }

            lib$es6$promise$$internal$$initializePromise(this, resolver);
        }
    }

    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;

    lib$es6$promise$promise$$Promise.prototype = {
        constructor: lib$es6$promise$promise$$Promise,

        /**
         The primary way of interacting with a promise is through its `then` method,
         which registers callbacks to receive either a promise's eventual value or the
         reason why the promise cannot be fulfilled.

         ```js
         findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
         ```

         Chaining
         --------

         The return value of `then` is itself a promise.  This second, 'downstream'
         promise is resolved with the return value of the first promise's fulfillment
         or rejection handler, or rejected if the handler throws an exception.

         ```js
         findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

         findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
         ```
         If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

         ```js
         findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
         ```

         Assimilation
         ------------

         Sometimes the value you want to propagate to a downstream promise can only be
         retrieved asynchronously. This can be achieved by returning a promise in the
         fulfillment or rejection handler. The downstream promise will then be pending
         until the returned promise is settled. This is called *assimilation*.

         ```js
         findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
         ```

         If the assimliated promise rejects, then the downstream promise will also reject.

         ```js
         findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
         ```

         Simple Example
         --------------

         Synchronous Example

         ```javascript
         var result;

         try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
         ```

         Errback Example

         ```js
         findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
         ```

         Promise Example;

         ```javascript
         findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
         ```

         Advanced Example
         --------------

         Synchronous Example

         ```javascript
         var author, books;

         try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
         ```

         Errback Example

         ```js

         function foundBooks(books) {

      }

         function failure(reason) {

      }

         findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
         ```

         Promise Example;

         ```javascript
         findAuthor().
         then(findBooksByAuthor).
         then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
         ```

         @method then
         @param {Function} onFulfilled
         @param {Function} onRejected
         Useful for tooling.
         @return {Promise}
         */
        then: function(onFulfillment, onRejection) {
            var parent = this;
            var state = parent._state;

            if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
                return this;
            }

            var child = new this.constructor(lib$es6$promise$$internal$$noop);
            var result = parent._result;

            if (state) {
                var callback = arguments[state - 1];
                lib$es6$promise$asap$$asap(function(){
                    lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);
                });
            } else {
                lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
            }

            return child;
        },

        /**
         `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
         as the catch block of a try/catch statement.

         ```js
         function findAuthor(){
        throw new Error('couldn't find that author');
      }

         // synchronous
         try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

         // async with promises
         findAuthor().catch(function(reason){
        // something went wrong
      });
         ```

         @method catch
         @param {Function} onRejection
         Useful for tooling.
         @return {Promise}
         */
        'catch': function(onRejection) {
            return this.then(null, onRejection);
        }
    };
    function lib$es6$promise$polyfill$$polyfill() {
        var local;

        if (typeof global !== 'undefined') {
            local = global;
        } else if (typeof self !== 'undefined') {
            local = self;
        } else {
            try {
                local = Function('return this')();
            } catch (e) {
                throw new Error('polyfill failed because global object is unavailable in this environment');
            }
        }

        var P = local.Promise;

        if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
            return;
        }

        local.Promise = lib$es6$promise$promise$$default;
    }

    module.exports = lib$es6$promise$promise$$default;
});

// ==ClosureCompiler==
// @compilation_level SIMPLE_OPTIMIZATIONS

/**
 * @license Highcharts JS v4.0.3 (2014-07-03)
 *
 * (c) 2009-2014 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

define('lib/highcharts',function(require,exports,module){
    var $=require("$");
    var Highcharts = {};
    // JSLint options:
    /*global Highcharts, HighchartsAdapter, document, window, navigator, setInterval, clearInterval, clearTimeout, setTimeout, location, jQuery, $, console, each, grep */
    /*jslint ass: true, sloppy: true, forin: true, plusplus: true, nomen: true, vars: true, regexp: true, newcap: true, browser: true, continue: true, white: true */
    (function () {
        // encapsulated variables
        var UNDEFINED,
            doc = document,
            win = window,
            math = Math,
            mathRound = math.round,
            mathFloor = math.floor,
            mathCeil = math.ceil,
            mathMax = math.max,
            mathMin = math.min,
            mathAbs = math.abs,
            mathCos = math.cos,
            mathSin = math.sin,
            mathPI = math.PI,
            deg2rad = mathPI * 2 / 360,


            // some variables
            userAgent = navigator.userAgent,
            isOpera = win.opera,
            isIE = /(msie|trident)/i.test(userAgent) && !isOpera,
            docMode8 = doc.documentMode === 8,
            isWebKit = /AppleWebKit/.test(userAgent),
            isFirefox = /Firefox/.test(userAgent),
            isTouchDevice = /(Mobile|Android|Windows Phone)/.test(userAgent),
            SVG_NS = 'http://www.w3.org/2000/svg',
            hasSVG = !!doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,
            hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4, // issue #38
            useCanVG = !hasSVG && !isIE && !!doc.createElement('canvas').getContext,
            Renderer,
            hasTouch,
            symbolSizes = {},
            idCounter = 0,
            garbageBin,
            defaultOptions,
            dateFormat, // function
            globalAnimation,
            pathAnim,
            timeUnits,
            noop = function () { return UNDEFINED; },
            charts = [],
            chartCount = 0,
            PRODUCT = 'Highcharts',
            VERSION = '4.1.7',

            // some constants for frequently used strings
            DIV = 'div',
            ABSOLUTE = 'absolute',
            RELATIVE = 'relative',
            HIDDEN = 'hidden',
            PREFIX = 'highcharts-',
            VISIBLE = 'visible',
            PX = 'px',
            NONE = 'none',
            M = 'M',
            L = 'L',
            numRegex = /^[0-9]+$/,
            NORMAL_STATE = '',
            HOVER_STATE = 'hover',
            SELECT_STATE = 'select',
            marginNames = ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],

            // Object for extending Axis
            AxisPlotLineOrBandExtension,

            // constants for attributes
            STROKE_WIDTH = 'stroke-width',

            // time methods, changed based on whether or not UTC is used
            Date,  // Allow using a different Date class
            makeTime,
            timezoneOffset,
            getTimezoneOffset,
            getMinutes,
            getHours,
            getDay,
            getDate,
            getMonth,
            getFullYear,
            setMilliseconds,
            setSeconds,
            setMinutes,
            setHours,
            setDate,
            setMonth,
            setFullYear,


            // lookup over the types and the associated classes
            seriesTypes = {},
            Highcharts;

        // The Highcharts namespace
        Highcharts = win.Highcharts = win.Highcharts ? error(16, true) : {};

        Highcharts.seriesTypes = seriesTypes;

        /**
         * Extend an object with the members of another
         * @param {Object} a The object to be extended
         * @param {Object} b The object to add to the first one
         */
        var extend = Highcharts.extend = function (a, b) {
            var n;
            if (!a) {
                a = {};
            }
            for (n in b) {
                a[n] = b[n];
            }
            return a;
        };

        /**
         * Deep merge two or more objects and return a third object. If the first argument is
         * true, the contents of the second object is copied into the first object.
         * Previously this function redirected to jQuery.extend(true), but this had two limitations.
         * First, it deep merged arrays, which lead to workarounds in Highcharts. Second,
         * it copied properties from extended prototypes. 
         */
        function merge() {
            var i,
                args = arguments,
                len,
                ret = {},
                doCopy = function (copy, original) {
                    var value, key;

                    // An object is replacing a primitive
                    if (typeof copy !== 'object') {
                        copy = {};
                    }

                    for (key in original) {
                        if (original.hasOwnProperty(key)) {
                            value = original[key];

                            // Copy the contents of objects, but not arrays or DOM nodes
                            if (value && typeof value === 'object' && Object.prototype.toString.call(value) !== '[object Array]' &&
                                    key !== 'renderTo' && typeof value.nodeType !== 'number') {
                                copy[key] = doCopy(copy[key] || {}, value);

                                // Primitives and arrays are copied over directly
                            } else {
                                copy[key] = original[key];
                            }
                        }
                    }
                    return copy;
                };

            // If first argument is true, copy into the existing object. Used in setOptions.
            if (args[0] === true) {
                ret = args[1];
                args = Array.prototype.slice.call(args, 2);
            }

            // For each argument, extend the return
            len = args.length;
            for (i = 0; i < len; i++) {
                ret = doCopy(ret, args[i]);
            }

            return ret;
        }

        /**
         * Shortcut for parseInt
         * @param {Object} s
         * @param {Number} mag Magnitude
         */
        function pInt(s, mag) {
            return parseInt(s, mag || 10);
        }

        /**
         * Check for string
         * @param {Object} s
         */
        function isString(s) {
            return typeof s === 'string';
        }

        /**
         * Check for object
         * @param {Object} obj
         */
        function isObject(obj) {
            return obj && typeof obj === 'object';
        }

        /**
         * Check for array
         * @param {Object} obj
         */
        function isArray(obj) {
            return Object.prototype.toString.call(obj) === '[object Array]';
        }

        /**
         * Check for number
         * @param {Object} n
         */
        function isNumber(n) {
            return typeof n === 'number';
        }

        function log2lin(num) {
            return math.log(num) / math.LN10;
        }
        function lin2log(num) {
            return math.pow(10, num);
        }

        /**
         * Remove last occurence of an item from an array
         * @param {Array} arr
         * @param {Mixed} item
         */
        function erase(arr, item) {
            var i = arr.length;
            while (i--) {
                if (arr[i] === item) {
                    arr.splice(i, 1);
                    break;
                }
            }
            //return arr;
        }

        /**
         * Returns true if the object is not null or undefined. Like MooTools' $.defined.
         * @param {Object} obj
         */
        function defined(obj) {
            return obj !== UNDEFINED && obj !== null;
        }

        /**
         * Set or get an attribute or an object of attributes. Can't use jQuery attr because
         * it attempts to set expando properties on the SVG element, which is not allowed.
         *
         * @param {Object} elem The DOM element to receive the attribute(s)
         * @param {String|Object} prop The property or an abject of key-value pairs
         * @param {String} value The value if a single property is set
         */
        function attr(elem, prop, value) {
            var key,
                ret;

            // if the prop is a string
            if (isString(prop)) {
                // set the value
                if (defined(value)) {
                    elem.setAttribute(prop, value);

                    // get the value
                } else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...
                    ret = elem.getAttribute(prop);
                }

                // else if prop is defined, it is a hash of key/value pairs
            } else if (defined(prop) && isObject(prop)) {
                for (key in prop) {
                    elem.setAttribute(key, prop[key]);
                }
            }
            return ret;
        }
        /**
         * Check if an element is an array, and if not, make it into an array. Like
         * MooTools' $.splat.
         */
        function splat(obj) {
            return isArray(obj) ? obj : [obj];
        }


        /**
         * Return the first value that is defined. Like MooTools' $.pick.
         */
        var pick = Highcharts.pick = function () {
            var args = arguments,
                i,
                arg,
                length = args.length;
            for (i = 0; i < length; i++) {
                arg = args[i];
                if (arg !== UNDEFINED && arg !== null) {
                    return arg;
                }
            }
        };

        /**
         * Set CSS on a given element
         * @param {Object} el
         * @param {Object} styles Style object with camel case property names
         */
        function css(el, styles) {
            if (isIE && !hasSVG) { // #2686
                if (styles && styles.opacity !== UNDEFINED) {
                    styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';
                }
            }
            extend(el.style, styles);
        }

        /**
         * Utility function to create element with attributes and styles
         * @param {Object} tag
         * @param {Object} attribs
         * @param {Object} styles
         * @param {Object} parent
         * @param {Object} nopad
         */
        function createElement(tag, attribs, styles, parent, nopad) {
            var el = doc.createElement(tag);
            if (attribs) {
                extend(el, attribs);
            }
            if (nopad) {
                css(el, { padding: 0, border: NONE, margin: 0 });
            }
            if (styles) {
                css(el, styles);
            }
            if (parent) {
                parent.appendChild(el);
            }
            return el;
        }

        /**
         * Extend a prototyped class by new members
         * @param {Object} parent
         * @param {Object} members
         */
        function extendClass(parent, members) {
            var object = function () { return UNDEFINED; };
            object.prototype = new parent();
            extend(object.prototype, members);
            return object;
        }

        /**
         * Pad a string to a given length by adding 0 to the beginning
         * @param {Number} number
         * @param {Number} length
         */
        function pad(number, length) {
            // Create an array of the remaining length +1 and join it with 0's
            return new Array((length || 2) + 1 - String(number).length).join(0) + number;
        }

        /**
         * Return a length based on either the integer value, or a percentage of a base.
         */
        function relativeLength(value, base) {
            return (/%$/).test(value) ? base * parseFloat(value) / 100 : parseFloat(value);
        }

        /**
         * Wrap a method with extended functionality, preserving the original function
         * @param {Object} obj The context object that the method belongs to 
         * @param {String} method The name of the method to extend
         * @param {Function} func A wrapper function callback. This function is called with the same arguments
         * as the original function, except that the original function is unshifted and passed as the first 
         * argument. 
         */
        var wrap = Highcharts.wrap = function (obj, method, func) {
            var proceed = obj[method];
            obj[method] = function () {
                var args = Array.prototype.slice.call(arguments);
                args.unshift(proceed);
                return func.apply(this, args);
            };
        };


        function getTZOffset(timestamp) {
            return ((getTimezoneOffset && getTimezoneOffset(timestamp)) || timezoneOffset || 0) * 60000;
        }

        /**
         * Based on http://www.php.net/manual/en/function.strftime.php
         * @param {String} format
         * @param {Number} timestamp
         * @param {Boolean} capitalize
         */
        dateFormat = function (format, timestamp, capitalize) {
            if (!defined(timestamp) || isNaN(timestamp)) {
                return 'Invalid date';
            }
            format = pick(format, '%Y-%m-%d %H:%M:%S');

            var date = new Date(timestamp - getTZOffset(timestamp)),
                key, // used in for constuct below
                // get the basic time values
                hours = date[getHours](),
                day = date[getDay](),
                dayOfMonth = date[getDate](),
                month = date[getMonth](),
                fullYear = date[getFullYear](),
                lang = defaultOptions.lang,
                langWeekdays = lang.weekdays,

                // List all format keys. Custom formats can be added from the outside. 
                replacements = extend({

                    // Day
                    'a': langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'
                    'A': langWeekdays[day], // Long weekday, like 'Monday'
                    'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31
                    'e': dayOfMonth, // Day of the month, 1 through 31
                    'w': day,

                    // Week (none implemented)
                    //'W': weekNumber(),

                    // Month
                    'b': lang.shortMonths[month], // Short month, like 'Jan'
                    'B': lang.months[month], // Long month, like 'January'
                    'm': pad(month + 1), // Two digit month number, 01 through 12

                    // Year
                    'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009
                    'Y': fullYear, // Four digits year, like 2009

                    // Time
                    'H': pad(hours), // Two digits hours in 24h format, 00 through 23
                    'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11
                    'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12
                    'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59
                    'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM
                    'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM
                    'S': pad(date.getSeconds()), // Two digits seconds, 00 through  59
                    'L': pad(mathRound(timestamp % 1000), 3) // Milliseconds (naming from Ruby)
                }, Highcharts.dateFormats);


            // do the replaces
            for (key in replacements) {
                while (format.indexOf('%' + key) !== -1) { // regex would do it in one line, but this is faster
                    format = format.replace('%' + key, typeof replacements[key] === 'function' ? replacements[key](timestamp) : replacements[key]);
                }
            }

            // Optionally capitalize the string and return
            return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;
        };

        /** 
         * Format a single variable. Similar to sprintf, without the % prefix.
         */
        function formatSingle(format, val) {
            var floatRegex = /f$/,
                decRegex = /\.([0-9])/,
                lang = defaultOptions.lang,
                decimals;

            if (floatRegex.test(format)) { // float
                decimals = format.match(decRegex);
                decimals = decimals ? decimals[1] : -1;
                if (val !== null) {
                    val = Highcharts.numberFormat(
                        val,
                        decimals,
                        lang.decimalPoint,
                        format.indexOf(',') > -1 ? lang.thousandsSep : ''
                    );
                }
            } else {
                val = dateFormat(format, val);
            }
            return val;
        }

        /**
         * Format a string according to a subset of the rules of Python's String.format method.
         */
        function format(str, ctx) {
            var splitter = '{',
                isInside = false,
                segment,
                valueAndFormat,
                path,
                i,
                len,
                ret = [],
                val,
                index;

            while ((index = str.indexOf(splitter)) !== -1) {

                segment = str.slice(0, index);
                if (isInside) { // we're on the closing bracket looking back

                    valueAndFormat = segment.split(':');
                    path = valueAndFormat.shift().split('.'); // get first and leave format
                    len = path.length;
                    val = ctx;

                    // Assign deeper paths
                    for (i = 0; i < len; i++) {
                        val = val[path[i]];
                    }

                    // Format the replacement
                    if (valueAndFormat.length) {
                        val = formatSingle(valueAndFormat.join(':'), val);
                    }

                    // Push the result and advance the cursor
                    ret.push(val);

                } else {
                    ret.push(segment);

                }
                str = str.slice(index + 1); // the rest
                isInside = !isInside; // toggle
                splitter = isInside ? '}' : '{'; // now look for next matching bracket
            }
            ret.push(str);
            return ret.join('');
        }

        /**
         * Get the magnitude of a number
         */
        function getMagnitude(num) {
            return math.pow(10, mathFloor(math.log(num) / math.LN10));
        }

        /**
         * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5
         * @param {Number} interval
         * @param {Array} multiples
         * @param {Number} magnitude
         * @param {Object} options
         */
        function normalizeTickInterval(interval, multiples, magnitude, allowDecimals, preventExceed) {
            var normalized,
                i,
                retInterval = interval;

            // round to a tenfold of 1, 2, 2.5 or 5
            magnitude = pick(magnitude, 1);
            normalized = interval / magnitude;

            // multiples for a linear scale
            if (!multiples) {
                multiples = [1, 2, 2.5, 5, 10];

                // the allowDecimals option
                if (allowDecimals === false) {
                    if (magnitude === 1) {
                        multiples = [1, 2, 5, 10];
                    } else if (magnitude <= 0.1) {
                        multiples = [1 / magnitude];
                    }
                }
            }

            // normalize the interval to the nearest multiple
            for (i = 0; i < multiples.length; i++) {
                retInterval = multiples[i];
                if ((preventExceed && retInterval * magnitude >= interval) || // only allow tick amounts smaller than natural
                    (!preventExceed && (normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2))) {
                    break;
                }
            }

            // multiply back to the correct magnitude
            retInterval *= magnitude;

            return retInterval;
        }


        /**
         * Utility method that sorts an object array and keeping the order of equal items.
         * ECMA script standard does not specify the behaviour when items are equal.
         */
        function stableSort(arr, sortFunction) {
            var length = arr.length,
                sortValue,
                i;

            // Add index to each item
            for (i = 0; i < length; i++) {
                arr[i].ss_i = i; // stable sort index
            }

            arr.sort(function (a, b) {
                sortValue = sortFunction(a, b);
                return sortValue === 0 ? a.ss_i - b.ss_i : sortValue;
            });

            // Remove index from items
            for (i = 0; i < length; i++) {
                delete arr[i].ss_i; // stable sort index
            }
        }

        /**
         * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
         * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
         * method is slightly slower, but safe.
         */
        function arrayMin(data) {
            var i = data.length,
                min = data[0];

            while (i--) {
                if (data[i] < min) {
                    min = data[i];
                }
            }
            return min;
        }

        /**
         * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
         * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
         * method is slightly slower, but safe.
         */
        function arrayMax(data) {
            var i = data.length,
                max = data[0];

            while (i--) {
                if (data[i] > max) {
                    max = data[i];
                }
            }
            return max;
        }

        /**
         * Utility method that destroys any SVGElement or VMLElement that are properties on the given object.
         * It loops all properties and invokes destroy if there is a destroy method. The property is
         * then delete'ed.
         * @param {Object} The object to destroy properties on
         * @param {Object} Exception, do not destroy this property, only delete it.
         */
        function destroyObjectProperties(obj, except) {
            var n;
            for (n in obj) {
                // If the object is non-null and destroy is defined
                if (obj[n] && obj[n] !== except && obj[n].destroy) {
                    // Invoke the destroy
                    obj[n].destroy();
                }

                // Delete the property from the object.
                delete obj[n];
            }
        }


        /**
         * Discard an element by moving it to the bin and delete
         * @param {Object} The HTML node to discard
         */
        function discardElement(element) {
            // create a garbage bin element, not part of the DOM
            if (!garbageBin) {
                garbageBin = createElement(DIV);
            }

            // move the node and empty bin
            if (element) {
                garbageBin.appendChild(element);
            }
            garbageBin.innerHTML = '';
        }

        /**
         * Provide error messages for debugging, with links to online explanation 
         */
        function error(code, stop) {
            var msg = 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code;
            if (stop) {
                throw msg;
            }
            // else ...
            if (win.console) {
                console.log(msg);
            }
        }

        /**
         * Fix JS round off float errors
         * @param {Number} num
         */
        function correctFloat(num) {
            return parseFloat(
                num.toPrecision(14)
            );
        }

        /**
         * Set the global animation to either a given value, or fall back to the
         * given chart's animation option
         * @param {Object} animation
         * @param {Object} chart
         */
        function setAnimation(animation, chart) {
            globalAnimation = pick(animation, chart.animation);
        }

        /**
         * The time unit lookup
         */
        timeUnits = {
            millisecond: 1,
            second: 1000,
            minute: 60000,
            hour: 3600000,
            day: 24 * 3600000,
            week: 7 * 24 * 3600000,
            month: 28 * 24 * 3600000,
            year: 364 * 24 * 3600000
        };


        /**
         * Format a number and return a string based on input settings
         * @param {Number} number The input number to format
         * @param {Number} decimals The amount of decimals
         * @param {String} decPoint The decimal point, defaults to the one given in the lang options
         * @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options
         */
        Highcharts.numberFormat = function (number, decimals, decPoint, thousandsSep) {
            var lang = defaultOptions.lang,
                // http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_number_format/
                n = +number || 0,
                c = decimals === -1 ?
                    mathMin((n.toString().split('.')[1] || '').length, 20) : // Preserve decimals. Not huge numbers (#3793).
                    (isNaN(decimals = mathAbs(decimals)) ? 2 : decimals),
                d = decPoint === undefined ? lang.decimalPoint : decPoint,
                t = thousandsSep === undefined ? lang.thousandsSep : thousandsSep,
                s = n < 0 ? "-" : "",
                i = String(pInt(n = mathAbs(n).toFixed(c))),
                j = i.length > 3 ? i.length % 3 : 0;

            return (s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) +
                    (c ? d + mathAbs(n - i).toFixed(c).slice(2) : ""));
        };
        /**
         * Path interpolation algorithm used across adapters
         */
        pathAnim = {
            /**
             * Prepare start and end values so that the path can be animated one to one
             */
            init: function (elem, fromD, toD) {
                fromD = fromD || '';
                var shift = elem.shift,
                    bezier = fromD.indexOf('C') > -1,
                    numParams = bezier ? 7 : 3,
                    endLength,
                    slice,
                    i,
                    start = fromD.split(' '),
                    end = [].concat(toD), // copy
                    startBaseLine,
                    endBaseLine,
                    sixify = function (arr) { // in splines make move points have six parameters like bezier curves
                        i = arr.length;
                        while (i--) {
                            if (arr[i] === M) {
                                arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);
                            }
                        }
                    };

                if (bezier) {
                    sixify(start);
                    sixify(end);
                }

                // pull out the base lines before padding
                if (elem.isArea) {
                    startBaseLine = start.splice(start.length - 6, 6);
                    endBaseLine = end.splice(end.length - 6, 6);
                }

                // if shifting points, prepend a dummy point to the end path
                if (shift <= end.length / numParams && start.length === end.length) {
                    while (shift--) {
                        end = [].concat(end).splice(0, numParams).concat(end);
                    }
                }
                elem.shift = 0; // reset for following animations

                // copy and append last point until the length matches the end length
                if (start.length) {
                    endLength = end.length;
                    while (start.length < endLength) {

                        //bezier && sixify(start);
                        slice = [].concat(start).splice(start.length - numParams, numParams);
                        if (bezier) { // disable first control point
                            slice[numParams - 6] = slice[numParams - 2];
                            slice[numParams - 5] = slice[numParams - 1];
                        }
                        start = start.concat(slice);
                    }
                }

                if (startBaseLine) { // append the base lines for areas
                    start = start.concat(startBaseLine);
                    end = end.concat(endBaseLine);
                }
                return [start, end];
            },

            /**
             * Interpolate each value of the path and return the array
             */
            step: function (start, end, pos, complete) {
                var ret = [],
                    i = start.length,
                    startVal;

                if (pos === 1) { // land on the final path without adjustment points appended in the ends
                    ret = complete;

                } else if (i === end.length && pos < 1) {
                    while (i--) {
                        startVal = parseFloat(start[i]);
                        ret[i] =
                            isNaN(startVal) ? // a letter instruction like M or L
                                start[i] :
                                pos * (parseFloat(end[i] - startVal)) + startVal;

                    }
                } else { // if animation is finished or length not matching, land on right value
                    ret = end;
                }
                return ret;
            }
        };

        (function ($) {
            /**
             * The default HighchartsAdapter for jQuery
             */
            win.HighchartsAdapter = win.HighchartsAdapter || ($ && {

                /**
                 * Initialize the adapter by applying some extensions to jQuery
                 */
                init: function (pathAnim) {

                    // extend the animate function to allow SVG animations
                    var Fx = $.fx;

                    /*jslint unparam: true*//* allow unused param x in this function */
                    $.extend($.easing, {
                        easeOutQuad: function (x, t, b, c, d) {
                            return -c * (t /= d) * (t - 2) + b;
                        }
                    });
                    /*jslint unparam: false*/

                    // extend some methods to check for elem.attr, which means it is a Highcharts SVG object
                    $.each(['cur', '_default', 'width', 'height', 'opacity'], function (i, fn) {
                        var obj = Fx.step,
                            base;

                        // Handle different parent objects
                        if (fn === 'cur') {
                            obj = Fx.prototype; // 'cur', the getter, relates to Fx.prototype

                        } else if (fn === '_default' && $.Tween) { // jQuery 1.8 model
                            obj = $.Tween.propHooks[fn];
                            fn = 'set';
                        }

                        // Overwrite the method
                        base = obj[fn];
                        if (base) { // step.width and step.height don't exist in jQuery < 1.7

                            // create the extended function replacement
                            obj[fn] = function (fx) {

                                var elem;

                                // Fx.prototype.cur does not use fx argument
                                fx = i ? fx : this;

                                // Don't run animations on textual properties like align (#1821)
                                if (fx.prop === 'align') {
                                    return;
                                }

                                // shortcut
                                elem = fx.elem;

                                // Fx.prototype.cur returns the current value. The other ones are setters
                                // and returning a value has no effect.
                                return elem.attr ? // is SVG element wrapper
                                    elem.attr(fx.prop, fn === 'cur' ? UNDEFINED : fx.now) : // apply the SVG wrapper's method
                                    base.apply(this, arguments); // use jQuery's built-in method
                            };
                        }
                    });

                    // Extend the opacity getter, needed for fading opacity with IE9 and jQuery 1.10+
                    wrap($.cssHooks.opacity, 'get', function (proceed, elem, computed) {
                        return elem.attr ? (elem.opacity || 0) : proceed.call(this, elem, computed);
                    });

                    // Define the setter function for d (path definitions)
                    this.addAnimSetter('d', function (fx) {
                        var elem = fx.elem,
                            ends;

                        // Normally start and end should be set in state == 0, but sometimes,
                        // for reasons unknown, this doesn't happen. Perhaps state == 0 is skipped
                        // in these cases
                        if (!fx.started) {
                            ends = pathAnim.init(elem, elem.d, elem.toD);
                            fx.start = ends[0];
                            fx.end = ends[1];
                            fx.started = true;
                        }

                        // Interpolate each value of the path
                        elem.attr('d', pathAnim.step(fx.start, fx.end, fx.pos, elem.toD));
                    });

                    /**
                     * Utility for iterating over an array. Parameters are reversed compared to jQuery.
                     * @param {Array} arr
                     * @param {Function} fn
                     */
                    this.each = Array.prototype.forEach ?
                        function (arr, fn) { // modern browsers
                            return Array.prototype.forEach.call(arr, fn);

                        } :
                        function (arr, fn) { // legacy
                            var i,
                                len = arr.length;
                            for (i = 0; i < len; i++) {
                                if (fn.call(arr[i], arr[i], i, arr) === false) {
                                    return i;
                                }
                            }
                        };

                    /**
                     * Register Highcharts as a plugin in the respective framework
                     */
                    $.fn.highcharts = function () {
                        var constr = 'Chart', // default constructor
                            args = arguments,
                            options,
                            ret,
                            chart;

                        if (this[0]) {

                            if (isString(args[0])) {
                                constr = args[0];
                                args = Array.prototype.slice.call(args, 1);
                            }
                            options = args[0];

                            // Create the chart
                            if (options !== UNDEFINED) {
                                /*jslint unused:false*/
                                options.chart = options.chart || {};
                                options.chart.renderTo = this[0];
                                chart = new Highcharts[constr](options, args[1]);
                                ret = this;
                                /*jslint unused:true*/
                            }

                            // When called without parameters or with the return argument, get a predefined chart
                            if (options === UNDEFINED) {
                                ret = charts[attr(this[0], 'data-highcharts-chart')];
                            }
                        }

                        return ret;
                    };

                },

                /**
                 * Add an animation setter for a specific property
                 */
                addAnimSetter: function (prop, setter) {
                    // jQuery 1.8 style
                    if ($.Tween) {
                        $.Tween.propHooks[prop] = {
                            set: setter
                        };
                        // pre 1.8
                    } else {
                        $.fx.step[prop] = setter;
                    }
                },

                /**
                 * Downloads a script and executes a callback when done.
                 * @param {String} scriptLocation
                 * @param {Function} callback
                 */
                getScript: $.getScript,

                /**
                 * Return the index of an item in an array, or -1 if not found
                 */
                inArray: $.inArray,

                /**
                 * A direct link to jQuery methods. MooTools and Prototype adapters must be implemented for each case of method.
                 * @param {Object} elem The HTML element
                 * @param {String} method Which method to run on the wrapped element
                 */
                adapterRun: function (elem, method) {
                    return $(elem)[method]();
                },

                /**
                 * Filter an array
                 */
                grep: $.grep,

                /**
                 * Map an array
                 * @param {Array} arr
                 * @param {Function} fn
                 */
                map: function (arr, fn) {
                    //return jQuery.map(arr, fn);
                    var results = [],
                        i = 0,
                        len = arr.length;
                    for (; i < len; i++) {
                        results[i] = fn.call(arr[i], arr[i], i, arr);
                    }
                    return results;

                },

                /**
                 * Get the position of an element relative to the top left of the page
                 */
                offset: function (el) {
                    return $(el).offset();
                },

                /**
                 * Add an event listener
                 * @param {Object} el A HTML element or custom object
                 * @param {String} event The event type
                 * @param {Function} fn The event handler
                 */
                addEvent: function (el, event, fn) {
                    $(el).bind(event, fn);
                },

                /**
                 * Remove event added with addEvent
                 * @param {Object} el The object
                 * @param {String} eventType The event type. Leave blank to remove all events.
                 * @param {Function} handler The function to remove
                 */
                removeEvent: function (el, eventType, handler) {
                    // workaround for jQuery issue with unbinding custom events:
                    // http://forum.jQuery.com/topic/javascript-error-when-unbinding-a-custom-event-using-jQuery-1-4-2
                    var func = doc.removeEventListener ? 'removeEventListener' : 'detachEvent';
                    if (doc[func] && el && !el[func]) {
                        el[func] = function () { };
                    }

                    $(el).unbind(eventType, handler);
                },

                /**
                 * Fire an event on a custom object
                 * @param {Object} el
                 * @param {String} type
                 * @param {Object} eventArguments
                 * @param {Function} defaultFunction
                 */
                fireEvent: function (el, type, eventArguments, defaultFunction) {
                    var event = $.Event(type),
                        detachedType = 'detached' + type,
                        defaultPrevented;

                    // Remove warnings in Chrome when accessing returnValue (#2790), layerX and layerY. Although Highcharts
                    // never uses these properties, Chrome includes them in the default click event and
                    // raises the warning when they are copied over in the extend statement below.
                    //
                    // To avoid problems in IE (see #1010) where we cannot delete the properties and avoid
                    // testing if they are there (warning in chrome) the only option is to test if running IE.
                    if (!isIE && eventArguments) {
                        delete eventArguments.layerX;
                        delete eventArguments.layerY;
                        delete eventArguments.returnValue;
                    }

                    extend(event, eventArguments);

                    // Prevent jQuery from triggering the object method that is named the
                    // same as the event. For example, if the event is 'select', jQuery
                    // attempts calling el.select and it goes into a loop.
                    if (el[type]) {
                        el[detachedType] = el[type];
                        el[type] = null;
                    }

                    // Wrap preventDefault and stopPropagation in try/catch blocks in
                    // order to prevent JS errors when cancelling events on non-DOM
                    // objects. #615.
                    /*jslint unparam: true*/
                    $.each(['preventDefault', 'stopPropagation'], function (i, fn) {
                        var base = event[fn];
                        event[fn] = function () {
                            try {
                                base.call(event);
                            } catch (e) {
                                if (fn === 'preventDefault') {
                                    defaultPrevented = true;
                                }
                            }
                        };
                    });
                    /*jslint unparam: false*/

                    // trigger it
                    $(el).trigger(event);

                    // attach the method
                    if (el[detachedType]) {
                        el[type] = el[detachedType];
                        el[detachedType] = null;
                    }

                    if (defaultFunction && !event.isDefaultPrevented() && !defaultPrevented) {
                        defaultFunction(event);
                    }
                },

                /**
                 * Extension method needed for MooTools
                 */
                washMouseEvent: function (e) {
                    var ret = e.originalEvent || e;

                    // computed by jQuery, needed by IE8
                    if (ret.pageX === UNDEFINED) { // #1236
                        ret.pageX = e.pageX;
                        ret.pageY = e.pageY;
                    }

                    return ret;
                },

                /**
                 * Animate a HTML element or SVG element wrapper
                 * @param {Object} el
                 * @param {Object} params
                 * @param {Object} options jQuery-like animation options: duration, easing, callback
                 */
                animate: function (el, params, options) {
                    var $el = $(el);
                    if (!el.style) {
                        el.style = {}; // #1881
                    }
                    if (params.d) {
                        el.toD = params.d; // keep the array form for paths, used in $.fx.step.d
                        params.d = 1; // because in jQuery, animating to an array has a different meaning
                    }

                    $el.stop();
                    if (params.opacity !== UNDEFINED && el.attr) {
                        params.opacity += 'px'; // force jQuery to use same logic as width and height (#2161)
                    }
                    el.hasAnim = 1; // #3342
                    $el.animate(params, options);

                },
                /**
                 * Stop running animation
                 */
                stop: function (el) {
                    if (el.hasAnim) { // #3342, memory leak on calling $(el) from destroy
                        $(el).stop();
                    }
                }
            });
        }(win.jQuery));


        // check for a custom HighchartsAdapter defined prior to this file
        var globalAdapter = win.HighchartsAdapter,
            adapter = globalAdapter || {};

        // Initialize the adapter
        if (globalAdapter) {
            globalAdapter.init.call(globalAdapter, pathAnim);
        }


        // Utility functions. If the HighchartsAdapter is not defined, adapter is an empty object
        // and all the utility functions will be null. In that case they are populated by the
        // default adapters below.
        var adapterRun = adapter.adapterRun,
            getScript = adapter.getScript,
            inArray = adapter.inArray,
            each = Highcharts.each = adapter.each,
            grep = adapter.grep,
            offset = adapter.offset,
            map = adapter.map,
            addEvent = adapter.addEvent,
            removeEvent = adapter.removeEvent,
            fireEvent = adapter.fireEvent,
            washMouseEvent = adapter.washMouseEvent,
            animate = adapter.animate,
            stop = adapter.stop;



        /* ****************************************************************************
         * Handle the options                                                         *
         *****************************************************************************/
        defaultOptions = {
            colors: ['#7cb5ec', '#434348', '#90ed7d', '#f7a35c',
                    '#8085e9', '#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1'],
            symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
            lang: {
                loading: 'Loading...',
                months: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
                        'August', 'September', 'October', 'November', 'December'],
                shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                decimalPoint: '.',
                numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'], // SI prefixes used in axis labels
                resetZoom: 'Reset zoom',
                resetZoomTitle: 'Reset zoom level 1:1',
                thousandsSep: ' '
            },
            global: {
                useUTC: true,
                //timezoneOffset: 0,
                canvasToolsURL: 'http://code.highcharts.com/4.1.7/modules/canvas-tools.js',
                VMLRadialGradientURL: 'http://code.highcharts.com/4.1.7/gfx/vml-radial-gradient.png'
            },
            chart: {
                //animation: true,
                //alignTicks: false,
                //reflow: true,
                //className: null,
                //events: { load, selection },
                //margin: [null],
                //marginTop: null,
                //marginRight: null,
                //marginBottom: null,
                //marginLeft: null,
                borderColor: '#4572A7',
                //borderWidth: 0,
                borderRadius: 0,
                defaultSeriesType: 'line',
                ignoreHiddenSeries: true,
                //inverted: false,
                //shadow: false,
                spacing: [10, 10, 15, 10],
                //spacingTop: 10,
                //spacingRight: 10,
                //spacingBottom: 15,
                //spacingLeft: 10,
                //style: {
                //	fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif', // default font
                //	fontSize: '12px'
                //},
                backgroundColor: '#FFFFFF',
                //plotBackgroundColor: null,
                plotBorderColor: '#C0C0C0',
                //plotBorderWidth: 0,
                //plotShadow: false,
                //zoomType: ''
                resetZoomButton: {
                    theme: {
                        zIndex: 20
                    },
                    position: {
                        align: 'right',
                        x: -10,
                        //verticalAlign: 'top',
                        y: 10
                    }
                    // relativeTo: 'plot'
                }
            },
            title: {
                text: 'Chart title',
                align: 'center',
                // floating: false,
                margin: 15,
                // x: 0,
                // verticalAlign: 'top',
                // y: null,
                style: {
                    color: '#333333',
                    fontSize: '18px'
                }

            },
            subtitle: {
                text: '',
                align: 'center',
                // floating: false
                // x: 0,
                // verticalAlign: 'top',
                // y: null,
                style: {
                    color: '#555555'
                }
            },

            plotOptions: {
                line: { // base series options
                    allowPointSelect: false,
                    showCheckbox: false,
                    animation: {
                        duration: 1000
                    },
                    //connectNulls: false,
                    //cursor: 'default',
                    //clip: true,
                    //dashStyle: null,
                    //enableMouseTracking: true,
                    events: {},
                    //legendIndex: 0,
                    //linecap: 'round',
                    lineWidth: 2,
                    //shadow: false,
                    // stacking: null,
                    marker: {
                        //enabled: true,
                        //symbol: null,
                        lineWidth: 0,
                        radius: 4,
                        lineColor: '#FFFFFF',
                        //fillColor: null,
                        states: { // states for a single point
                            hover: {
                                enabled: true,
                                lineWidthPlus: 1,
                                radiusPlus: 2
                            },
                            select: {
                                fillColor: '#FFFFFF',
                                lineColor: '#000000',
                                lineWidth: 2
                            }
                        }
                    },
                    point: {
                        events: {}
                    },
                    dataLabels: {
                        align: 'center',
                        // defer: true,
                        // enabled: false,
                        formatter: function () {
                            return this.y === null ? '' : Highcharts.numberFormat(this.y, -1);
                        },
                        style: {
                            color: 'contrast',
                            fontSize: '11px',
                            fontWeight: 'bold',
                            textShadow: '0 0 6px contrast, 0 0 3px contrast'
                        },
                        verticalAlign: 'bottom', // above singular point
                        x: 0,
                        y: 0,
                        // backgroundColor: undefined,
                        // borderColor: undefined,
                        // borderRadius: undefined,
                        // borderWidth: undefined,
                        padding: 5
                        // shadow: false
                    },
                    cropThreshold: 300, // draw points outside the plot area when the number of points is less than this
                    pointRange: 0,
                    //pointStart: 0,
                    //pointInterval: 1,
                    //showInLegend: null, // auto: true for standalone series, false for linked series
                    states: { // states for the entire series
                        hover: {
                            //enabled: false,
                            lineWidthPlus: 1,
                            marker: {
                                // lineWidth: base + 1,
                                // radius: base + 1
                            },
                            halo: {
                                size: 10,
                                opacity: 0.25
                            }
                        },
                        select: {
                            marker: {}
                        }
                    },
                    stickyTracking: true,
                    //tooltip: {
                    //pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b>'
                    //valueDecimals: null,
                    //xDateFormat: '%A, %b %e, %Y',
                    //valuePrefix: '',
                    //ySuffix: ''				
                    //}
                    turboThreshold: 1000
                    // zIndex: null
                }
            },
            labels: {
                //items: [],
                style: {
                    //font: defaultFont,
                    position: ABSOLUTE,
                    color: '#3E576F'
                }
            },
            legend: {
                enabled: true,
                align: 'center',
                //floating: false,
                layout: 'horizontal',
                labelFormatter: function () {
                    return this.name;
                },
                //borderWidth: 0,
                borderColor: '#909090',
                borderRadius: 0,
                navigation: {
                    // animation: true,
                    activeColor: '#274b6d',
                    // arrowSize: 12
                    inactiveColor: '#CCC'
                    // style: {} // text styles
                },
                // margin: 20,
                // reversed: false,
                shadow: false,
                // backgroundColor: null,
                /*style: {
                    padding: '5px'
                },*/
                itemStyle: {
                    color: '#333333',
                    fontSize: '12px',
                    fontWeight: 'bold'
                },
                itemHoverStyle: {
                    //cursor: 'pointer', removed as of #601
                    color: '#000'
                },
                itemHiddenStyle: {
                    color: '#CCC'
                },
                itemCheckboxStyle: {
                    position: ABSOLUTE,
                    width: '13px', // for IE precision
                    height: '13px'
                },
                // itemWidth: undefined,
                // symbolRadius: 0,
                // symbolWidth: 16,
                symbolPadding: 5,
                verticalAlign: 'bottom',
                // width: undefined,
                x: 0,
                y: 0,
                title: {
                    //text: null,
                    style: {
                        fontWeight: 'bold'
                    }
                }
            },

            loading: {
                // hideDuration: 100,
                labelStyle: {
                    fontWeight: 'bold',
                    position: RELATIVE,
                    top: '45%'
                },
                // showDuration: 0,
                style: {
                    position: ABSOLUTE,
                    backgroundColor: 'white',
                    opacity: 0.5,
                    textAlign: 'center'
                }
            },

            tooltip: {
                enabled: true,
                animation: hasSVG,
                //crosshairs: null,
                backgroundColor: 'rgba(249, 249, 249, .85)',
                borderWidth: 1,
                borderRadius: 3,
                dateTimeLabelFormats: {
                    millisecond: '%A, %b %e, %H:%M:%S.%L',
                    second: '%A, %b %e, %H:%M:%S',
                    minute: '%A, %b %e, %H:%M',
                    hour: '%A, %b %e, %H:%M',
                    day: '%A, %b %e, %Y',
                    week: 'Week from %A, %b %e, %Y',
                    month: '%B %Y',
                    year: '%Y'
                },
                footerFormat: '',
                //formatter: defaultFormatter,
                headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
                pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',
                shadow: true,
                //shape: 'callout',
                //shared: false,
                snap: isTouchDevice ? 25 : 10,
                style: {
                    color: '#333333',
                    cursor: 'default',
                    fontSize: '12px',
                    padding: '8px',
                    whiteSpace: 'nowrap'
                }
                //xDateFormat: '%A, %b %e, %Y',
                //valueDecimals: null,
                //valuePrefix: '',
                //valueSuffix: ''
            },

            credits: {
                enabled: true,
                text: 'Highcharts.com',
                href: 'http://www.highcharts.com',
                position: {
                    align: 'right',
                    x: -10,
                    verticalAlign: 'bottom',
                    y: -5
                },
                style: {
                    cursor: 'pointer',
                    color: '#909090',
                    fontSize: '9px'
                }
            }
        };




        // Series defaults
        var defaultPlotOptions = defaultOptions.plotOptions,
            defaultSeriesOptions = defaultPlotOptions.line;

        // set the default time methods
        setTimeMethods();



        /**
         * Set the time methods globally based on the useUTC option. Time method can be either
         * local time or UTC (default).
         */
        function setTimeMethods() {
            var globalOptions = defaultOptions.global,
                useUTC = globalOptions.useUTC,
                GET = useUTC ? 'getUTC' : 'get',
                SET = useUTC ? 'setUTC' : 'set';


            Date = globalOptions.Date || window.Date;
            timezoneOffset = useUTC && globalOptions.timezoneOffset;
            getTimezoneOffset = useUTC && globalOptions.getTimezoneOffset;
            makeTime = function (year, month, date, hours, minutes, seconds) {
                var d;
                if (useUTC) {
                    d = Date.UTC.apply(0, arguments);
                    d += getTZOffset(d);
                } else {
                    d = new Date(
                        year,
                        month,
                        pick(date, 1),
                        pick(hours, 0),
                        pick(minutes, 0),
                        pick(seconds, 0)
                    ).getTime();
                }
                return d;
            };
            getMinutes = GET + 'Minutes';
            getHours = GET + 'Hours';
            getDay = GET + 'Day';
            getDate = GET + 'Date';
            getMonth = GET + 'Month';
            getFullYear = GET + 'FullYear';
            setMilliseconds = SET + 'Milliseconds';
            setSeconds = SET + 'Seconds';
            setMinutes = SET + 'Minutes';
            setHours = SET + 'Hours';
            setDate = SET + 'Date';
            setMonth = SET + 'Month';
            setFullYear = SET + 'FullYear';

        }

        /**
         * Merge the default options with custom options and return the new options structure
         * @param {Object} options The new custom options
         */
        function setOptions(options) {

            // Copy in the default options
            defaultOptions = merge(true, defaultOptions, options);

            // Apply UTC
            setTimeMethods();

            return defaultOptions;
        }

        /**
         * Get the updated default options. Until 3.0.7, merely exposing defaultOptions for outside modules
         * wasn't enough because the setOptions method created a new object.
         */
        function getOptions() {
            return defaultOptions;
        }


        /**
         * Handle color operations. The object methods are chainable.
         * @param {String} input The input color in either rbga or hex format
         */
        var rgbaRegEx = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
            hexRegEx = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,
            rgbRegEx = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/;

        var Color = function (input) {
            // declare variables
            var rgba = [], result, stops;

            /**
             * Parse the input color to rgba array
             * @param {String} input
             */
            function init(input) {

                // Gradients
                if (input && input.stops) {
                    stops = map(input.stops, function (stop) {
                        return Color(stop[1]);
                    });

                    // Solid colors
                } else {
                    // rgba
                    result = rgbaRegEx.exec(input);
                    if (result) {
                        rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
                    } else {
                        // hex
                        result = hexRegEx.exec(input);
                        if (result) {
                            rgba = [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];
                        } else {
                            // rgb
                            result = rgbRegEx.exec(input);
                            if (result) {
                                rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];
                            }
                        }
                    }
                }

            }
            /**
             * Return the color a specified format
             * @param {String} format
             */
            function get(format) {
                var ret;

                if (stops) {
                    ret = merge(input);
                    ret.stops = [].concat(ret.stops);
                    each(stops, function (stop, i) {
                        ret.stops[i] = [ret.stops[i][0], stop.get(format)];
                    });

                    // it's NaN if gradient colors on a column chart
                } else if (rgba && !isNaN(rgba[0])) {
                    if (format === 'rgb') {
                        ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';
                    } else if (format === 'a') {
                        ret = rgba[3];
                    } else {
                        ret = 'rgba(' + rgba.join(',') + ')';
                    }
                } else {
                    ret = input;
                }
                return ret;
            }

            /**
             * Brighten the color
             * @param {Number} alpha
             */
            function brighten(alpha) {
                if (stops) {
                    each(stops, function (stop) {
                        stop.brighten(alpha);
                    });

                } else if (isNumber(alpha) && alpha !== 0) {
                    var i;
                    for (i = 0; i < 3; i++) {
                        rgba[i] += pInt(alpha * 255);

                        if (rgba[i] < 0) {
                            rgba[i] = 0;
                        }
                        if (rgba[i] > 255) {
                            rgba[i] = 255;
                        }
                    }
                }
                return this;
            }
            /**
             * Set the color's opacity to a given alpha value
             * @param {Number} alpha
             */
            function setOpacity(alpha) {
                rgba[3] = alpha;
                return this;
            }

            // initialize: parse the input
            init(input);

            // public methods
            return {
                get: get,
                brighten: brighten,
                rgba: rgba,
                setOpacity: setOpacity,
                raw: input
            };
        };


        /**
         * A wrapper object for SVG elements
         */
        function SVGElement() { }

        SVGElement.prototype = {

            // Default base for animation
            opacity: 1,
            // For labels, these CSS properties are applied to the <text> node directly
            textProps: ['fontSize', 'fontWeight', 'fontFamily', 'fontStyle', 'color',
                'lineHeight', 'width', 'textDecoration', 'textShadow'],

            /**
             * Initialize the SVG renderer
             * @param {Object} renderer
             * @param {String} nodeName
             */
            init: function (renderer, nodeName) {
                var wrapper = this;
                wrapper.element = nodeName === 'span' ?
                    createElement(nodeName) :
                    doc.createElementNS(SVG_NS, nodeName);
                wrapper.renderer = renderer;
            },

            /**
             * Animate a given attribute
             * @param {Object} params
             * @param {Number} options The same options as in jQuery animation
             * @param {Function} complete Function to perform at the end of animation
             */
            animate: function (params, options, complete) {
                var animOptions = pick(options, globalAnimation, true);
                stop(this); // stop regardless of animation actually running, or reverting to .attr (#607)
                if (animOptions) {
                    animOptions = merge(animOptions, {}); //#2625
                    if (complete) { // allows using a callback with the global animation without overwriting it
                        animOptions.complete = complete;
                    }
                    animate(this, params, animOptions);
                } else {
                    this.attr(params);
                    if (complete) {
                        complete();
                    }
                }
                return this;
            },

            /**
             * Build an SVG gradient out of a common JavaScript configuration object
             */
            colorGradient: function (color, prop, elem) {
                var renderer = this.renderer,
                    colorObject,
                    gradName,
                    gradAttr,
                    gradients,
                    gradientObject,
                    stops,
                    stopColor,
                    stopOpacity,
                    radialReference,
                    n,
                    id,
                    key = [];

                // Apply linear or radial gradients
                if (color.linearGradient) {
                    gradName = 'linearGradient';
                } else if (color.radialGradient) {
                    gradName = 'radialGradient';
                }

                if (gradName) {
                    gradAttr = color[gradName];
                    gradients = renderer.gradients;
                    stops = color.stops;
                    radialReference = elem.radialReference;

                    // Keep < 2.2 kompatibility
                    if (isArray(gradAttr)) {
                        color[gradName] = gradAttr = {
                            x1: gradAttr[0],
                            y1: gradAttr[1],
                            x2: gradAttr[2],
                            y2: gradAttr[3],
                            gradientUnits: 'userSpaceOnUse'
                        };
                    }

                    // Correct the radial gradient for the radial reference system
                    if (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {
                        gradAttr = merge(gradAttr, {
                            cx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],
                            cy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],
                            r: gradAttr.r * radialReference[2],
                            gradientUnits: 'userSpaceOnUse'
                        });
                    }

                    // Build the unique key to detect whether we need to create a new element (#1282)
                    for (n in gradAttr) {
                        if (n !== 'id') {
                            key.push(n, gradAttr[n]);
                        }
                    }
                    for (n in stops) {
                        key.push(stops[n]);
                    }
                    key = key.join(',');

                    // Check if a gradient object with the same config object is created within this renderer
                    if (gradients[key]) {
                        id = gradients[key].attr('id');

                    } else {

                        // Set the id and create the element
                        gradAttr.id = id = PREFIX + idCounter++;
                        gradients[key] = gradientObject = renderer.createElement(gradName)
                            .attr(gradAttr)
                            .add(renderer.defs);


                        // The gradient needs to keep a list of stops to be able to destroy them
                        gradientObject.stops = [];
                        each(stops, function (stop) {
                            var stopObject;
                            if (stop[1].indexOf('rgba') === 0) {
                                colorObject = Color(stop[1]);
                                stopColor = colorObject.get('rgb');
                                stopOpacity = colorObject.get('a');
                            } else {
                                stopColor = stop[1];
                                stopOpacity = 1;
                            }
                            stopObject = renderer.createElement('stop').attr({
                                offset: stop[0],
                                'stop-color': stopColor,
                                'stop-opacity': stopOpacity
                            }).add(gradientObject);

                            // Add the stop element to the gradient
                            gradientObject.stops.push(stopObject);
                        });
                    }

                    // Set the reference to the gradient object
                    elem.setAttribute(prop, 'url(' + renderer.url + '#' + id + ')');
                }
            },

            /**
             * Apply a polyfill to the text-stroke CSS property, by copying the text element
             * and apply strokes to the copy.
             *
             * docs: update default, document the polyfill and the limitations on hex colors and pixel values, document contrast pseudo-color
             * TODO: 
             * - update defaults
             */
            applyTextShadow: function (textShadow) {
                var elem = this.element,
                    tspans,
                    hasContrast = textShadow.indexOf('contrast') !== -1,
                    styles = {},
                    // IE10 and IE11 report textShadow in elem.style even though it doesn't work. Check
                    // this again with new IE release. In exports, the rendering is passed to PhantomJS. 
                    supports = this.renderer.forExport || (elem.style.textShadow !== UNDEFINED && !isIE);

                // When the text shadow is set to contrast, use dark stroke for light text and vice versa
                if (hasContrast) {
                    styles.textShadow = textShadow = textShadow.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));
                }

                // Safari with retina displays as well as PhantomJS bug (#3974). Firefox does not tolerate this,
                // it removes the text shadows.
                if (isWebKit) {
                    styles.textRendering = 'geometricPrecision';
                }

                /* Selective side-by-side testing in supported browser (http://jsfiddle.net/highcharts/73L1ptrh/)
                if (elem.textContent.indexOf('2.') === 0) {
                    elem.style['text-shadow'] = 'none';
                    supports = false;
                }
                // */

                // No reason to polyfill, we've got native support
                if (supports) {
                    css(elem, styles); // Apply altered textShadow or textRendering workaround
                } else {

                    this.fakeTS = true; // Fake text shadow

                    // In order to get the right y position of the clones, 
                    // copy over the y setter
                    this.ySetter = this.xSetter;

                    tspans = [].slice.call(elem.getElementsByTagName('tspan'));
                    each(textShadow.split(/\s?,\s?/g), function (textShadow) {
                        var firstChild = elem.firstChild,
                            color,
                            strokeWidth;

                        textShadow = textShadow.split(' ');
                        color = textShadow[textShadow.length - 1];

                        // Approximately tune the settings to the text-shadow behaviour
                        strokeWidth = textShadow[textShadow.length - 2];

                        if (strokeWidth) {
                            each(tspans, function (tspan, y) {
                                var clone;

                                // Let the first line start at the correct X position
                                if (y === 0) {
                                    tspan.setAttribute('x', elem.getAttribute('x'));
                                    y = elem.getAttribute('y');
                                    tspan.setAttribute('y', y || 0);
                                    if (y === null) {
                                        elem.setAttribute('y', 0);
                                    }
                                }

                                // Create the clone and apply shadow properties
                                clone = tspan.cloneNode(1);
                                attr(clone, {
                                    'class': PREFIX + 'text-shadow',
                                    'fill': color,
                                    'stroke': color,
                                    'stroke-opacity': 1 / mathMax(pInt(strokeWidth), 3),
                                    'stroke-width': strokeWidth,
                                    'stroke-linejoin': 'round'
                                });
                                elem.insertBefore(clone, firstChild);
                            });
                        }
                    });
                }
            },

            /**
             * Set or get a given attribute
             * @param {Object|String} hash
             * @param {Mixed|Undefined} val
             */
            attr: function (hash, val) {
                var key,
                    value,
                    element = this.element,
                    hasSetSymbolSize,
                    ret = this,
                    skipAttr;

                // single key-value pair
                if (typeof hash === 'string' && val !== UNDEFINED) {
                    key = hash;
                    hash = {};
                    hash[key] = val;
                }

                // used as a getter: first argument is a string, second is undefined
                if (typeof hash === 'string') {
                    ret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element);

                    // setter
                } else {

                    for (key in hash) {
                        value = hash[key];
                        skipAttr = false;



                        if (this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(key)) {
                            if (!hasSetSymbolSize) {
                                this.symbolAttr(hash);
                                hasSetSymbolSize = true;
                            }
                            skipAttr = true;
                        }

                        if (this.rotation && (key === 'x' || key === 'y')) {
                            this.doTransform = true;
                        }

                        if (!skipAttr) {
                            (this[key + 'Setter'] || this._defaultSetter).call(this, value, key, element);
                        }

                        // Let the shadow follow the main element
                        if (this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {
                            this.updateShadows(key, value);
                        }
                    }

                    // Update transform. Do this outside the loop to prevent redundant updating for batch setting
                    // of attributes.
                    if (this.doTransform) {
                        this.updateTransform();
                        this.doTransform = false;
                    }

                }

                return ret;
            },

            updateShadows: function (key, value) {
                var shadows = this.shadows,
                    i = shadows.length;
                while (i--) {
                    shadows[i].setAttribute(
                        key,
                        key === 'height' ?
                            mathMax(value - (shadows[i].cutHeight || 0), 0) :
                            key === 'd' ? this.d : value
                    );
                }
            },

            /**
             * Add a class name to an element
             */
            addClass: function (className) {
                var element = this.element,
                    currentClassName = attr(element, 'class') || '';

                if (currentClassName.indexOf(className) === -1) {
                    attr(element, 'class', currentClassName + ' ' + className);
                }
                return this;
            },
            /* hasClass and removeClass are not (yet) needed
            hasClass: function (className) {
                return attr(this.element, 'class').indexOf(className) !== -1;
            },
            removeClass: function (className) {
                attr(this.element, 'class', attr(this.element, 'class').replace(className, ''));
                return this;
            },
            */

            /**
             * If one of the symbol size affecting parameters are changed,
             * check all the others only once for each call to an element's
             * .attr() method
             * @param {Object} hash
             */
            symbolAttr: function (hash) {
                var wrapper = this;

                each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function (key) {
                    wrapper[key] = pick(hash[key], wrapper[key]);
                });

                wrapper.attr({
                    d: wrapper.renderer.symbols[wrapper.symbolName](
                        wrapper.x,
                        wrapper.y,
                        wrapper.width,
                        wrapper.height,
                        wrapper
                    )
                });
            },

            /**
             * Apply a clipping path to this object
             * @param {String} id
             */
            clip: function (clipRect) {
                return this.attr('clip-path', clipRect ? 'url(' + this.renderer.url + '#' + clipRect.id + ')' : NONE);
            },

            /**
             * Calculate the coordinates needed for drawing a rectangle crisply and return the
             * calculated attributes
             * @param {Number} strokeWidth
             * @param {Number} x
             * @param {Number} y
             * @param {Number} width
             * @param {Number} height
             */
            crisp: function (rect) {

                var wrapper = this,
                    key,
                    attribs = {},
                    normalizer,
                    strokeWidth = rect.strokeWidth || wrapper.strokeWidth || 0;

                normalizer = mathRound(strokeWidth) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors

                // normalize for crisp edges
                rect.x = mathFloor(rect.x || wrapper.x || 0) + normalizer;
                rect.y = mathFloor(rect.y || wrapper.y || 0) + normalizer;
                rect.width = mathFloor((rect.width || wrapper.width || 0) - 2 * normalizer);
                rect.height = mathFloor((rect.height || wrapper.height || 0) - 2 * normalizer);
                rect.strokeWidth = strokeWidth;

                for (key in rect) {
                    if (wrapper[key] !== rect[key]) { // only set attribute if changed
                        wrapper[key] = attribs[key] = rect[key];
                    }
                }

                return attribs;
            },

            /**
             * Set styles for the element
             * @param {Object} styles
             */
            css: function (styles) {
                var elemWrapper = this,
                    oldStyles = elemWrapper.styles,
                    newStyles = {},
                    elem = elemWrapper.element,
                    textWidth,
                    n,
                    serializedCss = '',
                    hyphenate,
                    hasNew = !oldStyles;

                // convert legacy
                if (styles && styles.color) {
                    styles.fill = styles.color;
                }

                // Filter out existing styles to increase performance (#2640)
                if (oldStyles) {
                    for (n in styles) {
                        if (styles[n] !== oldStyles[n]) {
                            newStyles[n] = styles[n];
                            hasNew = true;
                        }
                    }
                }
                if (hasNew) {
                    textWidth = elemWrapper.textWidth =
                        (styles && styles.width && elem.nodeName.toLowerCase() === 'text' && pInt(styles.width)) ||
                        elemWrapper.textWidth; // #3501

                    // Merge the new styles with the old ones
                    if (oldStyles) {
                        styles = extend(
                            oldStyles,
                            newStyles
                        );
                    }

                    // store object
                    elemWrapper.styles = styles;

                    if (textWidth && (useCanVG || (!hasSVG && elemWrapper.renderer.forExport))) {
                        delete styles.width;
                    }

                    // serialize and set style attribute
                    if (isIE && !hasSVG) {
                        css(elemWrapper.element, styles);
                    } else {
                        /*jslint unparam: true*/
                        hyphenate = function (a, b) { return '-' + b.toLowerCase(); };
                        /*jslint unparam: false*/
                        for (n in styles) {
                            serializedCss += n.replace(/([A-Z])/g, hyphenate) + ':' + styles[n] + ';';
                        }
                        attr(elem, 'style', serializedCss); // #1881
                    }


                    // re-build text
                    if (textWidth && elemWrapper.added) {
                        elemWrapper.renderer.buildText(elemWrapper);
                    }
                }

                return elemWrapper;
            },

            /**
             * Add an event listener
             * @param {String} eventType
             * @param {Function} handler
             */
            on: function (eventType, handler) {
                var svgElement = this,
                    element = svgElement.element;

                // touch
                if (hasTouch && eventType === 'click') {
                    element.ontouchstart = function (e) {
                        svgElement.touchEventFired = Date.now();
                        e.preventDefault();
                        handler.call(element, e);
                    };
                    element.onclick = function (e) {
                        if (userAgent.indexOf('Android') === -1 || Date.now() - (svgElement.touchEventFired || 0) > 1100) { // #2269
                            handler.call(element, e);
                        }
                    };
                } else {
                    // simplest possible event model for internal use
                    element['on' + eventType] = handler;
                }
                return this;
            },

            /**
             * Set the coordinates needed to draw a consistent radial gradient across
             * pie slices regardless of positioning inside the chart. The format is
             * [centerX, centerY, diameter] in pixels.
             */
            setRadialReference: function (coordinates) {
                this.element.radialReference = coordinates;
                return this;
            },

            /**
             * Move an object and its children by x and y values
             * @param {Number} x
             * @param {Number} y
             */
            translate: function (x, y) {
                return this.attr({
                    translateX: x,
                    translateY: y
                });
            },

            /**
             * Invert a group, rotate and flip
             */
            invert: function () {
                var wrapper = this;
                wrapper.inverted = true;
                wrapper.updateTransform();
                return wrapper;
            },

            /**
             * Private method to update the transform attribute based on internal
             * properties
             */
            updateTransform: function () {
                var wrapper = this,
                    translateX = wrapper.translateX || 0,
                    translateY = wrapper.translateY || 0,
                    scaleX = wrapper.scaleX,
                    scaleY = wrapper.scaleY,
                    inverted = wrapper.inverted,
                    rotation = wrapper.rotation,
                    element = wrapper.element,
                    transform;

                // flipping affects translate as adjustment for flipping around the group's axis
                if (inverted) {
                    translateX += wrapper.attr('width');
                    translateY += wrapper.attr('height');
                }

                // Apply translate. Nearly all transformed elements have translation, so instead
                // of checking for translate = 0, do it always (#1767, #1846).
                transform = ['translate(' + translateX + ',' + translateY + ')'];

                // apply rotation
                if (inverted) {
                    transform.push('rotate(90) scale(-1,1)');
                } else if (rotation) { // text rotation
                    transform.push('rotate(' + rotation + ' ' + (element.getAttribute('x') || 0) + ' ' + (element.getAttribute('y') || 0) + ')');

                    // Delete bBox memo when the rotation changes
                    //delete wrapper.bBox;
                }

                // apply scale
                if (defined(scaleX) || defined(scaleY)) {
                    transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');
                }

                if (transform.length) {
                    element.setAttribute('transform', transform.join(' '));
                }
            },
            /**
             * Bring the element to the front
             */
            toFront: function () {
                var element = this.element;
                element.parentNode.appendChild(element);
                return this;
            },


            /**
             * Break down alignment options like align, verticalAlign, x and y
             * to x and y relative to the chart.
             *
             * @param {Object} alignOptions
             * @param {Boolean} alignByTranslate
             * @param {String[Object} box The box to align to, needs a width and height. When the
             *		box is a string, it refers to an object in the Renderer. For example, when
             *		box is 'spacingBox', it refers to Renderer.spacingBox which holds width, height
             *		x and y properties.
             *
             */
            align: function (alignOptions, alignByTranslate, box) {
                var align,
                    vAlign,
                    x,
                    y,
                    attribs = {},
                    alignTo,
                    renderer = this.renderer,
                    alignedObjects = renderer.alignedObjects;

                // First call on instanciate
                if (alignOptions) {
                    this.alignOptions = alignOptions;
                    this.alignByTranslate = alignByTranslate;
                    if (!box || isString(box)) { // boxes other than renderer handle this internally
                        this.alignTo = alignTo = box || 'renderer';
                        erase(alignedObjects, this); // prevent duplicates, like legendGroup after resize
                        alignedObjects.push(this);
                        box = null; // reassign it below
                    }

                    // When called on resize, no arguments are supplied
                } else {
                    alignOptions = this.alignOptions;
                    alignByTranslate = this.alignByTranslate;
                    alignTo = this.alignTo;
                }

                box = pick(box, renderer[alignTo], renderer);

                // Assign variables
                align = alignOptions.align;
                vAlign = alignOptions.verticalAlign;
                x = (box.x || 0) + (alignOptions.x || 0); // default: left align
                y = (box.y || 0) + (alignOptions.y || 0); // default: top align

                // Align
                if (align === 'right' || align === 'center') {
                    x += (box.width - (alignOptions.width || 0)) /
                            { right: 1, center: 2 }[align];
                }
                attribs[alignByTranslate ? 'translateX' : 'x'] = mathRound(x);


                // Vertical align
                if (vAlign === 'bottom' || vAlign === 'middle') {
                    y += (box.height - (alignOptions.height || 0)) /
                            ({ bottom: 1, middle: 2 }[vAlign] || 1);

                }
                attribs[alignByTranslate ? 'translateY' : 'y'] = mathRound(y);

                // Animate only if already placed
                this[this.placed ? 'animate' : 'attr'](attribs);
                this.placed = true;
                this.alignAttr = attribs;

                return this;
            },

            /**
             * Get the bounding box (width, height, x and y) for the element
             */
            getBBox: function (reload) {
                var wrapper = this,
                    bBox,// = wrapper.bBox,
                    renderer = wrapper.renderer,
                    width,
                    height,
                    rotation = wrapper.rotation,
                    element = wrapper.element,
                    styles = wrapper.styles,
                    rad = rotation * deg2rad,
                    textStr = wrapper.textStr,
                    textShadow,
                    elemStyle = element.style,
                    toggleTextShadowShim,
                    cacheKey;

                if (textStr !== UNDEFINED) {

                    // Properties that affect bounding box
                    cacheKey = ['', rotation || 0, styles && styles.fontSize, element.style.width].join(',');

                    // Since numbers are monospaced, and numerical labels appear a lot in a chart,
                    // we assume that a label of n characters has the same bounding box as others 
                    // of the same length.
                    if (textStr === '' || numRegex.test(textStr)) {
                        cacheKey = 'num:' + textStr.toString().length + cacheKey;

                        // Caching all strings reduces rendering time by 4-5%.
                    } else {
                        cacheKey = textStr + cacheKey;
                    }
                }

                if (cacheKey && !reload) {
                    bBox = renderer.cache[cacheKey];
                }

                // No cache found
                if (!bBox) {

                    // SVG elements
                    if (element.namespaceURI === SVG_NS || renderer.forExport) {
                        try { // Fails in Firefox if the container has display: none.

                            // When the text shadow shim is used, we need to hide the fake shadows
                            // to get the correct bounding box (#3872)
                            toggleTextShadowShim = this.fakeTS && function (display) {
                                each(element.querySelectorAll('.' + PREFIX + 'text-shadow'), function (tspan) {
                                    tspan.style.display = display;
                                });
                            };

                            // Workaround for #3842, Firefox reporting wrong bounding box for shadows
                            if (isFirefox && elemStyle.textShadow) {
                                textShadow = elemStyle.textShadow;
                                elemStyle.textShadow = '';
                            } else if (toggleTextShadowShim) {
                                toggleTextShadowShim(NONE);
                            }

                            bBox = element.getBBox ?
                                // SVG: use extend because IE9 is not allowed to change width and height in case
                                // of rotation (below)
                                extend({}, element.getBBox()) :
                                // Canvas renderer and legacy IE in export mode
						{
						    width: element.offsetWidth,
						    height: element.offsetHeight
						};

                            // #3842
                            if (textShadow) {
                                elemStyle.textShadow = textShadow;
                            } else if (toggleTextShadowShim) {
                                toggleTextShadowShim('');
                            }
                        } catch (e) { }

                        // If the bBox is not set, the try-catch block above failed. The other condition
                        // is for Opera that returns a width of -Infinity on hidden elements.
                        if (!bBox || bBox.width < 0) {
                            bBox = { width: 0, height: 0 };
                        }


                        // VML Renderer or useHTML within SVG
                    } else {

                        bBox = wrapper.htmlGetBBox();

                    }

                    // True SVG elements as well as HTML elements in modern browsers using the .useHTML option
                    // need to compensated for rotation
                    if (renderer.isSVG) {
                        width = bBox.width;
                        height = bBox.height;

                        // Workaround for wrong bounding box in IE9 and IE10 (#1101, #1505, #1669, #2568)
                        if (isIE && styles && styles.fontSize === '11px' && height.toPrecision(3) === '16.9') {
                            bBox.height = height = 14;
                        }

                        // Adjust for rotated text
                        if (rotation) {
                            bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));
                            bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));
                        }
                    }

                    // Cache it
                    renderer.cache[cacheKey] = bBox;
                }
                return bBox;
            },

            /**
             * Show the element
             */
            show: function (inherit) {
                // IE9-11 doesn't handle visibilty:inherit well, so we remove the attribute instead (#2881)
                if (inherit && this.element.namespaceURI === SVG_NS) {
                    this.element.removeAttribute('visibility');
                } else {
                    this.attr({ visibility: inherit ? 'inherit' : VISIBLE });
                }
                return this;
            },

            /**
             * Hide the element
             */
            hide: function () {
                return this.attr({ visibility: HIDDEN });
            },

            fadeOut: function (duration) {
                var elemWrapper = this;
                elemWrapper.animate({
                    opacity: 0
                }, {
                    duration: duration || 150,
                    complete: function () {
                        elemWrapper.attr({ y: -9999 }); // #3088, assuming we're only using this for tooltips
                    }
                });
            },

            /**
             * Add the element
             * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined
             *	to append the element to the renderer.box.
             */
            add: function (parent) {

                var renderer = this.renderer,
                    element = this.element,
                    inserted;

                if (parent) {
                    this.parentGroup = parent;
                }

                // mark as inverted
                this.parentInverted = parent && parent.inverted;

                // build formatted text
                if (this.textStr !== undefined) {
                    renderer.buildText(this);
                }

                // Mark as added
                this.added = true;

                // If we're adding to renderer root, or other elements in the group 
                // have a z index, we need to handle it
                if (!parent || parent.handleZ || this.zIndex) {
                    inserted = this.zIndexSetter();
                }

                // If zIndex is not handled, append at the end
                if (!inserted) {
                    (parent ? parent.element : renderer.box).appendChild(element);
                }

                // fire an event for internal hooks
                if (this.onAdd) {
                    this.onAdd();
                }

                return this;
            },

            /**
             * Removes a child either by removeChild or move to garbageBin.
             * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
             */
            safeRemoveChild: function (element) {
                var parentNode = element.parentNode;
                if (parentNode) {
                    parentNode.removeChild(element);
                }
            },

            /**
             * Destroy the element and element wrapper
             */
            destroy: function () {
                var wrapper = this,
                    element = wrapper.element || {},
                    shadows = wrapper.shadows,
                    parentToClean = wrapper.renderer.isSVG && element.nodeName === 'SPAN' && wrapper.parentGroup,
                    grandParent,
                    key,
                    i;

                // remove events
                element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
                stop(wrapper); // stop running animations

                if (wrapper.clipPath) {
                    wrapper.clipPath = wrapper.clipPath.destroy();
                }

                // Destroy stops in case this is a gradient object
                if (wrapper.stops) {
                    for (i = 0; i < wrapper.stops.length; i++) {
                        wrapper.stops[i] = wrapper.stops[i].destroy();
                    }
                    wrapper.stops = null;
                }

                // remove element
                wrapper.safeRemoveChild(element);

                // destroy shadows
                if (shadows) {
                    each(shadows, function (shadow) {
                        wrapper.safeRemoveChild(shadow);
                    });
                }

                // In case of useHTML, clean up empty containers emulating SVG groups (#1960, #2393, #2697).
                while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {
                    grandParent = parentToClean.parentGroup;
                    wrapper.safeRemoveChild(parentToClean.div);
                    delete parentToClean.div;
                    parentToClean = grandParent;
                }

                // remove from alignObjects
                if (wrapper.alignTo) {
                    erase(wrapper.renderer.alignedObjects, wrapper);
                }

                for (key in wrapper) {
                    delete wrapper[key];
                }

                return null;
            },

            /**
             * Add a shadow to the element. Must be done after the element is added to the DOM
             * @param {Boolean|Object} shadowOptions
             */
            shadow: function (shadowOptions, group, cutOff) {
                var shadows = [],
                    i,
                    shadow,
                    element = this.element,
                    strokeWidth,
                    shadowWidth,
                    shadowElementOpacity,

                    // compensate for inverted plot area
                    transform;


                if (shadowOptions) {
                    shadowWidth = pick(shadowOptions.width, 3);
                    shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
                    transform = this.parentInverted ?
                        '(-1,-1)' :
                        '(' + pick(shadowOptions.offsetX, 1) + ', ' + pick(shadowOptions.offsetY, 1) + ')';
                    for (i = 1; i <= shadowWidth; i++) {
                        shadow = element.cloneNode(0);
                        strokeWidth = (shadowWidth * 2) + 1 - (2 * i);
                        attr(shadow, {
                            'isShadow': 'true',
                            'stroke': shadowOptions.color || 'black',
                            'stroke-opacity': shadowElementOpacity * i,
                            'stroke-width': strokeWidth,
                            'transform': 'translate' + transform,
                            'fill': NONE
                        });
                        if (cutOff) {
                            attr(shadow, 'height', mathMax(attr(shadow, 'height') - strokeWidth, 0));
                            shadow.cutHeight = strokeWidth;
                        }

                        if (group) {
                            group.element.appendChild(shadow);
                        } else {
                            element.parentNode.insertBefore(shadow, element);
                        }

                        shadows.push(shadow);
                    }

                    this.shadows = shadows;
                }
                return this;

            },

            xGetter: function (key) {
                if (this.element.nodeName === 'circle') {
                    key = { x: 'cx', y: 'cy' }[key] || key;
                }
                return this._defaultGetter(key);
            },

            /** 
             * Get the current value of an attribute or pseudo attribute, used mainly
             * for animation.
             */
            _defaultGetter: function (key) {
                var ret = pick(this[key], this.element ? this.element.getAttribute(key) : null, 0);

                if (/^[\-0-9\.]+$/.test(ret)) { // is numerical
                    ret = parseFloat(ret);
                }
                return ret;
            },


            dSetter: function (value, key, element) {
                if (value && value.join) { // join path
                    value = value.join(' ');
                }
                if (/(NaN| {2}|^$)/.test(value)) {
                    value = 'M 0 0';
                }
                element.setAttribute(key, value);

                this[key] = value;
            },
            dashstyleSetter: function (value) {
                var i;
                value = value && value.toLowerCase();
                if (value) {
                    value = value
                        .replace('shortdashdotdot', '3,1,1,1,1,1,')
                        .replace('shortdashdot', '3,1,1,1')
                        .replace('shortdot', '1,1,')
                        .replace('shortdash', '3,1,')
                        .replace('longdash', '8,3,')
                        .replace(/dot/g, '1,3,')
                        .replace('dash', '4,3,')
                        .replace(/,$/, '')
                        .split(','); // ending comma

                    i = value.length;
                    while (i--) {
                        value[i] = pInt(value[i]) * this['stroke-width'];
                    }
                    value = value.join(',')
                        .replace('NaN', 'none'); // #3226
                    this.element.setAttribute('stroke-dasharray', value);
                }
            },
            alignSetter: function (value) {
                this.element.setAttribute('text-anchor', { left: 'start', center: 'middle', right: 'end' }[value]);
            },
            opacitySetter: function (value, key, element) {
                this[key] = value;
                element.setAttribute(key, value);
            },
            titleSetter: function (value) {
                var titleNode = this.element.getElementsByTagName('title')[0];
                if (!titleNode) {
                    titleNode = doc.createElementNS(SVG_NS, 'title');
                    this.element.appendChild(titleNode);
                }
                titleNode.appendChild(
                    doc.createTextNode(
                        (String(pick(value), '')).replace(/<[^>]*>/g, '') // #3276, #3895
                    )
                );
            },
            textSetter: function (value) {
                if (value !== this.textStr) {
                    // Delete bBox memo when the text changes
                    delete this.bBox;

                    this.textStr = value;
                    if (this.added) {
                        this.renderer.buildText(this);
                    }
                }
            },
            fillSetter: function (value, key, element) {
                if (typeof value === 'string') {
                    element.setAttribute(key, value);
                } else if (value) {
                    this.colorGradient(value, key, element);
                }
            },
            zIndexSetter: function (value, key) {
                var renderer = this.renderer,
                    parentGroup = this.parentGroup,
                    parentWrapper = parentGroup || renderer,
                    parentNode = parentWrapper.element || renderer.box,
                    childNodes,
                    otherElement,
                    otherZIndex,
                    element = this.element,
                    inserted,
                    run = this.added,
                    i;

                if (defined(value)) {
                    element.setAttribute(key, value); // So we can read it for other elements in the group
                    value = +value;
                    if (this[key] === value) { // Only update when needed (#3865)
                        run = false;
                    }
                    this[key] = value;
                }

                // Insert according to this and other elements' zIndex. Before .add() is called,
                // nothing is done. Then on add, or by later calls to zIndexSetter, the node
                // is placed on the right place in the DOM.
                if (run) {
                    value = this.zIndex;

                    if (value && parentGroup) {
                        parentGroup.handleZ = true;
                    }

                    childNodes = parentNode.childNodes;
                    for (i = 0; i < childNodes.length && !inserted; i++) {
                        otherElement = childNodes[i];
                        otherZIndex = attr(otherElement, 'zIndex');
                        if (otherElement !== element && (
                            // Insert before the first element with a higher zIndex
                                pInt(otherZIndex) > value ||
                            // If no zIndex given, insert before the first element with a zIndex
                                (!defined(value) && defined(otherZIndex))

                                )) {
                            parentNode.insertBefore(element, otherElement);
                            inserted = true;
                        }
                    }
                    if (!inserted) {
                        parentNode.appendChild(element);
                    }
                }
                return inserted;
            },
            _defaultSetter: function (value, key, element) {
                element.setAttribute(key, value);
            }
        };

        // Some shared setters and getters
        SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
        SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter =
                SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter =
                SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = function (value, key) {
                    this[key] = value;
                    this.doTransform = true;
                };

        // WebKit and Batik have problems with a stroke-width of zero, so in this case we remove the 
        // stroke attribute altogether. #1270, #1369, #3065, #3072.
        SVGElement.prototype['stroke-widthSetter'] = SVGElement.prototype.strokeSetter = function (value, key, element) {
            this[key] = value;
            // Only apply the stroke attribute if the stroke width is defined and larger than 0
            if (this.stroke && this['stroke-width']) {
                this.strokeWidth = this['stroke-width'];
                SVGElement.prototype.fillSetter.call(this, this.stroke, 'stroke', element); // use prototype as instance may be overridden
                element.setAttribute('stroke-width', this['stroke-width']);
                this.hasStroke = true;
            } else if (key === 'stroke-width' && value === 0 && this.hasStroke) {
                element.removeAttribute('stroke');
                this.hasStroke = false;
            }
        };


        /**
         * The default SVG renderer
         */
        var SVGRenderer = function () {
            this.init.apply(this, arguments);
        };
        SVGRenderer.prototype = {
            Element: SVGElement,

            /**
             * Initialize the SVGRenderer
             * @param {Object} container
             * @param {Number} width
             * @param {Number} height
             * @param {Boolean} forExport
             */
            init: function (container, width, height, style, forExport) {
                var renderer = this,
                    loc = location,
                    boxWrapper,
                    element,
                    desc;

                boxWrapper = renderer.createElement('svg')
                    .attr({
                        version: '1.1'
                    })
                    .css(this.getStyle(style));
                element = boxWrapper.element;
                container.appendChild(element);

                // For browsers other than IE, add the namespace attribute (#1978)
                if (container.innerHTML.indexOf('xmlns') === -1) {
                    attr(element, 'xmlns', SVG_NS);
                }

                // object properties
                renderer.isSVG = true;
                renderer.box = element;
                renderer.boxWrapper = boxWrapper;
                renderer.alignedObjects = [];

                // Page url used for internal references. #24, #672, #1070
                renderer.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ?
                    loc.href
                        .replace(/#.*?$/, '') // remove the hash
                        .replace(/([\('\)])/g, '\\$1') // escape parantheses and quotes
                        .replace(/ /g, '%20') : // replace spaces (needed for Safari only)
                    '';

                // Add description
                desc = this.createElement('desc').add();
                desc.element.appendChild(doc.createTextNode('Created with ' + PRODUCT + ' ' + VERSION));


                renderer.defs = this.createElement('defs').add();
                renderer.forExport = forExport;
                renderer.gradients = {}; // Object where gradient SvgElements are stored
                renderer.cache = {}; // Cache for numerical bounding boxes

                renderer.setSize(width, height, false);



                // Issue 110 workaround:
                // In Firefox, if a div is positioned by percentage, its pixel position may land
                // between pixels. The container itself doesn't display this, but an SVG element
                // inside this container will be drawn at subpixel precision. In order to draw
                // sharp lines, this must be compensated for. This doesn't seem to work inside
                // iframes though (like in jsFiddle).
                var subPixelFix, rect;
                if (isFirefox && container.getBoundingClientRect) {
                    renderer.subPixelFix = subPixelFix = function () {
                        css(container, { left: 0, top: 0 });
                        rect = container.getBoundingClientRect();
                        css(container, {
                            left: (mathCeil(rect.left) - rect.left) + PX,
                            top: (mathCeil(rect.top) - rect.top) + PX
                        });
                    };

                    // run the fix now
                    subPixelFix();

                    // run it on resize
                    addEvent(win, 'resize', subPixelFix);
                }
            },

            getStyle: function (style) {
                return (this.style = extend({
                    fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif', // default font
                    fontSize: '12px'
                }, style));
            },

            /**
             * Detect whether the renderer is hidden. This happens when one of the parent elements
             * has display: none. #608.
             */
            isHidden: function () {
                return !this.boxWrapper.getBBox().width;
            },

            /**
             * Destroys the renderer and its allocated members.
             */
            destroy: function () {
                var renderer = this,
                    rendererDefs = renderer.defs;
                renderer.box = null;
                renderer.boxWrapper = renderer.boxWrapper.destroy();

                // Call destroy on all gradient elements
                destroyObjectProperties(renderer.gradients || {});
                renderer.gradients = null;

                // Defs are null in VMLRenderer
                // Otherwise, destroy them here.
                if (rendererDefs) {
                    renderer.defs = rendererDefs.destroy();
                }

                // Remove sub pixel fix handler
                // We need to check that there is a handler, otherwise all functions that are registered for event 'resize' are removed
                // See issue #982
                if (renderer.subPixelFix) {
                    removeEvent(win, 'resize', renderer.subPixelFix);
                }

                renderer.alignedObjects = null;

                return null;
            },

            /**
             * Create a wrapper for an SVG element
             * @param {Object} nodeName
             */
            createElement: function (nodeName) {
                var wrapper = new this.Element();
                wrapper.init(this, nodeName);
                return wrapper;
            },

            /**
             * Dummy function for use in canvas renderer
             */
            draw: function () { },

            /**
             * Parse a simple HTML string into SVG tspans
             *
             * @param {Object} textNode The parent text SVG node
             */
            buildText: function (wrapper) {
                var textNode = wrapper.element,
                    renderer = this,
                    forExport = renderer.forExport,
                    textStr = pick(wrapper.textStr, '').toString(),
                    hasMarkup = textStr.indexOf('<') !== -1,
                    lines,
                    childNodes = textNode.childNodes,
                    styleRegex,
                    hrefRegex,
                    parentX = attr(textNode, 'x'),
                    textStyles = wrapper.styles,
                    width = wrapper.textWidth,
                    textLineHeight = textStyles && textStyles.lineHeight,
                    textShadow = textStyles && textStyles.textShadow,
                    ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',
                    i = childNodes.length,
                    tempParent = width && !wrapper.added && this.box,
                    getLineHeight = function (tspan) {
                        return textLineHeight ?
                            pInt(textLineHeight) :
                            renderer.fontMetrics(
                                /(px|em)$/.test(tspan && tspan.style.fontSize) ?
                                    tspan.style.fontSize :
                                    ((textStyles && textStyles.fontSize) || renderer.style.fontSize || 12),
                                tspan
                            ).h;
                    },
                    unescapeAngleBrackets = function (inputStr) {
                        return inputStr.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                    };

                /// remove old text
                while (i--) {
                    textNode.removeChild(childNodes[i]);
                }

                // Skip tspans, add text directly to text node. The forceTSpan is a hook 
                // used in text outline hack.
                if (!hasMarkup && !textShadow && !ellipsis && textStr.indexOf(' ') === -1) {
                    textNode.appendChild(doc.createTextNode(unescapeAngleBrackets(textStr)));
                    return;

                    // Complex strings, add more logic
                } else {

                    styleRegex = /<.*style="([^"]+)".*>/;
                    hrefRegex = /<.*href="(http[^"]+)".*>/;

                    if (tempParent) {
                        tempParent.appendChild(textNode); // attach it to the DOM to read offset width
                    }

                    if (hasMarkup) {
                        lines = textStr
                            .replace(/<(b|strong)>/g, '<span style="font-weight:bold">')
                            .replace(/<(i|em)>/g, '<span style="font-style:italic">')
                            .replace(/<a/g, '<span')
                            .replace(/<\/(b|strong|i|em|a)>/g, '</span>')
                            .split(/<br.*?>/g);

                    } else {
                        lines = [textStr];
                    }


                    // remove empty line at end
                    if (lines[lines.length - 1] === '') {
                        lines.pop();
                    }


                    // build the lines
                    each(lines, function (line, lineNo) {
                        var spans, spanNo = 0;

                        line = line.replace(/<span/g, '|||<span').replace(/<\/span>/g, '</span>|||');
                        spans = line.split('|||');

                        each(spans, function (span) {
                            if (span !== '' || spans.length === 1) {
                                var attributes = {},
                                    tspan = doc.createElementNS(SVG_NS, 'tspan'),
                                    spanStyle; // #390
                                if (styleRegex.test(span)) {
                                    spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2');
                                    attr(tspan, 'style', spanStyle);
                                }
                                if (hrefRegex.test(span) && !forExport) { // Not for export - #1529
                                    attr(tspan, 'onclick', 'location.href=\"' + span.match(hrefRegex)[1] + '\"');
                                    css(tspan, { cursor: 'pointer' });
                                }

                                span = unescapeAngleBrackets(span.replace(/<(.|\n)*?>/g, '') || ' ');

                                // Nested tags aren't supported, and cause crash in Safari (#1596)
                                if (span !== ' ') {

                                    // add the text node
                                    tspan.appendChild(doc.createTextNode(span));

                                    if (!spanNo) { // first span in a line, align it to the left
                                        if (lineNo && parentX !== null) {
                                            attributes.x = parentX;
                                        }
                                    } else {
                                        attributes.dx = 0; // #16
                                    }

                                    // add attributes
                                    attr(tspan, attributes);

                                    // Append it
                                    textNode.appendChild(tspan);

                                    // first span on subsequent line, add the line height
                                    if (!spanNo && lineNo) {

                                        // allow getting the right offset height in exporting in IE
                                        if (!hasSVG && forExport) {
                                            css(tspan, { display: 'block' });
                                        }

                                        // Set the line height based on the font size of either
                                        // the text element or the tspan element
                                        attr(
                                            tspan,
                                            'dy',
                                            getLineHeight(tspan)
                                        );
                                    }

                                    /*if (width) {
                                        renderer.breakText(wrapper, width);
                                    }*/

                                    // Check width and apply soft breaks or ellipsis
                                    if (width) {
                                        var words = span.replace(/([^\^])-/g, '$1- ').split(' '), // #1273
                                            hasWhiteSpace = spans.length > 1 || lineNo || (words.length > 1 && textStyles.whiteSpace !== 'nowrap'),
                                            tooLong,
                                            wasTooLong,
                                            actualWidth,
                                            rest = [],
                                            dy = getLineHeight(tspan),
                                            softLineNo = 1,
                                            rotation = wrapper.rotation,
                                            wordStr = span, // for ellipsis
                                            cursor = wordStr.length, // binary search cursor
                                            bBox;

                                        while ((hasWhiteSpace || ellipsis) && (words.length || rest.length)) {
                                            wrapper.rotation = 0; // discard rotation when computing box
                                            bBox = wrapper.getBBox(true);
                                            actualWidth = bBox.width;

                                            // Old IE cannot measure the actualWidth for SVG elements (#2314)
                                            if (!hasSVG && renderer.forExport) {
                                                actualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);
                                            }

                                            tooLong = actualWidth > width;

                                            // For ellipsis, do a binary search for the correct string length
                                            if (wasTooLong === undefined) {
                                                wasTooLong = tooLong; // First time
                                            }
                                            if (ellipsis && wasTooLong) {
                                                cursor /= 2;

                                                if (wordStr === '' || (!tooLong && cursor < 0.5)) {
                                                    words = []; // All ok, break out
                                                } else {
                                                    if (tooLong) {
                                                        wasTooLong = true;
                                                    }
                                                    wordStr = span.substring(0, wordStr.length + (tooLong ? -1 : 1) * mathCeil(cursor));
                                                    words = [wordStr + (width > 3 ? '\u2026' : '')];
                                                    tspan.removeChild(tspan.firstChild);
                                                }

                                                // Looping down, this is the first word sequence that is not too long,
                                                // so we can move on to build the next line.
                                            } else if (!tooLong || words.length === 1) {
                                                words = rest;
                                                rest = [];

                                                if (words.length) {
                                                    softLineNo++;

                                                    tspan = doc.createElementNS(SVG_NS, 'tspan');
                                                    attr(tspan, {
                                                        dy: dy,
                                                        x: parentX
                                                    });
                                                    if (spanStyle) { // #390
                                                        attr(tspan, 'style', spanStyle);
                                                    }
                                                    textNode.appendChild(tspan);
                                                }
                                                if (actualWidth > width) { // a single word is pressing it out
                                                    width = actualWidth;
                                                }
                                            } else { // append to existing line tspan
                                                tspan.removeChild(tspan.firstChild);
                                                rest.unshift(words.pop());
                                            }
                                            if (words.length) {
                                                tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));
                                            }
                                        }
                                        if (wasTooLong) {
                                            wrapper.attr('title', wrapper.textStr);
                                        }
                                        wrapper.rotation = rotation;
                                    }

                                    spanNo++;
                                }
                            }
                        });
                    });
                    if (tempParent) {
                        tempParent.removeChild(textNode); // attach it to the DOM to read offset width
                    }

                    // Apply the text shadow
                    if (textShadow && wrapper.applyTextShadow) {
                        wrapper.applyTextShadow(textShadow);
                    }
                }
            },



            /*
            breakText: function (wrapper, width) {
                var bBox = wrapper.getBBox(),
                    node = wrapper.element,
                    textLength = node.textContent.length,
                    pos = mathRound(width * textLength / bBox.width), // try this position first, based on average character width
                    increment = 0,
                    finalPos;
        
                if (bBox.width > width) {
                    while (finalPos === undefined) {
                        textLength = node.getSubStringLength(0, pos);
        
                        if (textLength <= width) {
                            if (increment === -1) {
                                finalPos = pos;
                            } else {
                                increment = 1;
                            }
                        } else {
                            if (increment === 1) {
                                finalPos = pos - 1;
                            } else {
                                increment = -1;
                            }
                        }
                        pos += increment;
                    }
                }
                console.log(finalPos, node.getSubStringLength(0, finalPos))
            },
            */

            /** 
             * Returns white for dark colors and black for bright colors
             */
            getContrast: function (color) {
                color = Color(color).rgba;
                return color[0] + color[1] + color[2] > 384 ? '#000000' : '#FFFFFF';
            },

            /**
             * Create a button with preset states
             * @param {String} text
             * @param {Number} x
             * @param {Number} y
             * @param {Function} callback
             * @param {Object} normalState
             * @param {Object} hoverState
             * @param {Object} pressedState
             */
            button: function (text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {
                var label = this.label(text, x, y, shape, null, null, null, null, 'button'),
                    curState = 0,
                    stateOptions,
                    stateStyle,
                    normalStyle,
                    hoverStyle,
                    pressedStyle,
                    disabledStyle,
                    verticalGradient = { x1: 0, y1: 0, x2: 0, y2: 1 };

                // Normal state - prepare the attributes
                normalState = merge({
                    'stroke-width': 1,
                    stroke: '#CCCCCC',
                    fill: {
                        linearGradient: verticalGradient,
                        stops: [
                            [0, '#FEFEFE'],
                            [1, '#F6F6F6']
                        ]
                    },
                    r: 2,
                    padding: 5,
                    style: {
                        color: 'black'
                    }
                }, normalState);
                normalStyle = normalState.style;
                delete normalState.style;

                // Hover state
                hoverState = merge(normalState, {
                    stroke: '#68A',
                    fill: {
                        linearGradient: verticalGradient,
                        stops: [
                            [0, '#FFF'],
                            [1, '#ACF']
                        ]
                    }
                }, hoverState);
                hoverStyle = hoverState.style;
                delete hoverState.style;

                // Pressed state
                pressedState = merge(normalState, {
                    stroke: '#68A',
                    fill: {
                        linearGradient: verticalGradient,
                        stops: [
                            [0, '#9BD'],
                            [1, '#CDF']
                        ]
                    }
                }, pressedState);
                pressedStyle = pressedState.style;
                delete pressedState.style;

                // Disabled state
                disabledState = merge(normalState, {
                    style: {
                        color: '#CCC'
                    }
                }, disabledState);
                disabledStyle = disabledState.style;
                delete disabledState.style;

                // Add the events. IE9 and IE10 need mouseover and mouseout to funciton (#667).
                addEvent(label.element, isIE ? 'mouseover' : 'mouseenter', function () {
                    if (curState !== 3) {
                        label.attr(hoverState)
                            .css(hoverStyle);
                    }
                });
                addEvent(label.element, isIE ? 'mouseout' : 'mouseleave', function () {
                    if (curState !== 3) {
                        stateOptions = [normalState, hoverState, pressedState][curState];
                        stateStyle = [normalStyle, hoverStyle, pressedStyle][curState];
                        label.attr(stateOptions)
                            .css(stateStyle);
                    }
                });

                label.setState = function (state) {
                    label.state = curState = state;
                    if (!state) {
                        label.attr(normalState)
                            .css(normalStyle);
                    } else if (state === 2) {
                        label.attr(pressedState)
                            .css(pressedStyle);
                    } else if (state === 3) {
                        label.attr(disabledState)
                            .css(disabledStyle);
                    }
                };

                return label
                    .on('click', function () {
                        if (curState !== 3) {
                            callback.call(label);
                        }
                    })
                    .attr(normalState)
                    .css(extend({ cursor: 'default' }, normalStyle));
            },

            /**
             * Make a straight line crisper by not spilling out to neighbour pixels
             * @param {Array} points
             * @param {Number} width
             */
            crispLine: function (points, width) {
                // points format: [M, 0, 0, L, 100, 0]
                // normalize to a crisp line
                if (points[1] === points[4]) {
                    // Substract due to #1129. Now bottom and left axis gridlines behave the same.
                    points[1] = points[4] = mathRound(points[1]) - (width % 2 / 2);
                }
                if (points[2] === points[5]) {
                    points[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);
                }
                return points;
            },


            /**
             * Draw a path
             * @param {Array} path An SVG path in array form
             */
            path: function (path) {
                var attr = {
                    fill: NONE
                };
                if (isArray(path)) {
                    attr.d = path;
                } else if (isObject(path)) { // attributes
                    extend(attr, path);
                }
                return this.createElement('path').attr(attr);
            },

            /**
             * Draw and return an SVG circle
             * @param {Number} x The x position
             * @param {Number} y The y position
             * @param {Number} r The radius
             */
            circle: function (x, y, r) {
                var attr = isObject(x) ?
                    x :
			{
			    x: x,
			    y: y,
			    r: r
			},
                    wrapper = this.createElement('circle');

                wrapper.xSetter = function (value) {
                    this.element.setAttribute('cx', value);
                };
                wrapper.ySetter = function (value) {
                    this.element.setAttribute('cy', value);
                };
                return wrapper.attr(attr);
            },

            /**
             * Draw and return an arc
             * @param {Number} x X position
             * @param {Number} y Y position
             * @param {Number} r Radius
             * @param {Number} innerR Inner radius like used in donut charts
             * @param {Number} start Starting angle
             * @param {Number} end Ending angle
             */
            arc: function (x, y, r, innerR, start, end) {
                var arc;

                if (isObject(x)) {
                    y = x.y;
                    r = x.r;
                    innerR = x.innerR;
                    start = x.start;
                    end = x.end;
                    x = x.x;
                }

                // Arcs are defined as symbols for the ability to set
                // attributes in attr and animate
                arc = this.symbol('arc', x || 0, y || 0, r || 0, r || 0, {
                    innerR: innerR || 0,
                    start: start || 0,
                    end: end || 0
                });
                arc.r = r; // #959
                return arc;
            },

            /**
             * Draw and return a rectangle
             * @param {Number} x Left position
             * @param {Number} y Top position
             * @param {Number} width
             * @param {Number} height
             * @param {Number} r Border corner radius
             * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing
             */
            rect: function (x, y, width, height, r, strokeWidth) {

                r = isObject(x) ? x.r : r;

                var wrapper = this.createElement('rect'),
                    attribs = isObject(x) ? x : x === UNDEFINED ? {} : {
                        x: x,
                        y: y,
                        width: mathMax(width, 0),
                        height: mathMax(height, 0)
                    };

                if (strokeWidth !== UNDEFINED) {
                    attribs.strokeWidth = strokeWidth;
                    attribs = wrapper.crisp(attribs);
                }

                if (r) {
                    attribs.r = r;
                }

                wrapper.rSetter = function (value) {
                    attr(this.element, {
                        rx: value,
                        ry: value
                    });
                };

                return wrapper.attr(attribs);
            },

            /**
             * Resize the box and re-align all aligned elements
             * @param {Object} width
             * @param {Object} height
             * @param {Boolean} animate
             *
             */
            setSize: function (width, height, animate) {
                var renderer = this,
                    alignedObjects = renderer.alignedObjects,
                    i = alignedObjects.length;

                renderer.width = width;
                renderer.height = height;

                renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({
                    width: width,
                    height: height
                });

                while (i--) {
                    alignedObjects[i].align();
                }
            },

            /**
             * Create a group
             * @param {String} name The group will be given a class name of 'highcharts-{name}'.
             *	 This can be used for styling and scripting.
             */
            g: function (name) {
                var elem = this.createElement('g');
                return defined(name) ? elem.attr({ 'class': PREFIX + name }) : elem;
            },

            /**
             * Display an image
             * @param {String} src
             * @param {Number} x
             * @param {Number} y
             * @param {Number} width
             * @param {Number} height
             */
            image: function (src, x, y, width, height) {
                var attribs = {
                    preserveAspectRatio: NONE
                },
                    elemWrapper;

                // optional properties
                if (arguments.length > 1) {
                    extend(attribs, {
                        x: x,
                        y: y,
                        width: width,
                        height: height
                    });
                }

                elemWrapper = this.createElement('image').attr(attribs);

                // set the href in the xlink namespace
                if (elemWrapper.element.setAttributeNS) {
                    elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',
                        'href', src);
                } else {
                    // could be exporting in IE
                    // using href throws "not supported" in ie7 and under, requries regex shim to fix later
                    elemWrapper.element.setAttribute('hc-svg-href', src);
                }
                return elemWrapper;
            },

            /**
             * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.
             *
             * @param {Object} symbol
             * @param {Object} x
             * @param {Object} y
             * @param {Object} radius
             * @param {Object} options
             */
            symbol: function (symbol, x, y, width, height, options) {

                var obj,

                    // get the symbol definition function
                    symbolFn = this.symbols[symbol],

                    // check if there's a path defined for this symbol
                    path = symbolFn && symbolFn(
                        mathRound(x),
                        mathRound(y),
                        width,
                        height,
                        options
                    ),

                    imageElement,
                    imageRegex = /^url\((.*?)\)$/,
                    imageSrc,
                    imageSize,
                    centerImage;

                if (path) {

                    obj = this.path(path);
                    // expando properties for use in animate and attr
                    extend(obj, {
                        symbolName: symbol,
                        x: x,
                        y: y,
                        width: width,
                        height: height
                    });
                    if (options) {
                        extend(obj, options);
                    }


                    // image symbols
                } else if (imageRegex.test(symbol)) {

                    // On image load, set the size and position
                    centerImage = function (img, size) {
                        if (img.element) { // it may be destroyed in the meantime (#1390)
                            img.attr({
                                width: size[0],
                                height: size[1]
                            });

                            if (!img.alignByTranslate) { // #185
                                img.translate(
                                    mathRound((width - size[0]) / 2), // #1378
                                    mathRound((height - size[1]) / 2)
                                );
                            }
                        }
                    };

                    imageSrc = symbol.match(imageRegex)[1];
                    imageSize = symbolSizes[imageSrc] || (options && options.width && options.height && [options.width, options.height]);

                    // Ireate the image synchronously, add attribs async
                    obj = this.image(imageSrc)
                        .attr({
                            x: x,
                            y: y
                        });
                    obj.isImg = true;

                    if (imageSize) {
                        centerImage(obj, imageSize);
                    } else {
                        // Initialize image to be 0 size so export will still function if there's no cached sizes.
                        obj.attr({ width: 0, height: 0 });

                        // Create a dummy JavaScript image to get the width and height. Due to a bug in IE < 8,
                        // the created element must be assigned to a variable in order to load (#292).
                        imageElement = createElement('img', {
                            onload: function () {
                                centerImage(obj, symbolSizes[imageSrc] = [this.width, this.height]);
                            },
                            src: imageSrc
                        });
                    }
                }

                return obj;
            },

            /**
             * An extendable collection of functions for defining symbol paths.
             */
            symbols: {
                'circle': function (x, y, w, h) {
                    var cpw = 0.166 * w;
                    return [
                        M, x + w / 2, y,
                        'C', x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h,
                        'C', x - cpw, y + h, x - cpw, y, x + w / 2, y,
                        'Z'
                    ];
                },

                'square': function (x, y, w, h) {
                    return [
                        M, x, y,
                        L, x + w, y,
                        x + w, y + h,
                        x, y + h,
                        'Z'
                    ];
                },

                'triangle': function (x, y, w, h) {
                    return [
                        M, x + w / 2, y,
                        L, x + w, y + h,
                        x, y + h,
                        'Z'
                    ];
                },

                'triangle-down': function (x, y, w, h) {
                    return [
                        M, x, y,
                        L, x + w, y,
                        x + w / 2, y + h,
                        'Z'
                    ];
                },
                'diamond': function (x, y, w, h) {
                    return [
                        M, x + w / 2, y,
                        L, x + w, y + h / 2,
                        x + w / 2, y + h,
                        x, y + h / 2,
                        'Z'
                    ];
                },
                'arc': function (x, y, w, h, options) {
                    var start = options.start,
                        radius = options.r || w || h,
                        end = options.end - 0.001, // to prevent cos and sin of start and end from becoming equal on 360 arcs (related: #1561)
                        innerRadius = options.innerR,
                        open = options.open,
                        cosStart = mathCos(start),
                        sinStart = mathSin(start),
                        cosEnd = mathCos(end),
                        sinEnd = mathSin(end),
                        longArc = options.end - start < mathPI ? 0 : 1;

                    return [
                        M,
                        x + radius * cosStart,
                        y + radius * sinStart,
                        'A', // arcTo
                        radius, // x radius
                        radius, // y radius
                        0, // slanting
                        longArc, // long or short arc
                        1, // clockwise
                        x + radius * cosEnd,
                        y + radius * sinEnd,
                        open ? M : L,
                        x + innerRadius * cosEnd,
                        y + innerRadius * sinEnd,
                        'A', // arcTo
                        innerRadius, // x radius
                        innerRadius, // y radius
                        0, // slanting
                        longArc, // long or short arc
                        0, // clockwise
                        x + innerRadius * cosStart,
                        y + innerRadius * sinStart,

                        open ? '' : 'Z' // close
                    ];
                },

                /**
                 * Callout shape used for default tooltips, also used for rounded rectangles in VML
                 */
                callout: function (x, y, w, h, options) {
                    var arrowLength = 6,
                        halfDistance = 6,
                        r = mathMin((options && options.r) || 0, w, h),
                        safeDistance = r + halfDistance,
                        anchorX = options && options.anchorX,
                        anchorY = options && options.anchorY,
                        path;

                    path = [
                        'M', x + r, y,
                        'L', x + w - r, y, // top side
                        'C', x + w, y, x + w, y, x + w, y + r, // top-right corner
                        'L', x + w, y + h - r, // right side
                        'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-right corner
                        'L', x + r, y + h, // bottom side
                        'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner
                        'L', x, y + r, // left side
                        'C', x, y, x, y, x + r, y // top-right corner
                    ];

                    if (anchorX && anchorX > w && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace right side
                        path.splice(13, 3,
                            'L', x + w, anchorY - halfDistance,
                            x + w + arrowLength, anchorY,
                            x + w, anchorY + halfDistance,
                            x + w, y + h - r
                        );
                    } else if (anchorX && anchorX < 0 && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace left side
                        path.splice(33, 3,
                            'L', x, anchorY + halfDistance,
                            x - arrowLength, anchorY,
                            x, anchorY - halfDistance,
                            x, y + r
                        );
                    } else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace bottom
                        path.splice(23, 3,
                            'L', anchorX + halfDistance, y + h,
                            anchorX, y + h + arrowLength,
                            anchorX - halfDistance, y + h,
                            x + r, y + h
                        );
                    } else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace top
                        path.splice(3, 3,
                            'L', anchorX - halfDistance, y,
                            anchorX, y - arrowLength,
                            anchorX + halfDistance, y,
                            w - r, y
                        );
                    }
                    return path;
                }
            },

            /**
             * Define a clipping rectangle
             * @param {String} id
             * @param {Number} x
             * @param {Number} y
             * @param {Number} width
             * @param {Number} height
             */
            clipRect: function (x, y, width, height) {
                var wrapper,
                    id = PREFIX + idCounter++,

                    clipPath = this.createElement('clipPath').attr({
                        id: id
                    }).add(this.defs);

                wrapper = this.rect(x, y, width, height, 0).add(clipPath);
                wrapper.id = id;
                wrapper.clipPath = clipPath;
                wrapper.count = 0;

                return wrapper;
            },





            /**
             * Add text to the SVG object
             * @param {String} str
             * @param {Number} x Left position
             * @param {Number} y Top position
             * @param {Boolean} useHTML Use HTML to render the text
             */
            text: function (str, x, y, useHTML) {

                // declare variables
                var renderer = this,
                    fakeSVG = useCanVG || (!hasSVG && renderer.forExport),
                    wrapper,
                    attr = {};

                if (useHTML && !renderer.forExport) {
                    return renderer.html(str, x, y);
                }

                attr.x = Math.round(x || 0); // X is always needed for line-wrap logic
                if (y) {
                    attr.y = Math.round(y);
                }
                if (str || str === 0) {
                    attr.text = str;
                }

                wrapper = renderer.createElement('text')
                    .attr(attr);

                // Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)
                if (fakeSVG) {
                    wrapper.css({
                        position: ABSOLUTE
                    });
                }

                if (!useHTML) {
                    wrapper.xSetter = function (value, key, element) {
                        var tspans = element.getElementsByTagName('tspan'),
                            tspan,
                            parentVal = element.getAttribute(key),
                            i;
                        for (i = 0; i < tspans.length; i++) {
                            tspan = tspans[i];
                            // If the x values are equal, the tspan represents a linebreak
                            if (tspan.getAttribute(key) === parentVal) {
                                tspan.setAttribute(key, value);
                            }
                        }
                        element.setAttribute(key, value);
                    };
                }

                return wrapper;
            },

            /**
             * Utility to return the baseline offset and total line height from the font size
             */
            fontMetrics: function (fontSize, elem) {
                var lineHeight,
                    baseline,
                    style;

                fontSize = fontSize || this.style.fontSize;
                if (elem && win.getComputedStyle) {
                    elem = elem.element || elem; // SVGElement
                    style = win.getComputedStyle(elem, "");
                    fontSize = style && style.fontSize; // #4309, the style doesn't exist inside a hidden iframe in Firefox
                }
                fontSize = /px/.test(fontSize) ? pInt(fontSize) : /em/.test(fontSize) ? parseFloat(fontSize) * 12 : 12;

                // Empirical values found by comparing font size and bounding box height.
                // Applies to the default font family. http://jsfiddle.net/highcharts/7xvn7/
                lineHeight = fontSize < 24 ? fontSize + 3 : mathRound(fontSize * 1.2);
                baseline = mathRound(lineHeight * 0.8);

                return {
                    h: lineHeight,
                    b: baseline,
                    f: fontSize
                };
            },

            /**
             * Correct X and Y positioning of a label for rotation (#1764)
             */
            rotCorr: function (baseline, rotation, alterY) {
                var y = baseline;
                if (rotation && alterY) {
                    y = mathMax(y * mathCos(rotation * deg2rad), 4);
                }
                return {
                    x: (-baseline / 3) * mathSin(rotation * deg2rad),
                    y: y
                };
            },

            /**
             * Add a label, a text item that can hold a colored or gradient background
             * as well as a border and shadow.
             * @param {string} str
             * @param {Number} x
             * @param {Number} y
             * @param {String} shape
             * @param {Number} anchorX In case the shape has a pointer, like a flag, this is the
             *	coordinates it should be pinned to
             * @param {Number} anchorY
             * @param {Boolean} baseline Whether to position the label relative to the text baseline,
             *	like renderer.text, or to the upper border of the rectangle.
             * @param {String} className Class name for the group
             */
            label: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {

                var renderer = this,
                    wrapper = renderer.g(className),
                    text = renderer.text('', 0, 0, useHTML)
                        .attr({
                            zIndex: 1
                        }),
                        //.add(wrapper),
                    box,
                    bBox,
                    alignFactor = 0,
                    padding = 3,
                    paddingLeft = 0,
                    width,
                    height,
                    wrapperX,
                    wrapperY,
                    crispAdjust = 0,
                    deferredAttr = {},
                    baselineOffset,
                    needsBox;

                /**
                 * This function runs after the label is added to the DOM (when the bounding box is
                 * available), and after the text of the label is updated to detect the new bounding
                 * box and reflect it in the border box.
                 */
                function updateBoxSize() {
                    var boxX,
                        boxY,
                        style = text.element.style;

                    bBox = (width === undefined || height === undefined || wrapper.styles.textAlign) && defined(text.textStr) &&
                        text.getBBox(); //#3295 && 3514 box failure when string equals 0
                    wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;
                    wrapper.height = (height || bBox.height || 0) + 2 * padding;

                    // update the label-scoped y offset
                    baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;


                    if (needsBox) {

                        // create the border box if it is not already present
                        if (!box) {
                            boxX = mathRound(-alignFactor * padding) + crispAdjust;
                            boxY = (baseline ? -baselineOffset : 0) + crispAdjust;

                            wrapper.box = box = shape ?
                                renderer.symbol(shape, boxX, boxY, wrapper.width, wrapper.height, deferredAttr) :
                                renderer.rect(boxX, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);
                            box.attr('fill', NONE).add(wrapper);
                        }

                        // apply the box attributes
                        if (!box.isImg) { // #1630
                            box.attr(extend({
                                width: mathRound(wrapper.width),
                                height: mathRound(wrapper.height)
                            }, deferredAttr));
                        }
                        deferredAttr = null;
                    }
                }

                /**
                 * This function runs after setting text or padding, but only if padding is changed
                 */
                function updateTextPadding() {
                    var styles = wrapper.styles,
                        textAlign = styles && styles.textAlign,
                        x = paddingLeft + padding * (1 - alignFactor),
                        y;

                    // determin y based on the baseline
                    y = baseline ? 0 : baselineOffset;

                    // compensate for alignment
                    if (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {
                        x += { center: 0.5, right: 1 }[textAlign] * (width - bBox.width);
                    }

                    // update if anything changed
                    if (x !== text.x || y !== text.y) {
                        text.attr('x', x);
                        if (y !== UNDEFINED) {
                            text.attr('y', y);
                        }
                    }

                    // record current values
                    text.x = x;
                    text.y = y;
                }

                /**
                 * Set a box attribute, or defer it if the box is not yet created
                 * @param {Object} key
                 * @param {Object} value
                 */
                function boxAttr(key, value) {
                    if (box) {
                        box.attr(key, value);
                    } else {
                        deferredAttr[key] = value;
                    }
                }

                /**
                 * After the text element is added, get the desired size of the border box
                 * and add it before the text in the DOM.
                 */
                wrapper.onAdd = function () {
                    text.add(wrapper);
                    wrapper.attr({
                        text: (str || str === 0) ? str : '', // alignment is available now // #3295: 0 not rendered if given as a value
                        x: x,
                        y: y
                    });

                    if (box && defined(anchorX)) {
                        wrapper.attr({
                            anchorX: anchorX,
                            anchorY: anchorY
                        });
                    }
                };

                /*
                 * Add specific attribute setters.
                 */

                // only change local variables
                wrapper.widthSetter = function (value) {
                    width = value;
                };
                wrapper.heightSetter = function (value) {
                    height = value;
                };
                wrapper.paddingSetter = function (value) {
                    if (defined(value) && value !== padding) {
                        padding = wrapper.padding = value;
                        updateTextPadding();
                    }
                };
                wrapper.paddingLeftSetter = function (value) {
                    if (defined(value) && value !== paddingLeft) {
                        paddingLeft = value;
                        updateTextPadding();
                    }
                };


                // change local variable and prevent setting attribute on the group
                wrapper.alignSetter = function (value) {
                    alignFactor = { left: 0, center: 0.5, right: 1 }[value];
                };

                // apply these to the box and the text alike
                wrapper.textSetter = function (value) {
                    if (value !== UNDEFINED) {
                        text.textSetter(value);
                    }
                    updateBoxSize();
                    updateTextPadding();
                };

                // apply these to the box but not to the text
                wrapper['stroke-widthSetter'] = function (value, key) {
                    if (value) {
                        needsBox = true;
                    }
                    crispAdjust = value % 2 / 2;
                    boxAttr(key, value);
                };
                wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function (value, key) {
                    if (key === 'fill' && value) {
                        needsBox = true;
                    }
                    boxAttr(key, value);
                };
                wrapper.anchorXSetter = function (value, key) {
                    anchorX = value;
                    boxAttr(key, mathRound(value) - crispAdjust - wrapperX);
                };
                wrapper.anchorYSetter = function (value, key) {
                    anchorY = value;
                    boxAttr(key, value - wrapperY);
                };

                // rename attributes
                wrapper.xSetter = function (value) {
                    wrapper.x = value; // for animation getter
                    if (alignFactor) {
                        value -= alignFactor * ((width || bBox.width) + padding);
                    }
                    wrapperX = mathRound(value);
                    wrapper.attr('translateX', wrapperX);
                };
                wrapper.ySetter = function (value) {
                    wrapperY = wrapper.y = mathRound(value);
                    wrapper.attr('translateY', wrapperY);
                };

                // Redirect certain methods to either the box or the text
                var baseCss = wrapper.css;
                return extend(wrapper, {
                    /**
                     * Pick up some properties and apply them to the text instead of the wrapper
                     */
                    css: function (styles) {
                        if (styles) {
                            var textStyles = {};
                            styles = merge(styles); // create a copy to avoid altering the original object (#537)
                            each(wrapper.textProps, function (prop) {
                                if (styles[prop] !== UNDEFINED) {
                                    textStyles[prop] = styles[prop];
                                    delete styles[prop];
                                }
                            });
                            text.css(textStyles);
                        }
                        return baseCss.call(wrapper, styles);
                    },
                    /**
                     * Return the bounding box of the box, not the group
                     */
                    getBBox: function () {
                        return {
                            width: bBox.width + 2 * padding,
                            height: bBox.height + 2 * padding,
                            x: bBox.x - padding,
                            y: bBox.y - padding
                        };
                    },
                    /**
                     * Apply the shadow to the box
                     */
                    shadow: function (b) {
                        if (box) {
                            box.shadow(b);
                        }
                        return wrapper;
                    },
                    /**
                     * Destroy and release memory.
                     */
                    destroy: function () {

                        // Added by button implementation
                        removeEvent(wrapper.element, 'mouseenter');
                        removeEvent(wrapper.element, 'mouseleave');

                        if (text) {
                            text = text.destroy();
                        }
                        if (box) {
                            box = box.destroy();
                        }
                        // Call base implementation to destroy the rest
                        SVGElement.prototype.destroy.call(wrapper);

                        // Release local pointers (#1298)
                        wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;
                    }
                });
            }
        }; // end SVGRenderer


        // general renderer
        Renderer = SVGRenderer;
        // extend SvgElement for useHTML option
        extend(SVGElement.prototype, {
            /**
             * Apply CSS to HTML elements. This is used in text within SVG rendering and
             * by the VML renderer
             */
            htmlCss: function (styles) {
                var wrapper = this,
                    element = wrapper.element,
                    textWidth = styles && element.tagName === 'SPAN' && styles.width;

                if (textWidth) {
                    delete styles.width;
                    wrapper.textWidth = textWidth;
                    wrapper.updateTransform();
                }
                if (styles && styles.textOverflow === 'ellipsis') {
                    styles.whiteSpace = 'nowrap';
                    styles.overflow = 'hidden';
                }
                wrapper.styles = extend(wrapper.styles, styles);
                css(wrapper.element, styles);

                return wrapper;
            },

            /**
             * VML and useHTML method for calculating the bounding box based on offsets
             * @param {Boolean} refresh Whether to force a fresh value from the DOM or to
             * use the cached value
             *
             * @return {Object} A hash containing values for x, y, width and height
             */

            htmlGetBBox: function () {
                var wrapper = this,
                    element = wrapper.element;

                // faking getBBox in exported SVG in legacy IE
                // faking getBBox in exported SVG in legacy IE (is this a duplicate of the fix for #1079?)
                if (element.nodeName === 'text') {
                    element.style.position = ABSOLUTE;
                }

                return {
                    x: element.offsetLeft,
                    y: element.offsetTop,
                    width: element.offsetWidth,
                    height: element.offsetHeight
                };
            },

            /**
             * VML override private method to update elements based on internal
             * properties based on SVG transform
             */
            htmlUpdateTransform: function () {
                // aligning non added elements is expensive
                if (!this.added) {
                    this.alignOnAdd = true;
                    return;
                }

                var wrapper = this,
                    renderer = wrapper.renderer,
                    elem = wrapper.element,
                    translateX = wrapper.translateX || 0,
                    translateY = wrapper.translateY || 0,
                    x = wrapper.x || 0,
                    y = wrapper.y || 0,
                    align = wrapper.textAlign || 'left',
                    alignCorrection = { left: 0, center: 0.5, right: 1 }[align],
                    shadows = wrapper.shadows,
                    styles = wrapper.styles;

                // apply translate
                css(elem, {
                    marginLeft: translateX,
                    marginTop: translateY
                });
                if (shadows) { // used in labels/tooltip
                    each(shadows, function (shadow) {
                        css(shadow, {
                            marginLeft: translateX + 1,
                            marginTop: translateY + 1
                        });
                    });
                }

                // apply inversion
                if (wrapper.inverted) { // wrapper is a group
                    each(elem.childNodes, function (child) {
                        renderer.invertChild(child, elem);
                    });
                }

                if (elem.tagName === 'SPAN') {

                    var width,
                        rotation = wrapper.rotation,
                        baseline,
                        textWidth = pInt(wrapper.textWidth),
                        currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth].join(',');

                    if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed


                        baseline = renderer.fontMetrics(elem.style.fontSize).b;

                        // Renderer specific handling of span rotation
                        if (defined(rotation)) {
                            wrapper.setSpanRotation(rotation, alignCorrection, baseline);
                        }

                        width = pick(wrapper.elemWidth, elem.offsetWidth);

                        // Update textWidth
                        if (width > textWidth && /[ \-]/.test(elem.textContent || elem.innerText)) { // #983, #1254
                            css(elem, {
                                width: textWidth + PX,
                                display: 'block',
                                whiteSpace: (styles && styles.whiteSpace) || 'normal' // #3331
                            });
                            width = textWidth;
                        }

                        wrapper.getSpanCorrection(width, baseline, alignCorrection, rotation, align);
                    }

                    // apply position with correction
                    css(elem, {
                        left: (x + (wrapper.xCorr || 0)) + PX,
                        top: (y + (wrapper.yCorr || 0)) + PX
                    });

                    // force reflow in webkit to apply the left and top on useHTML element (#1249)
                    if (isWebKit) {
                        baseline = elem.offsetHeight; // assigned to baseline for JSLint purpose
                    }

                    // record current text transform
                    wrapper.cTT = currentTextTransform;
                }
            },

            /**
             * Set the rotation of an individual HTML span
             */
            setSpanRotation: function (rotation, alignCorrection, baseline) {
                var rotationStyle = {},
                    cssTransformKey = isIE ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : isOpera ? '-o-transform' : '';

                rotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';
                rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] = rotationStyle.transformOrigin = (alignCorrection * 100) + '% ' + baseline + 'px';
                css(this.element, rotationStyle);
            },

            /**
             * Get the correction in X and Y positioning as the element is rotated.
             */
            getSpanCorrection: function (width, baseline, alignCorrection) {
                this.xCorr = -width * alignCorrection;
                this.yCorr = -baseline;
            }
        });

        // Extend SvgRenderer for useHTML option.
        extend(SVGRenderer.prototype, {
            /**
             * Create HTML text node. This is used by the VML renderer as well as the SVG
             * renderer through the useHTML option.
             *
             * @param {String} str
             * @param {Number} x
             * @param {Number} y
             */
            html: function (str, x, y) {
                var wrapper = this.createElement('span'),
                    element = wrapper.element,
                    renderer = wrapper.renderer;

                // Text setter
                wrapper.textSetter = function (value) {
                    if (value !== element.innerHTML) {
                        delete this.bBox;
                    }
                    element.innerHTML = this.textStr = value;
                };

                // Various setters which rely on update transform
                wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function (value, key) {
                    if (key === 'align') {
                        key = 'textAlign'; // Do not overwrite the SVGElement.align method. Same as VML.
                    }
                    wrapper[key] = value;
                    wrapper.htmlUpdateTransform();
                };

                // Set the default attributes
                wrapper.attr({
                    text: str,
                    x: mathRound(x),
                    y: mathRound(y)
                })
                    .css({
                        position: ABSOLUTE,
                        fontFamily: this.style.fontFamily,
                        fontSize: this.style.fontSize
                    });

                // Keep the whiteSpace style outside the wrapper.styles collection
                element.style.whiteSpace = 'nowrap';

                // Use the HTML specific .css method
                wrapper.css = wrapper.htmlCss;

                // This is specific for HTML within SVG
                if (renderer.isSVG) {
                    wrapper.add = function (svgGroupWrapper) {

                        var htmlGroup,
                            container = renderer.box.parentNode,
                            parentGroup,
                            parents = [];

                        this.parentGroup = svgGroupWrapper;

                        // Create a mock group to hold the HTML elements
                        if (svgGroupWrapper) {
                            htmlGroup = svgGroupWrapper.div;
                            if (!htmlGroup) {

                                // Read the parent chain into an array and read from top down
                                parentGroup = svgGroupWrapper;
                                while (parentGroup) {

                                    parents.push(parentGroup);

                                    // Move up to the next parent group
                                    parentGroup = parentGroup.parentGroup;
                                }

                                // Ensure dynamically updating position when any parent is translated
                                each(parents.reverse(), function (parentGroup) {
                                    var htmlGroupStyle,
                                        cls = attr(parentGroup.element, 'class');

                                    if (cls) {
                                        cls = { className: cls };
                                    } // else null

                                    // Create a HTML div and append it to the parent div to emulate
                                    // the SVG group structure
                                    htmlGroup = parentGroup.div = parentGroup.div || createElement(DIV, cls, {
                                        position: ABSOLUTE,
                                        left: (parentGroup.translateX || 0) + PX,
                                        top: (parentGroup.translateY || 0) + PX
                                    }, htmlGroup || container); // the top group is appended to container

                                    // Shortcut
                                    htmlGroupStyle = htmlGroup.style;

                                    // Set listeners to update the HTML div's position whenever the SVG group
                                    // position is changed
                                    extend(parentGroup, {
                                        translateXSetter: function (value, key) {
                                            htmlGroupStyle.left = value + PX;
                                            parentGroup[key] = value;
                                            parentGroup.doTransform = true;
                                        },
                                        translateYSetter: function (value, key) {
                                            htmlGroupStyle.top = value + PX;
                                            parentGroup[key] = value;
                                            parentGroup.doTransform = true;
                                        },
                                        visibilitySetter: function (value, key) {
                                            htmlGroupStyle[key] = value;
                                        }
                                    });
                                });

                            }
                        } else {
                            htmlGroup = container;
                        }

                        htmlGroup.appendChild(element);

                        // Shared with VML:
                        wrapper.added = true;
                        if (wrapper.alignOnAdd) {
                            wrapper.htmlUpdateTransform();
                        }

                        return wrapper;
                    };
                }
                return wrapper;
            }
        });

        /* ****************************************************************************
         *                                                                            *
         * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *
         *                                                                            *
         * For applications and websites that don't need IE support, like platform    *
         * targeted mobile apps and web apps, this code can be removed.               *
         *                                                                            *
         *****************************************************************************/

        /**
         * @constructor
         */
        var VMLRenderer, VMLElement;
        if (!hasSVG && !useCanVG) {

            /**
             * The VML element wrapper.
             */
            VMLElement = {

                /**
                 * Initialize a new VML element wrapper. It builds the markup as a string
                 * to minimize DOM traffic.
                 * @param {Object} renderer
                 * @param {Object} nodeName
                 */
                init: function (renderer, nodeName) {
                    var wrapper = this,
                        markup = ['<', nodeName, ' filled="f" stroked="f"'],
                        style = ['position: ', ABSOLUTE, ';'],
                        isDiv = nodeName === DIV;

                    // divs and shapes need size
                    if (nodeName === 'shape' || isDiv) {
                        style.push('left:0;top:0;width:1px;height:1px;');
                    }
                    style.push('visibility: ', isDiv ? HIDDEN : VISIBLE);

                    markup.push(' style="', style.join(''), '"/>');

                    // create element with default attributes and style
                    if (nodeName) {
                        markup = isDiv || nodeName === 'span' || nodeName === 'img' ?
                            markup.join('')
                            : renderer.prepVML(markup);
                        wrapper.element = createElement(markup);
                    }

                    wrapper.renderer = renderer;
                },

                /**
                 * Add the node to the given parent
                 * @param {Object} parent
                 */
                add: function (parent) {
                    var wrapper = this,
                        renderer = wrapper.renderer,
                        element = wrapper.element,
                        box = renderer.box,
                        inverted = parent && parent.inverted,

                        // get the parent node
                        parentNode = parent ?
                            parent.element || parent :
                            box;


                    // if the parent group is inverted, apply inversion on all children
                    if (inverted) { // only on groups
                        renderer.invertChild(element, parentNode);
                    }

                    // append it
                    parentNode.appendChild(element);

                    // align text after adding to be able to read offset
                    wrapper.added = true;
                    if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {
                        wrapper.updateTransform();
                    }

                    // fire an event for internal hooks
                    if (wrapper.onAdd) {
                        wrapper.onAdd();
                    }

                    return wrapper;
                },

                /**
                 * VML always uses htmlUpdateTransform
                 */
                updateTransform: SVGElement.prototype.htmlUpdateTransform,

                /**
                 * Set the rotation of a span with oldIE's filter
                 */
                setSpanRotation: function () {
                    // Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented
                    // but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+
                    // has support for CSS3 transform. The getBBox method also needs to be updated
                    // to compensate for the rotation, like it currently does for SVG.
                    // Test case: http://jsfiddle.net/highcharts/Ybt44/

                    var rotation = this.rotation,
                        costheta = mathCos(rotation * deg2rad),
                        sintheta = mathSin(rotation * deg2rad);

                    css(this.element, {
                        filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
                            ', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
                            ', sizingMethod=\'auto expand\')'].join('') : NONE
                    });
                },

                /**
                 * Get the positioning correction for the span after rotating. 
                 */
                getSpanCorrection: function (width, baseline, alignCorrection, rotation, align) {

                    var costheta = rotation ? mathCos(rotation * deg2rad) : 1,
                        sintheta = rotation ? mathSin(rotation * deg2rad) : 0,
                        height = pick(this.elemHeight, this.element.offsetHeight),
                        quad,
                        nonLeft = align && align !== 'left';

                    // correct x and y
                    this.xCorr = costheta < 0 && -width;
                    this.yCorr = sintheta < 0 && -height;

                    // correct for baseline and corners spilling out after rotation
                    quad = costheta * sintheta < 0;
                    this.xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);
                    this.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);
                    // correct for the length/height of the text
                    if (nonLeft) {
                        this.xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);
                        if (rotation) {
                            this.yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);
                        }
                        css(this.element, {
                            textAlign: align
                        });
                    }
                },

                /**
                 * Converts a subset of an SVG path definition to its VML counterpart. Takes an array
                 * as the parameter and returns a string.
                 */
                pathToVML: function (value) {
                    // convert paths
                    var i = value.length,
                        path = [];

                    while (i--) {

                        // Multiply by 10 to allow subpixel precision.
                        // Substracting half a pixel seems to make the coordinates
                        // align with SVG, but this hasn't been tested thoroughly
                        if (isNumber(value[i])) {
                            path[i] = mathRound(value[i] * 10) - 5;
                        } else if (value[i] === 'Z') { // close the path
                            path[i] = 'x';
                        } else {
                            path[i] = value[i];

                            // When the start X and end X coordinates of an arc are too close,
                            // they are rounded to the same value above. In this case, substract or 
                            // add 1 from the end X and Y positions. #186, #760, #1371, #1410.
                            if (value.isArc && (value[i] === 'wa' || value[i] === 'at')) {
                                // Start and end X
                                if (path[i + 5] === path[i + 7]) {
                                    path[i + 7] += value[i + 7] > value[i + 5] ? 1 : -1;
                                }
                                // Start and end Y
                                if (path[i + 6] === path[i + 8]) {
                                    path[i + 8] += value[i + 8] > value[i + 6] ? 1 : -1;
                                }
                            }
                        }
                    }


                    // Loop up again to handle path shortcuts (#2132)
                    /*while (i++ < path.length) {
                        if (path[i] === 'H') { // horizontal line to
                            path[i] = 'L';
                            path.splice(i + 2, 0, path[i - 1]);
                        } else if (path[i] === 'V') { // vertical line to
                            path[i] = 'L';
                            path.splice(i + 1, 0, path[i - 2]);
                        }
                    }*/
                    return path.join(' ') || 'x';
                },

                /**
                 * Set the element's clipping to a predefined rectangle
                 *
                 * @param {String} id The id of the clip rectangle
                 */
                clip: function (clipRect) {
                    var wrapper = this,
                        clipMembers,
                        cssRet;

                    if (clipRect) {
                        clipMembers = clipRect.members;
                        erase(clipMembers, wrapper); // Ensure unique list of elements (#1258)
                        clipMembers.push(wrapper);
                        wrapper.destroyClip = function () {
                            erase(clipMembers, wrapper);
                        };
                        cssRet = clipRect.getCSS(wrapper);

                    } else {
                        if (wrapper.destroyClip) {
                            wrapper.destroyClip();
                        }
                        cssRet = { clip: docMode8 ? 'inherit' : 'rect(auto)' }; // #1214
                    }

                    return wrapper.css(cssRet);

                },

                /**
                 * Set styles for the element
                 * @param {Object} styles
                 */
                css: SVGElement.prototype.htmlCss,

                /**
                 * Removes a child either by removeChild or move to garbageBin.
                 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
                 */
                safeRemoveChild: function (element) {
                    // discardElement will detach the node from its parent before attaching it
                    // to the garbage bin. Therefore it is important that the node is attached and have parent.
                    if (element.parentNode) {
                        discardElement(element);
                    }
                },

                /**
                 * Extend element.destroy by removing it from the clip members array
                 */
                destroy: function () {
                    if (this.destroyClip) {
                        this.destroyClip();
                    }

                    return SVGElement.prototype.destroy.apply(this);
                },

                /**
                 * Add an event listener. VML override for normalizing event parameters.
                 * @param {String} eventType
                 * @param {Function} handler
                 */
                on: function (eventType, handler) {
                    // simplest possible event model for internal use
                    this.element['on' + eventType] = function () {
                        var evt = win.event;
                        evt.target = evt.srcElement;
                        handler(evt);
                    };
                    return this;
                },

                /**
                 * In stacked columns, cut off the shadows so that they don't overlap
                 */
                cutOffPath: function (path, length) {

                    var len;

                    path = path.split(/[ ,]/);
                    len = path.length;

                    if (len === 9 || len === 11) {
                        path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;
                    }
                    return path.join(' ');
                },

                /**
                 * Apply a drop shadow by copying elements and giving them different strokes
                 * @param {Boolean|Object} shadowOptions
                 */
                shadow: function (shadowOptions, group, cutOff) {
                    var shadows = [],
                        i,
                        element = this.element,
                        renderer = this.renderer,
                        shadow,
                        elemStyle = element.style,
                        markup,
                        path = element.path,
                        strokeWidth,
                        modifiedPath,
                        shadowWidth,
                        shadowElementOpacity;

                    // some times empty paths are not strings
                    if (path && typeof path.value !== 'string') {
                        path = 'x';
                    }
                    modifiedPath = path;

                    if (shadowOptions) {
                        shadowWidth = pick(shadowOptions.width, 3);
                        shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
                        for (i = 1; i <= 3; i++) {

                            strokeWidth = (shadowWidth * 2) + 1 - (2 * i);

                            // Cut off shadows for stacked column items
                            if (cutOff) {
                                modifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);
                            }

                            markup = ['<shape isShadow="true" strokeweight="', strokeWidth,
                                '" filled="false" path="', modifiedPath,
                                '" coordsize="10 10" style="', element.style.cssText, '" />'];

                            shadow = createElement(renderer.prepVML(markup),
                                null, {
                                    left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),
                                    top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)
                                }
                            );
                            if (cutOff) {
                                shadow.cutOff = strokeWidth + 1;
                            }

                            // apply the opacity
                            markup = ['<stroke color="', shadowOptions.color || 'black', '" opacity="', shadowElementOpacity * i, '"/>'];
                            createElement(renderer.prepVML(markup), null, null, shadow);


                            // insert it
                            if (group) {
                                group.element.appendChild(shadow);
                            } else {
                                element.parentNode.insertBefore(shadow, element);
                            }

                            // record it
                            shadows.push(shadow);

                        }

                        this.shadows = shadows;
                    }
                    return this;
                },
                updateShadows: noop, // Used in SVG only

                setAttr: function (key, value) {
                    if (docMode8) { // IE8 setAttribute bug
                        this.element[key] = value;
                    } else {
                        this.element.setAttribute(key, value);
                    }
                },
                classSetter: function (value) {
                    // IE8 Standards mode has problems retrieving the className unless set like this
                    this.element.className = value;
                },
                dashstyleSetter: function (value, key, element) {
                    var strokeElem = element.getElementsByTagName('stroke')[0] ||
                        createElement(this.renderer.prepVML(['<stroke/>']), null, null, element);
                    strokeElem[key] = value || 'solid';
                    this[key] = value; /* because changing stroke-width will change the dash length
			and cause an epileptic effect */
                },
                dSetter: function (value, key, element) {
                    var i,
                        shadows = this.shadows;
                    value = value || [];
                    this.d = value.join && value.join(' '); // used in getter for animation

                    element.path = value = this.pathToVML(value);

                    // update shadows
                    if (shadows) {
                        i = shadows.length;
                        while (i--) {
                            shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;
                        }
                    }
                    this.setAttr(key, value);
                },
                fillSetter: function (value, key, element) {
                    var nodeName = element.nodeName;
                    if (nodeName === 'SPAN') { // text color
                        element.style.color = value;
                    } else if (nodeName !== 'IMG') { // #1336
                        element.filled = value !== NONE;
                        this.setAttr('fillcolor', this.renderer.color(value, element, key, this));
                    }
                },
                opacitySetter: noop, // Don't bother - animation is too slow and filters introduce artifacts
                rotationSetter: function (value, key, element) {
                    var style = element.style;
                    this[key] = style[key] = value; // style is for #1873

                    // Correction for the 1x1 size of the shape container. Used in gauge needles.
                    style.left = -mathRound(mathSin(value * deg2rad) + 1) + PX;
                    style.top = mathRound(mathCos(value * deg2rad)) + PX;
                },
                strokeSetter: function (value, key, element) {
                    this.setAttr('strokecolor', this.renderer.color(value, element, key));
                },
                'stroke-widthSetter': function (value, key, element) {
                    element.stroked = !!value; // VML "stroked" attribute
                    this[key] = value; // used in getter, issue #113
                    if (isNumber(value)) {
                        value += PX;
                    }
                    this.setAttr('strokeweight', value);
                },
                titleSetter: function (value, key) {
                    this.setAttr(key, value);
                },
                visibilitySetter: function (value, key, element) {

                    // Handle inherited visibility
                    if (value === 'inherit') {
                        value = VISIBLE;
                    }

                    // Let the shadow follow the main element
                    if (this.shadows) {
                        each(this.shadows, function (shadow) {
                            shadow.style[key] = value;
                        });
                    }

                    // Instead of toggling the visibility CSS property, move the div out of the viewport.
                    // This works around #61 and #586
                    if (element.nodeName === 'DIV') {
                        value = value === HIDDEN ? '-999em' : 0;

                        // In order to redraw, IE7 needs the div to be visible when tucked away
                        // outside the viewport. So the visibility is actually opposite of
                        // the expected value. This applies to the tooltip only.
                        if (!docMode8) {
                            element.style[key] = value ? VISIBLE : HIDDEN;
                        }
                        key = 'top';
                    }
                    element.style[key] = value;
                },
                xSetter: function (value, key, element) {
                    this[key] = value; // used in getter

                    if (key === 'x') {
                        key = 'left';
                    } else if (key === 'y') {
                        key = 'top';
                    }/* else {
			value = mathMax(0, value); // don't set width or height below zero (#311)
		}*/

                    // clipping rectangle special
                    if (this.updateClipping) {
                        this[key] = value; // the key is now 'left' or 'top' for 'x' and 'y'
                        this.updateClipping();
                    } else {
                        // normal
                        element.style[key] = value;
                    }
                },
                zIndexSetter: function (value, key, element) {
                    element.style[key] = value;
                }
            };
            Highcharts.VMLElement = VMLElement = extendClass(SVGElement, VMLElement);

            // Some shared setters
            VMLElement.prototype.ySetter =
                VMLElement.prototype.widthSetter =
                VMLElement.prototype.heightSetter =
                VMLElement.prototype.xSetter;


            /**
             * The VML renderer
             */
            var VMLRendererExtension = { // inherit SVGRenderer

                Element: VMLElement,
                isIE8: userAgent.indexOf('MSIE 8.0') > -1,


                /**
                 * Initialize the VMLRenderer
                 * @param {Object} container
                 * @param {Number} width
                 * @param {Number} height
                 */
                init: function (container, width, height, style) {
                    var renderer = this,
                        boxWrapper,
                        box,
                        css;

                    renderer.alignedObjects = [];

                    boxWrapper = renderer.createElement(DIV)
                        .css(extend(this.getStyle(style), { position: RELATIVE }));
                    box = boxWrapper.element;
                    container.appendChild(boxWrapper.element);


                    // generate the containing box
                    renderer.isVML = true;
                    renderer.box = box;
                    renderer.boxWrapper = boxWrapper;
                    renderer.cache = {};


                    renderer.setSize(width, height, false);

                    // The only way to make IE6 and IE7 print is to use a global namespace. However,
                    // with IE8 the only way to make the dynamic shapes visible in screen and print mode
                    // seems to be to add the xmlns attribute and the behaviour style inline.
                    if (!doc.namespaces.hcv) {

                        doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');

                        // Setup default CSS (#2153, #2368, #2384)
                        css = 'hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke' +
                            '{ behavior:url(#default#VML); display: inline-block; } ';
                        try {
                            doc.createStyleSheet().cssText = css;
                        } catch (e) {
                            doc.styleSheets[0].cssText += css;
                        }

                    }
                },


                /**
                 * Detect whether the renderer is hidden. This happens when one of the parent elements
                 * has display: none
                 */
                isHidden: function () {
                    return !this.box.offsetWidth;
                },

                /**
                 * Define a clipping rectangle. In VML it is accomplished by storing the values
                 * for setting the CSS style to all associated members.
                 *
                 * @param {Number} x
                 * @param {Number} y
                 * @param {Number} width
                 * @param {Number} height
                 */
                clipRect: function (x, y, width, height) {

                    // create a dummy element
                    var clipRect = this.createElement(),
                        isObj = isObject(x);

                    // mimic a rectangle with its style object for automatic updating in attr
                    return extend(clipRect, {
                        members: [],
                        count: 0,
                        left: (isObj ? x.x : x) + 1,
                        top: (isObj ? x.y : y) + 1,
                        width: (isObj ? x.width : width) - 1,
                        height: (isObj ? x.height : height) - 1,
                        getCSS: function (wrapper) {
                            var element = wrapper.element,
                                nodeName = element.nodeName,
                                isShape = nodeName === 'shape',
                                inverted = wrapper.inverted,
                                rect = this,
                                top = rect.top - (isShape ? element.offsetTop : 0),
                                left = rect.left,
                                right = left + rect.width,
                                bottom = top + rect.height,
                                ret = {
                                    clip: 'rect(' +
                                        mathRound(inverted ? left : top) + 'px,' +
                                        mathRound(inverted ? bottom : right) + 'px,' +
                                        mathRound(inverted ? right : bottom) + 'px,' +
                                        mathRound(inverted ? top : left) + 'px)'
                                };

                            // issue 74 workaround
                            if (!inverted && docMode8 && nodeName === 'DIV') {
                                extend(ret, {
                                    width: right + PX,
                                    height: bottom + PX
                                });
                            }
                            return ret;
                        },

                        // used in attr and animation to update the clipping of all members
                        updateClipping: function () {
                            each(clipRect.members, function (member) {
                                if (member.element) { // Deleted series, like in stock/members/series-remove demo. Should be removed from members, but this will do.
                                    member.css(clipRect.getCSS(member));
                                }
                            });
                        }
                    });

                },


                /**
                 * Take a color and return it if it's a string, make it a gradient if it's a
                 * gradient configuration object, and apply opacity.
                 *
                 * @param {Object} color The color or config object
                 */
                color: function (color, elem, prop, wrapper) {
                    var renderer = this,
                        colorObject,
                        regexRgba = /^rgba/,
                        markup,
                        fillType,
                        ret = NONE;

                    // Check for linear or radial gradient
                    if (color && color.linearGradient) {
                        fillType = 'gradient';
                    } else if (color && color.radialGradient) {
                        fillType = 'pattern';
                    }


                    if (fillType) {

                        var stopColor,
                            stopOpacity,
                            gradient = color.linearGradient || color.radialGradient,
                            x1,
                            y1,
                            x2,
                            y2,
                            opacity1,
                            opacity2,
                            color1,
                            color2,
                            fillAttr = '',
                            stops = color.stops,
                            firstStop,
                            lastStop,
                            colors = [],
                            addFillNode = function () {
                                // Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2
                                // are reversed.
                                markup = ['<fill colors="' + colors.join(',') + '" opacity="', opacity2, '" o:opacity2="', opacity1,
                                    '" type="', fillType, '" ', fillAttr, 'focus="100%" method="any" />'];
                                createElement(renderer.prepVML(markup), null, null, elem);
                            };

                        // Extend from 0 to 1
                        firstStop = stops[0];
                        lastStop = stops[stops.length - 1];
                        if (firstStop[0] > 0) {
                            stops.unshift([
                                0,
                                firstStop[1]
                            ]);
                        }
                        if (lastStop[0] < 1) {
                            stops.push([
                                1,
                                lastStop[1]
                            ]);
                        }

                        // Compute the stops
                        each(stops, function (stop, i) {
                            if (regexRgba.test(stop[1])) {
                                colorObject = Color(stop[1]);
                                stopColor = colorObject.get('rgb');
                                stopOpacity = colorObject.get('a');
                            } else {
                                stopColor = stop[1];
                                stopOpacity = 1;
                            }

                            // Build the color attribute
                            colors.push((stop[0] * 100) + '% ' + stopColor);

                            // Only start and end opacities are allowed, so we use the first and the last
                            if (!i) {
                                opacity1 = stopOpacity;
                                color2 = stopColor;
                            } else {
                                opacity2 = stopOpacity;
                                color1 = stopColor;
                            }
                        });

                        // Apply the gradient to fills only.
                        if (prop === 'fill') {

                            // Handle linear gradient angle
                            if (fillType === 'gradient') {
                                x1 = gradient.x1 || gradient[0] || 0;
                                y1 = gradient.y1 || gradient[1] || 0;
                                x2 = gradient.x2 || gradient[2] || 0;
                                y2 = gradient.y2 || gradient[3] || 0;
                                fillAttr = 'angle="' + (90 - math.atan(
                                    (y2 - y1) / // y vector
                                    (x2 - x1) // x vector
                                    ) * 180 / mathPI) + '"';

                                addFillNode();

                                // Radial (circular) gradient
                            } else {

                                var r = gradient.r,
                                    sizex = r * 2,
                                    sizey = r * 2,
                                    cx = gradient.cx,
                                    cy = gradient.cy,
                                    radialReference = elem.radialReference,
                                    bBox,
                                    applyRadialGradient = function () {
                                        if (radialReference) {
                                            bBox = wrapper.getBBox();
                                            cx += (radialReference[0] - bBox.x) / bBox.width - 0.5;
                                            cy += (radialReference[1] - bBox.y) / bBox.height - 0.5;
                                            sizex *= radialReference[2] / bBox.width;
                                            sizey *= radialReference[2] / bBox.height;
                                        }
                                        fillAttr = 'src="' + defaultOptions.global.VMLRadialGradientURL + '" ' +
                                            'size="' + sizex + ',' + sizey + '" ' +
                                            'origin="0.5,0.5" ' +
                                            'position="' + cx + ',' + cy + '" ' +
                                            'color2="' + color2 + '" ';

                                        addFillNode();
                                    };

                                // Apply radial gradient
                                if (wrapper.added) {
                                    applyRadialGradient();
                                } else {
                                    // We need to know the bounding box to get the size and position right
                                    wrapper.onAdd = applyRadialGradient;
                                }

                                // The fill element's color attribute is broken in IE8 standards mode, so we
                                // need to set the parent shape's fillcolor attribute instead.
                                ret = color1;
                            }

                            // Gradients are not supported for VML stroke, return the first color. #722.
                        } else {
                            ret = stopColor;
                        }

                        // if the color is an rgba color, split it and add a fill node
                        // to hold the opacity component
                    } else if (regexRgba.test(color) && elem.tagName !== 'IMG') {

                        colorObject = Color(color);

                        markup = ['<', prop, ' opacity="', colorObject.get('a'), '"/>'];
                        createElement(this.prepVML(markup), null, null, elem);

                        ret = colorObject.get('rgb');


                    } else {
                        var propNodes = elem.getElementsByTagName(prop); // 'stroke' or 'fill' node
                        if (propNodes.length) {
                            propNodes[0].opacity = 1;
                            propNodes[0].type = 'solid';
                        }
                        ret = color;
                    }

                    return ret;
                },

                /**
                 * Take a VML string and prepare it for either IE8 or IE6/IE7.
                 * @param {Array} markup A string array of the VML markup to prepare
                 */
                prepVML: function (markup) {
                    var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',
                        isIE8 = this.isIE8;

                    markup = markup.join('');

                    if (isIE8) { // add xmlns and style inline
                        markup = markup.replace('/>', ' xmlns="urn:schemas-microsoft-com:vml" />');
                        if (markup.indexOf('style="') === -1) {
                            markup = markup.replace('/>', ' style="' + vmlStyle + '" />');
                        } else {
                            markup = markup.replace('style="', 'style="' + vmlStyle);
                        }

                    } else { // add namespace
                        markup = markup.replace('<', '<hcv:');
                    }

                    return markup;
                },

                /**
                 * Create rotated and aligned text
                 * @param {String} str
                 * @param {Number} x
                 * @param {Number} y
                 */
                text: SVGRenderer.prototype.html,

                /**
                 * Create and return a path element
                 * @param {Array} path
                 */
                path: function (path) {
                    var attr = {
                        // subpixel precision down to 0.1 (width and height = 1px)
                        coordsize: '10 10'
                    };
                    if (isArray(path)) {
                        attr.d = path;
                    } else if (isObject(path)) { // attributes
                        extend(attr, path);
                    }
                    // create the shape
                    return this.createElement('shape').attr(attr);
                },

                /**
                 * Create and return a circle element. In VML circles are implemented as
                 * shapes, which is faster than v:oval
                 * @param {Number} x
                 * @param {Number} y
                 * @param {Number} r
                 */
                circle: function (x, y, r) {
                    var circle = this.symbol('circle');
                    if (isObject(x)) {
                        r = x.r;
                        y = x.y;
                        x = x.x;
                    }
                    circle.isCircle = true; // Causes x and y to mean center (#1682)
                    circle.r = r;
                    return circle.attr({ x: x, y: y });
                },

                /**
                 * Create a group using an outer div and an inner v:group to allow rotating
                 * and flipping. A simple v:group would have problems with positioning
                 * child HTML elements and CSS clip.
                 *
                 * @param {String} name The name of the group
                 */
                g: function (name) {
                    var wrapper,
                        attribs;

                    // set the class name
                    if (name) {
                        attribs = { 'className': PREFIX + name, 'class': PREFIX + name };
                    }

                    // the div to hold HTML and clipping
                    wrapper = this.createElement(DIV).attr(attribs);

                    return wrapper;
                },

                /**
                 * VML override to create a regular HTML image
                 * @param {String} src
                 * @param {Number} x
                 * @param {Number} y
                 * @param {Number} width
                 * @param {Number} height
                 */
                image: function (src, x, y, width, height) {
                    var obj = this.createElement('img')
                        .attr({ src: src });

                    if (arguments.length > 1) {
                        obj.attr({
                            x: x,
                            y: y,
                            width: width,
                            height: height
                        });
                    }
                    return obj;
                },

                /**
                 * For rectangles, VML uses a shape for rect to overcome bugs and rotation problems
                 */
                createElement: function (nodeName) {
                    return nodeName === 'rect' ? this.symbol(nodeName) : SVGRenderer.prototype.createElement.call(this, nodeName);
                },

                /**
                 * In the VML renderer, each child of an inverted div (group) is inverted
                 * @param {Object} element
                 * @param {Object} parentNode
                 */
                invertChild: function (element, parentNode) {
                    var ren = this,
                        parentStyle = parentNode.style,
                        imgStyle = element.tagName === 'IMG' && element.style; // #1111

                    css(element, {
                        flip: 'x',
                        left: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : 1),
                        top: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : 1),
                        rotation: -90
                    });

                    // Recursively invert child elements, needed for nested composite shapes like box plots and error bars. #1680, #1806.
                    each(element.childNodes, function (child) {
                        ren.invertChild(child, element);
                    });
                },

                /**
                 * Symbol definitions that override the parent SVG renderer's symbols
                 *
                 */
                symbols: {
                    // VML specific arc function
                    arc: function (x, y, w, h, options) {
                        var start = options.start,
                            end = options.end,
                            radius = options.r || w || h,
                            innerRadius = options.innerR,
                            cosStart = mathCos(start),
                            sinStart = mathSin(start),
                            cosEnd = mathCos(end),
                            sinEnd = mathSin(end),
                            ret;

                        if (end - start === 0) { // no angle, don't show it.
                            return ['x'];
                        }

                        ret = [
                            'wa', // clockwise arc to
                            x - radius, // left
                            y - radius, // top
                            x + radius, // right
                            y + radius, // bottom
                            x + radius * cosStart, // start x
                            y + radius * sinStart, // start y
                            x + radius * cosEnd, // end x
                            y + radius * sinEnd  // end y
                        ];

                        if (options.open && !innerRadius) {
                            ret.push(
                                'e',
                                M,
                                x,// - innerRadius,
                                y// - innerRadius
                            );
                        }

                        ret.push(
                            'at', // anti clockwise arc to
                            x - innerRadius, // left
                            y - innerRadius, // top
                            x + innerRadius, // right
                            y + innerRadius, // bottom
                            x + innerRadius * cosEnd, // start x
                            y + innerRadius * sinEnd, // start y
                            x + innerRadius * cosStart, // end x
                            y + innerRadius * sinStart, // end y
                            'x', // finish path
                            'e' // close
                        );

                        ret.isArc = true;
                        return ret;

                    },
                    // Add circle symbol path. This performs significantly faster than v:oval.
                    circle: function (x, y, w, h, wrapper) {

                        if (wrapper) {
                            w = h = 2 * wrapper.r;
                        }

                        // Center correction, #1682
                        if (wrapper && wrapper.isCircle) {
                            x -= w / 2;
                            y -= h / 2;
                        }

                        // Return the path
                        return [
                            'wa', // clockwisearcto
                            x, // left
                            y, // top
                            x + w, // right
                            y + h, // bottom
                            x + w, // start x
                            y + h / 2,     // start y
                            x + w, // end x
                            y + h / 2,     // end y
                            //'x', // finish path
                            'e' // close
                        ];
                    },
                    /**
                     * Add rectangle symbol path which eases rotation and omits arcsize problems
                     * compared to the built-in VML roundrect shape. When borders are not rounded,
                     * use the simpler square path, else use the callout path without the arrow.
                     */
                    rect: function (x, y, w, h, options) {
                        return SVGRenderer.prototype.symbols[
                            !defined(options) || !options.r ? 'square' : 'callout'
                        ].call(0, x, y, w, h, options);
                    }
                }
            };
            Highcharts.VMLRenderer = VMLRenderer = function () {
                this.init.apply(this, arguments);
            };
            VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);

            // general renderer
            Renderer = VMLRenderer;
        }

        // This method is used with exporting in old IE, when emulating SVG (see #2314)
        SVGRenderer.prototype.measureSpanWidth = function (text, styles) {
            var measuringSpan = doc.createElement('span'),
                offsetWidth,
            textNode = doc.createTextNode(text);

            measuringSpan.appendChild(textNode);
            css(measuringSpan, styles);
            this.box.appendChild(measuringSpan);
            offsetWidth = measuringSpan.offsetWidth;
            discardElement(measuringSpan); // #2463
            return offsetWidth;
        };


        /* ****************************************************************************
         *                                                                            *
         * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *
         *                                                                            *
         *****************************************************************************/
        /* ****************************************************************************
         *                                                                            *
         * START OF ANDROID < 3 SPECIFIC CODE. THIS CAN BE REMOVED IF YOU'RE NOT      *
         * TARGETING THAT SYSTEM.                                                     *
         *                                                                            *
         *****************************************************************************/
        var CanVGRenderer,
            CanVGController;

        if (useCanVG) {
            /**
             * The CanVGRenderer is empty from start to keep the source footprint small.
             * When requested, the CanVGController downloads the rest of the source packaged
             * together with the canvg library.
             */
            Highcharts.CanVGRenderer = CanVGRenderer = function () {
                // Override the global SVG namespace to fake SVG/HTML that accepts CSS
                SVG_NS = 'http://www.w3.org/1999/xhtml';
            };

            /**
             * Start with an empty symbols object. This is needed when exporting is used (exporting.src.js will add a few symbols), but 
             * the implementation from SvgRenderer will not be merged in until first render.
             */
            CanVGRenderer.prototype.symbols = {};

            /**
             * Handles on demand download of canvg rendering support.
             */
            CanVGController = (function () {
                // List of renderering calls
                var deferredRenderCalls = [];

                /**
                 * When downloaded, we are ready to draw deferred charts.
                 */
                function drawDeferred() {
                    var callLength = deferredRenderCalls.length,
                        callIndex;

                    // Draw all pending render calls
                    for (callIndex = 0; callIndex < callLength; callIndex++) {
                        deferredRenderCalls[callIndex]();
                    }
                    // Clear the list
                    deferredRenderCalls = [];
                }

                return {
                    push: function (func, scriptLocation) {
                        // Only get the script once
                        if (deferredRenderCalls.length === 0) {
                            getScript(scriptLocation, drawDeferred);
                        }
                        // Register render call
                        deferredRenderCalls.push(func);
                    }
                };
            }());

            Renderer = CanVGRenderer;
        } // end CanVGRenderer

        /* ****************************************************************************
         *                                                                            *
         * END OF ANDROID < 3 SPECIFIC CODE                                           *
         *                                                                            *
         *****************************************************************************/

        /**
         * The Tick class
         */
        function Tick(axis, pos, type, noLabel) {
            this.axis = axis;
            this.pos = pos;
            this.type = type || '';
            this.isNew = true;

            if (!type && !noLabel) {
                this.addLabel();
            }
        }

        Tick.prototype = {
            /**
             * Write the tick label
             */
            addLabel: function () {
                var tick = this,
                    axis = tick.axis,
                    options = axis.options,
                    chart = axis.chart,
                    categories = axis.categories,
                    names = axis.names,
                    pos = tick.pos,
                    labelOptions = options.labels,
                    str,
                    tickPositions = axis.tickPositions,
                    isFirst = pos === tickPositions[0],
                    isLast = pos === tickPositions[tickPositions.length - 1],
                    value = categories ?
                        pick(categories[pos], names[pos], pos) :
                        pos,
                    label = tick.label,
                    tickPositionInfo = tickPositions.info,
                    dateTimeLabelFormat;

                // Set the datetime label format. If a higher rank is set for this position, use that. If not,
                // use the general format.
                if (axis.isDatetimeAxis && tickPositionInfo) {
                    dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];
                }
                // set properties for access in render method
                tick.isFirst = isFirst;
                tick.isLast = isLast;

                // get the string
                str = axis.labelFormatter.call({
                    axis: axis,
                    chart: chart,
                    isFirst: isFirst,
                    isLast: isLast,
                    dateTimeLabelFormat: dateTimeLabelFormat,
                    value: axis.isLog ? correctFloat(lin2log(value)) : value
                });

                // prepare CSS
                //css = width && { width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) + PX };

                // first call
                if (!defined(label)) {

                    tick.label = label =
                        defined(str) && labelOptions.enabled ?
                            chart.renderer.text(
                                    str,
                                    0,
                                    0,
                                    labelOptions.useHTML
                                )
                                //.attr(attr)
                                // without position absolute, IE export sometimes is wrong
                                .css(merge(labelOptions.style))
                                .add(axis.labelGroup) :
                            null;
                    tick.labelLength = label && label.getBBox().width; // Un-rotated length
                    tick.rotation = 0; // Base value to detect change for new calls to getBBox

                    // update
                } else if (label) {
                    label.attr({ text: str });
                }
            },

            /**
             * Get the offset height or width of the label
             */
            getLabelSize: function () {
                return this.label ?
                    this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :
                    0;
            },

            /**
             * Handle the label overflow by adjusting the labels to the left and right edge, or
             * hide them if they collide into the neighbour label.
             */
            handleOverflow: function (xy) {
                var axis = this.axis,
                    pxPos = xy.x,
                    chartWidth = axis.chart.chartWidth,
                    spacing = axis.chart.spacing,
                    leftBound = pick(axis.labelLeft, mathMin(axis.pos, spacing[3])),
                    rightBound = pick(axis.labelRight, mathMax(axis.pos + axis.len, chartWidth - spacing[1])),
                    label = this.label,
                    rotation = this.rotation,
                    factor = { left: 0, center: 0.5, right: 1 }[axis.labelAlign],
                    labelWidth = label.getBBox().width,
                    slotWidth = axis.slotWidth,
                    xCorrection = factor,
                    goRight = 1,
                    leftPos,
                    rightPos,
                    textWidth,
                    css = {};

                // Check if the label overshoots the chart spacing box. If it does, move it.
                // If it now overshoots the slotWidth, add ellipsis.
                if (!rotation) {
                    leftPos = pxPos - factor * labelWidth;
                    rightPos = pxPos + (1 - factor) * labelWidth;

                    if (leftPos < leftBound) {
                        slotWidth = xy.x + slotWidth * (1 - factor) - leftBound;
                    } else if (rightPos > rightBound) {
                        slotWidth = rightBound - xy.x + slotWidth * factor;
                        goRight = -1;
                    }

                    slotWidth = mathMin(axis.slotWidth, slotWidth); // #4177
                    if (slotWidth < axis.slotWidth && axis.labelAlign === 'center') {
                        xy.x += goRight * (axis.slotWidth - slotWidth - xCorrection * (axis.slotWidth - mathMin(labelWidth, slotWidth)));
                    }
                    // If the label width exceeds the available space, set a text width to be 
                    // picked up below. Also, if a width has been set before, we need to set a new
                    // one because the reported labelWidth will be limited by the box (#3938).
                    if (labelWidth > slotWidth || (axis.autoRotation && label.styles.width)) {
                        textWidth = slotWidth;
                    }

                    // Add ellipsis to prevent rotated labels to be clipped against the edge of the chart
                } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {
                    textWidth = mathRound(pxPos / mathCos(rotation * deg2rad) - leftBound);
                } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {
                    textWidth = mathRound((chartWidth - pxPos) / mathCos(rotation * deg2rad));
                }

                if (textWidth) {
                    css.width = textWidth;
                    if (!axis.options.labels.style.textOverflow) {
                        css.textOverflow = 'ellipsis';
                    }
                    label.css(css);
                }
            },

            /**
             * Get the x and y position for ticks and labels
             */
            getPosition: function (horiz, pos, tickmarkOffset, old) {
                var axis = this.axis,
                    chart = axis.chart,
                    cHeight = (old && chart.oldChartHeight) || chart.chartHeight;

                return {
                    x: horiz ?
                        axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB :
                        axis.left + axis.offset + (axis.opposite ? ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left : 0),

                    y: horiz ?
                        cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) :
                        cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB
                };

            },

            /**
             * Get the x, y position of the tick label
             */
            getLabelPosition: function (x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
                var axis = this.axis,
                    transA = axis.transA,
                    reversed = axis.reversed,
                    staggerLines = axis.staggerLines,
                    rotCorr = axis.tickRotCorr || { x: 0, y: 0 },
                    yOffset = pick(labelOptions.y, rotCorr.y + (axis.side === 2 ? 8 : -(label.getBBox().height / 2))),
                    line;

                x = x + labelOptions.x + rotCorr.x - (tickmarkOffset && horiz ?
                    tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
                y = y + yOffset - (tickmarkOffset && !horiz ?
                    tickmarkOffset * transA * (reversed ? 1 : -1) : 0);

                // Correct for staggered labels
                if (staggerLines) {
                    line = (index / (step || 1) % staggerLines);
                    y += line * (axis.labelOffset / staggerLines);
                }

                return {
                    x: x,
                    y: mathRound(y)
                };
            },

            /**
             * Extendible method to return the path of the marker
             */
            getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {
                return renderer.crispLine([
                        M,
                        x,
                        y,
                        L,
                        x + (horiz ? 0 : -tickLength),
                        y + (horiz ? tickLength : 0)
                ], tickWidth);
            },

            /**
             * Put everything in place
             *
             * @param index {Number}
             * @param old {Boolean} Use old coordinates to prepare an animation into new position
             */
            render: function (index, old, opacity) {
                var tick = this,
                    axis = tick.axis,
                    options = axis.options,
                    chart = axis.chart,
                    renderer = chart.renderer,
                    horiz = axis.horiz,
                    type = tick.type,
                    label = tick.label,
                    pos = tick.pos,
                    labelOptions = options.labels,
                    gridLine = tick.gridLine,
                    gridPrefix = type ? type + 'Grid' : 'grid',
                    tickPrefix = type ? type + 'Tick' : 'tick',
                    gridLineWidth = options[gridPrefix + 'LineWidth'],
                    gridLineColor = options[gridPrefix + 'LineColor'],
                    dashStyle = options[gridPrefix + 'LineDashStyle'],
                    tickLength = options[tickPrefix + 'Length'],
                    tickWidth = options[tickPrefix + 'Width'] || 0,
                    tickColor = options[tickPrefix + 'Color'],
                    tickPosition = options[tickPrefix + 'Position'],
                    gridLinePath,
                    mark = tick.mark,
                    markPath,
                    step = /*axis.labelStep || */labelOptions.step,
                    attribs,
                    show = true,
                    tickmarkOffset = axis.tickmarkOffset,
                    xy = tick.getPosition(horiz, pos, tickmarkOffset, old),
                    x = xy.x,
                    y = xy.y,
                    reverseCrisp = ((horiz && x === axis.pos + axis.len) || (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687

                opacity = pick(opacity, 1);
                this.isActive = true;

                // create the grid line
                if (gridLineWidth) {
                    gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLineWidth * reverseCrisp, old, true);

                    if (gridLine === UNDEFINED) {
                        attribs = {
                            stroke: gridLineColor,
                            'stroke-width': gridLineWidth
                        };
                        if (dashStyle) {
                            attribs.dashstyle = dashStyle;
                        }
                        if (!type) {
                            attribs.zIndex = 1;
                        }
                        if (old) {
                            attribs.opacity = 0;
                        }
                        tick.gridLine = gridLine =
                            gridLineWidth ?
                                renderer.path(gridLinePath)
                                    .attr(attribs).add(axis.gridGroup) :
                                null;
                    }

                    // If the parameter 'old' is set, the current call will be followed
                    // by another call, therefore do not do any animations this time
                    if (!old && gridLine && gridLinePath) {
                        gridLine[tick.isNew ? 'attr' : 'animate']({
                            d: gridLinePath,
                            opacity: opacity
                        });
                    }
                }

                // create the tick mark
                if (tickWidth && tickLength) {

                    // negate the length
                    if (tickPosition === 'inside') {
                        tickLength = -tickLength;
                    }
                    if (axis.opposite) {
                        tickLength = -tickLength;
                    }

                    markPath = tick.getMarkPath(x, y, tickLength, tickWidth * reverseCrisp, horiz, renderer);
                    if (mark) { // updating
                        mark.animate({
                            d: markPath,
                            opacity: opacity
                        });
                    } else { // first time
                        tick.mark = renderer.path(
                            markPath
                        ).attr({
                            stroke: tickColor,
                            'stroke-width': tickWidth,
                            opacity: opacity
                        }).add(axis.axisGroup);
                    }
                }

                // the label is created on init - now move it into place
                if (label && !isNaN(x)) {
                    label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);

                    // Apply show first and show last. If the tick is both first and last, it is
                    // a single centered tick, in which case we show the label anyway (#2100).
                    if ((tick.isFirst && !tick.isLast && !pick(options.showFirstLabel, 1)) ||
                            (tick.isLast && !tick.isFirst && !pick(options.showLastLabel, 1))) {
                        show = false;

                        // Handle label overflow and show or hide accordingly
                    } else if (horiz && !axis.isRadial && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {
                        tick.handleOverflow(xy);
                    }

                    // apply step
                    if (step && index % step) {
                        // show those indices dividable by step
                        show = false;
                    }

                    // Set the new position, and show or hide
                    if (show && !isNaN(xy.y)) {
                        xy.opacity = opacity;
                        label[tick.isNew ? 'attr' : 'animate'](xy);
                        tick.isNew = false;
                    } else {
                        label.attr('y', -9999); // #1338
                    }
                }
            },

            /**
             * Destructor for the tick prototype
             */
            destroy: function () {
                destroyObjectProperties(this, this.axis);
            }
        };

        /**
         * The object wrapper for plot lines and plot bands
         * @param {Object} options
         */
        Highcharts.PlotLineOrBand = function (axis, options) {
            this.axis = axis;

            if (options) {
                this.options = options;
                this.id = options.id;
            }
        };

        Highcharts.PlotLineOrBand.prototype = {

            /**
             * Render the plot line or plot band. If it is already existing,
             * move it.
             */
            render: function () {
                var plotLine = this,
                    axis = plotLine.axis,
                    horiz = axis.horiz,
                    options = plotLine.options,
                    optionsLabel = options.label,
                    label = plotLine.label,
                    width = options.width,
                    to = options.to,
                    from = options.from,
                    isBand = defined(from) && defined(to),
                    value = options.value,
                    dashStyle = options.dashStyle,
                    svgElem = plotLine.svgElem,
                    path = [],
                    addEvent,
                    eventType,
                    xs,
                    ys,
                    x,
                    y,
                    color = options.color,
                    zIndex = options.zIndex,
                    events = options.events,
                    attribs = {},
                    renderer = axis.chart.renderer;

                // logarithmic conversion
                if (axis.isLog) {
                    from = log2lin(from);
                    to = log2lin(to);
                    value = log2lin(value);
                }

                // plot line
                if (width) {
                    path = axis.getPlotLinePath(value, width);
                    attribs = {
                        stroke: color,
                        'stroke-width': width
                    };
                    if (dashStyle) {
                        attribs.dashstyle = dashStyle;
                    }
                } else if (isBand) { // plot band

                    path = axis.getPlotBandPath(from, to, options);
                    if (color) {
                        attribs.fill = color;
                    }
                    if (options.borderWidth) {
                        attribs.stroke = options.borderColor;
                        attribs['stroke-width'] = options.borderWidth;
                    }
                } else {
                    return;
                }
                // zIndex
                if (defined(zIndex)) {
                    attribs.zIndex = zIndex;
                }

                // common for lines and bands
                if (svgElem) {
                    if (path) {
                        svgElem.animate({
                            d: path
                        }, null, svgElem.onGetPath);
                    } else {
                        svgElem.hide();
                        svgElem.onGetPath = function () {
                            svgElem.show();
                        };
                        if (label) {
                            plotLine.label = label = label.destroy();
                        }
                    }
                } else if (path && path.length) {
                    plotLine.svgElem = svgElem = renderer.path(path)
                        .attr(attribs).add();

                    // events
                    if (events) {
                        addEvent = function (eventType) {
                            svgElem.on(eventType, function (e) {
                                events[eventType].apply(plotLine, [e]);
                            });
                        };
                        for (eventType in events) {
                            addEvent(eventType);
                        }
                    }
                }

                // the plot band/line label
                if (optionsLabel && defined(optionsLabel.text) && path && path.length && axis.width > 0 && axis.height > 0) {
                    // apply defaults
                    optionsLabel = merge({
                        align: horiz && isBand && 'center',
                        x: horiz ? !isBand && 4 : 10,
                        verticalAlign: !horiz && isBand && 'middle',
                        y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
                        rotation: horiz && !isBand && 90
                    }, optionsLabel);

                    // add the SVG element
                    if (!label) {
                        attribs = {
                            align: optionsLabel.textAlign || optionsLabel.align,
                            rotation: optionsLabel.rotation
                        };
                        if (defined(zIndex)) {
                            attribs.zIndex = zIndex;
                        }
                        plotLine.label = label = renderer.text(
                                optionsLabel.text,
                                0,
                                0,
                                optionsLabel.useHTML
                            )
                            .attr(attribs)
                            .css(optionsLabel.style)
                            .add();
                    }

                    // get the bounding box and align the label
                    // #3000 changed to better handle choice between plotband or plotline
                    xs = [path[1], path[4], (isBand ? path[6] : path[1])];
                    ys = [path[2], path[5], (isBand ? path[7] : path[2])];
                    x = arrayMin(xs);
                    y = arrayMin(ys);

                    label.align(optionsLabel, false, {
                        x: x,
                        y: y,
                        width: arrayMax(xs) - x,
                        height: arrayMax(ys) - y
                    });
                    label.show();

                } else if (label) { // move out of sight
                    label.hide();
                }

                // chainable
                return plotLine;
            },

            /**
             * Remove the plot line or band
             */
            destroy: function () {
                // remove it from the lookup
                erase(this.axis.plotLinesAndBands, this);

                delete this.axis;
                destroyObjectProperties(this);
            }
        };

        /**
         * Object with members for extending the Axis prototype
         */

        AxisPlotLineOrBandExtension = {

            /**
             * Create the path for a plot band
             */
            getPlotBandPath: function (from, to) {
                var toPath = this.getPlotLinePath(to, null, null, true),
                    path = this.getPlotLinePath(from, null, null, true);

                if (path && toPath && path.toString() !== toPath.toString()) { // #3836
                    path.push(
                        toPath[4],
                        toPath[5],
                        toPath[1],
                        toPath[2]
                    );
                } else { // outside the axis area
                    path = null;
                }

                return path;
            },

            addPlotBand: function (options) {
                return this.addPlotBandOrLine(options, 'plotBands');
            },

            addPlotLine: function (options) {
                return this.addPlotBandOrLine(options, 'plotLines');
            },

            /**
             * Add a plot band or plot line after render time
             *
             * @param options {Object} The plotBand or plotLine configuration object
             */
            addPlotBandOrLine: function (options, coll) {
                var obj = new Highcharts.PlotLineOrBand(this, options).render(),
                    userOptions = this.userOptions;

                if (obj) { // #2189
                    // Add it to the user options for exporting and Axis.update
                    if (coll) {
                        userOptions[coll] = userOptions[coll] || [];
                        userOptions[coll].push(options);
                    }
                    this.plotLinesAndBands.push(obj);
                }

                return obj;
            },

            /**
             * Remove a plot band or plot line from the chart by id
             * @param {Object} id
             */
            removePlotBandOrLine: function (id) {
                var plotLinesAndBands = this.plotLinesAndBands,
                    options = this.options,
                    userOptions = this.userOptions,
                    i = plotLinesAndBands.length;
                while (i--) {
                    if (plotLinesAndBands[i].id === id) {
                        plotLinesAndBands[i].destroy();
                    }
                }
                each([options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || []], function (arr) {
                    i = arr.length;
                    while (i--) {
                        if (arr[i].id === id) {
                            erase(arr, arr[i]);
                        }
                    }
                });
            }
        };

        /**
         * Create a new axis object
         * @param {Object} chart
         * @param {Object} options
         */
        var Axis = Highcharts.Axis = function () {
            this.init.apply(this, arguments);
        };

        Axis.prototype = {

            /**
             * Default options for the X axis - the Y axis has extended defaults
             */
            defaultOptions: {
                // allowDecimals: null,
                // alternateGridColor: null,
                // categories: [],
                dateTimeLabelFormats: {
                    millisecond: '%H:%M:%S.%L',
                    second: '%H:%M:%S',
                    minute: '%H:%M',
                    hour: '%H:%M',
                    day: '%e. %b',
                    week: '%e. %b',
                    month: '%b \'%y',
                    year: '%Y'
                },
                endOnTick: false,
                gridLineColor: '#D8D8D8',
                // gridLineDashStyle: 'solid',
                // gridLineWidth: 0,
                // reversed: false,

                labels: {
                    enabled: true,
                    // rotation: 0,
                    // align: 'center',
                    // step: null,
                    style: {
                        color: '#606060',
                        cursor: 'default',
                        fontSize: '11px'
                    },
                    x: 0,
                    y: 15
                    /*formatter: function () {
                        return this.value;
                    },*/
                },
                lineColor: '#C0D0E0',
                lineWidth: 1,
                //linkedTo: null,
                //max: undefined,
                //min: undefined,
                minPadding: 0.01,
                maxPadding: 0.01,
                //minRange: null,
                minorGridLineColor: '#E0E0E0',
                // minorGridLineDashStyle: null,
                minorGridLineWidth: 1,
                minorTickColor: '#A0A0A0',
                //minorTickInterval: null,
                minorTickLength: 2,
                minorTickPosition: 'outside', // inside or outside
                //minorTickWidth: 0,
                //opposite: false,
                //offset: 0,
                //plotBands: [{
                //	events: {},
                //	zIndex: 1,
                //	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
                //}],
                //plotLines: [{
                //	events: {}
                //  dashStyle: {}
                //	zIndex:
                //	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
                //}],
                //reversed: false,
                // showFirstLabel: true,
                // showLastLabel: true,
                startOfWeek: 1,
                startOnTick: false,
                tickColor: '#C0D0E0',
                //tickInterval: null,
                tickLength: 10,
                tickmarkPlacement: 'between', // on or between
                tickPixelInterval: 100,
                tickPosition: 'outside',
                tickWidth: 1,
                title: {
                    //text: null,
                    align: 'middle', // low, middle or high
                    //margin: 0 for horizontal, 10 for vertical axes,
                    //rotation: 0,
                    //side: 'outside',
                    style: {
                        color: '#707070'
                    }
                    //x: 0,
                    //y: 0
                },
                type: 'linear' // linear, logarithmic or datetime
            },

            /**
             * This options set extends the defaultOptions for Y axes
             */
            defaultYAxisOptions: {
                endOnTick: true,
                gridLineWidth: 1,
                tickPixelInterval: 72,
                showLastLabel: true,
                labels: {
                    x: -8,
                    y: 3
                },
                lineWidth: 0,
                maxPadding: 0.05,
                minPadding: 0.05,
                startOnTick: true,
                tickWidth: 0,
                title: {
                    rotation: 270,
                    text: 'Values'
                },
                stackLabels: {
                    enabled: false,
                    //align: dynamic,
                    //y: dynamic,
                    //x: dynamic,
                    //verticalAlign: dynamic,
                    //textAlign: dynamic,
                    //rotation: 0,
                    formatter: function () {
                        return Highcharts.numberFormat(this.total, -1);
                    },
                    style: merge(defaultPlotOptions.line.dataLabels.style, { color: '#000000' })
                }
            },

            /**
             * These options extend the defaultOptions for left axes
             */
            defaultLeftAxisOptions: {
                labels: {
                    x: -15,
                    y: null
                },
                title: {
                    rotation: 270
                }
            },

            /**
             * These options extend the defaultOptions for right axes
             */
            defaultRightAxisOptions: {
                labels: {
                    x: 15,
                    y: null
                },
                title: {
                    rotation: 90
                }
            },

            /**
             * These options extend the defaultOptions for bottom axes
             */
            defaultBottomAxisOptions: {
                labels: {
                    autoRotation: [-45],
                    x: 0,
                    y: null // based on font size
                    // overflow: undefined,
                    // staggerLines: null
                },
                title: {
                    rotation: 0
                }
            },
            /**
             * These options extend the defaultOptions for top axes
             */
            defaultTopAxisOptions: {
                labels: {
                    autoRotation: [-45],
                    x: 0,
                    y: -15
                    // overflow: undefined
                    // staggerLines: null
                },
                title: {
                    rotation: 0
                }
            },

            /**
             * Initialize the axis
             */
            init: function (chart, userOptions) {


                var isXAxis = userOptions.isX,
                    axis = this;

                // Flag, is the axis horizontal
                axis.horiz = chart.inverted ? !isXAxis : isXAxis;

                // Flag, isXAxis
                axis.isXAxis = isXAxis;
                axis.coll = isXAxis ? 'xAxis' : 'yAxis';

                axis.opposite = userOptions.opposite; // needed in setOptions
                axis.side = userOptions.side || (axis.horiz ?
                        (axis.opposite ? 0 : 2) : // top : bottom
                        (axis.opposite ? 1 : 3));  // right : left

                axis.setOptions(userOptions);


                var options = this.options,
                    type = options.type,
                    isDatetimeAxis = type === 'datetime';

                axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter; // can be overwritten by dynamic format


                // Flag, stagger lines or not
                axis.userOptions = userOptions;

                //axis.axisTitleMargin = UNDEFINED,// = options.title.margin,
                axis.minPixelPadding = 0;
                //axis.ignoreMinPadding = UNDEFINED; // can be set to true by a column or bar series
                //axis.ignoreMaxPadding = UNDEFINED;

                axis.chart = chart;
                axis.reversed = options.reversed;
                axis.zoomEnabled = options.zoomEnabled !== false;

                // Initial categories
                axis.categories = options.categories || type === 'category';
                axis.names = axis.names || []; // Preserve on update (#3830)

                // Elements
                //axis.axisGroup = UNDEFINED;
                //axis.gridGroup = UNDEFINED;
                //axis.axisTitle = UNDEFINED;
                //axis.axisLine = UNDEFINED;

                // Shorthand types
                axis.isLog = type === 'logarithmic';
                axis.isDatetimeAxis = isDatetimeAxis;

                // Flag, if axis is linked to another axis
                axis.isLinked = defined(options.linkedTo);
                // Linked axis.
                //axis.linkedParent = UNDEFINED;

                // Tick positions
                //axis.tickPositions = UNDEFINED; // array containing predefined positions
                // Tick intervals
                //axis.tickInterval = UNDEFINED;
                //axis.minorTickInterval = UNDEFINED;


                // Major ticks
                axis.ticks = {};
                axis.labelEdge = [];
                // Minor ticks
                axis.minorTicks = {};

                // List of plotLines/Bands
                axis.plotLinesAndBands = [];

                // Alternate bands
                axis.alternateBands = {};

                // Axis metrics
                //axis.left = UNDEFINED;
                //axis.top = UNDEFINED;
                //axis.width = UNDEFINED;
                //axis.height = UNDEFINED;
                //axis.bottom = UNDEFINED;
                //axis.right = UNDEFINED;
                //axis.transA = UNDEFINED;
                //axis.transB = UNDEFINED;
                //axis.oldTransA = UNDEFINED;
                axis.len = 0;
                //axis.oldMin = UNDEFINED;
                //axis.oldMax = UNDEFINED;
                //axis.oldUserMin = UNDEFINED;
                //axis.oldUserMax = UNDEFINED;
                //axis.oldAxisLength = UNDEFINED;
                axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
                axis.range = options.range;
                axis.offset = options.offset || 0;


                // Dictionary for stacks
                axis.stacks = {};
                axis.oldStacks = {};

                // Min and max in the data
                //axis.dataMin = UNDEFINED,
                //axis.dataMax = UNDEFINED,

                // The axis range
                axis.max = null;
                axis.min = null;

                // User set min and max
                //axis.userMin = UNDEFINED,
                //axis.userMax = UNDEFINED,

                // Crosshair options
                axis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);
                // Run Axis

                var eventType,
                    events = axis.options.events;

                // Register
                if (inArray(axis, chart.axes) === -1) { // don't add it again on Axis.update()
                    if (isXAxis && !this.isColorAxis) { // #2713
                        chart.axes.splice(chart.xAxis.length, 0, axis);
                    } else {
                        chart.axes.push(axis);
                    }

                    chart[axis.coll].push(axis);
                }

                axis.series = axis.series || []; // populated by Series

                // inverted charts have reversed xAxes as default
                if (chart.inverted && isXAxis && axis.reversed === UNDEFINED) {
                    axis.reversed = true;
                }

                axis.removePlotBand = axis.removePlotBandOrLine;
                axis.removePlotLine = axis.removePlotBandOrLine;


                // register event listeners
                for (eventType in events) {
                    addEvent(axis, eventType, events[eventType]);
                }

                // extend logarithmic axis
                if (axis.isLog) {
                    axis.val2lin = log2lin;
                    axis.lin2val = lin2log;
                }
            },

            /**
             * Merge and set options
             */
            setOptions: function (userOptions) {
                this.options = merge(
                    this.defaultOptions,
                    this.isXAxis ? {} : this.defaultYAxisOptions,
                    [this.defaultTopAxisOptions, this.defaultRightAxisOptions,
                        this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side],
                    merge(
                        defaultOptions[this.coll], // if set in setOptions (#1053)
                        userOptions
                    )
                );
            },

            /**
             * The default label formatter. The context is a special config object for the label.
             */
            defaultLabelFormatter: function () {
                var axis = this.axis,
                    value = this.value,
                    categories = axis.categories,
                    dateTimeLabelFormat = this.dateTimeLabelFormat,
                    numericSymbols = defaultOptions.lang.numericSymbols,
                    i = numericSymbols && numericSymbols.length,
                    multi,
                    ret,
                    formatOption = axis.options.labels.format,

                    // make sure the same symbol is added for all labels on a linear axis
                    numericSymbolDetector = axis.isLog ? value : axis.tickInterval;

                if (formatOption) {
                    ret = format(formatOption, this);

                } else if (categories) {
                    ret = value;

                } else if (dateTimeLabelFormat) { // datetime axis
                    ret = dateFormat(dateTimeLabelFormat, value);

                } else if (i && numericSymbolDetector >= 1000) {
                    // Decide whether we should add a numeric symbol like k (thousands) or M (millions).
                    // If we are to enable this in tooltip or other places as well, we can move this
                    // logic to the numberFormatter and enable it by a parameter.
                    while (i-- && ret === UNDEFINED) {
                        multi = Math.pow(1000, i + 1);
                        if (numericSymbolDetector >= multi && (value * 10) % multi === 0 && numericSymbols[i] !== null) {
                            ret = Highcharts.numberFormat(value / multi, -1) + numericSymbols[i];
                        }
                    }
                }

                if (ret === UNDEFINED) {
                    if (mathAbs(value) >= 10000) { // add thousands separators
                        ret = Highcharts.numberFormat(value, -1);

                    } else { // small numbers
                        ret = Highcharts.numberFormat(value, -1, UNDEFINED, ''); // #2466
                    }
                }

                return ret;
            },

            /**
             * Get the minimum and maximum for the series of each axis
             */
            getSeriesExtremes: function () {
                var axis = this,
                    chart = axis.chart;

                axis.hasVisibleSeries = false;

                // Reset properties in case we're redrawing (#3353)
                axis.dataMin = axis.dataMax = axis.ignoreMinPadding = axis.ignoreMaxPadding = null;

                if (axis.buildStacks) {
                    axis.buildStacks();
                }

                // loop through this axis' series
                each(axis.series, function (series) {

                    if (series.visible || !chart.options.chart.ignoreHiddenSeries) {

                        var seriesOptions = series.options,
                            xData,
                            threshold = seriesOptions.threshold,
                            seriesDataMin,
                            seriesDataMax;

                        axis.hasVisibleSeries = true;

                        // Validate threshold in logarithmic axes
                        if (axis.isLog && threshold <= 0) {
                            threshold = null;
                        }

                        // Get dataMin and dataMax for X axes
                        if (axis.isXAxis) {
                            xData = series.xData;
                            if (xData.length) {
                                axis.dataMin = mathMin(pick(axis.dataMin, xData[0]), arrayMin(xData));
                                axis.dataMax = mathMax(pick(axis.dataMax, xData[0]), arrayMax(xData));
                            }

                            // Get dataMin and dataMax for Y axes, as well as handle stacking and processed data
                        } else {

                            // Get this particular series extremes
                            series.getExtremes();
                            seriesDataMax = series.dataMax;
                            seriesDataMin = series.dataMin;

                            // Get the dataMin and dataMax so far. If percentage is used, the min and max are
                            // always 0 and 100. If seriesDataMin and seriesDataMax is null, then series
                            // doesn't have active y data, we continue with nulls
                            if (defined(seriesDataMin) && defined(seriesDataMax)) {
                                axis.dataMin = mathMin(pick(axis.dataMin, seriesDataMin), seriesDataMin);
                                axis.dataMax = mathMax(pick(axis.dataMax, seriesDataMax), seriesDataMax);
                            }

                            // Adjust to threshold
                            if (defined(threshold)) {
                                if (axis.dataMin >= threshold) {
                                    axis.dataMin = threshold;
                                    axis.ignoreMinPadding = true;
                                } else if (axis.dataMax < threshold) {
                                    axis.dataMax = threshold;
                                    axis.ignoreMaxPadding = true;
                                }
                            }
                        }
                    }
                });
            },

            /**
             * Translate from axis value to pixel position on the chart, or back
             *
             */
            translate: function (val, backwards, cvsCoord, old, handleLog, pointPlacement) {
                var axis = this.linkedParent || this, // #1417
                    sign = 1,
                    cvsOffset = 0,
                    localA = old ? axis.oldTransA : axis.transA,
                    localMin = old ? axis.oldMin : axis.min,
                    returnValue,
                    minPixelPadding = axis.minPixelPadding,
                    doPostTranslate = (axis.doPostTranslate || (axis.isLog && handleLog)) && axis.lin2val;

                if (!localA) {
                    localA = axis.transA;
                }

                // In vertical axes, the canvas coordinates start from 0 at the top like in
                // SVG.
                if (cvsCoord) {
                    sign *= -1; // canvas coordinates inverts the value
                    cvsOffset = axis.len;
                }

                // Handle reversed axis
                if (axis.reversed) {
                    sign *= -1;
                    cvsOffset -= sign * (axis.sector || axis.len);
                }

                // From pixels to value
                if (backwards) { // reverse translation

                    val = val * sign + cvsOffset;
                    val -= minPixelPadding;
                    returnValue = val / localA + localMin; // from chart pixel to value
                    if (doPostTranslate) { // log and ordinal axes
                        returnValue = axis.lin2val(returnValue);
                    }

                    // From value to pixels
                } else {
                    if (doPostTranslate) { // log and ordinal axes
                        val = axis.val2lin(val);
                    }
                    if (pointPlacement === 'between') {
                        pointPlacement = 0.5;
                    }
                    returnValue = sign * (val - localMin) * localA + cvsOffset + (sign * minPixelPadding) +
                        (isNumber(pointPlacement) ? localA * pointPlacement * axis.pointRange : 0);
                }

                return returnValue;
            },

            /**
             * Utility method to translate an axis value to pixel position.
             * @param {Number} value A value in terms of axis units
             * @param {Boolean} paneCoordinates Whether to return the pixel coordinate relative to the chart
             *        or just the axis/pane itself.
             */
            toPixels: function (value, paneCoordinates) {
                return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);
            },

            /*
             * Utility method to translate a pixel position in to an axis value
             * @param {Number} pixel The pixel value coordinate
             * @param {Boolean} paneCoordiantes Whether the input pixel is relative to the chart or just the
             *        axis/pane itself.
             */
            toValue: function (pixel, paneCoordinates) {
                return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);
            },

            /**
             * Create the path for a plot line that goes from the given value on
             * this axis, across the plot to the opposite side
             * @param {Number} value
             * @param {Number} lineWidth Used for calculation crisp line
             * @param {Number] old Use old coordinates (for resizing and rescaling)
             */
            getPlotLinePath: function (value, lineWidth, old, force, translatedValue) {
                var axis = this,
                    chart = axis.chart,
                    axisLeft = axis.left,
                    axisTop = axis.top,
                    x1,
                    y1,
                    x2,
                    y2,
                    cHeight = (old && chart.oldChartHeight) || chart.chartHeight,
                    cWidth = (old && chart.oldChartWidth) || chart.chartWidth,
                    skip,
                    transB = axis.transB,
                    /**
                     * Check if x is between a and b. If not, either move to a/b or skip, 
                     * depending on the force parameter.
                     */
                    between = function (x, a, b) {
                        if (x < a || x > b) {
                            if (force) {
                                x = mathMin(mathMax(a, x), b);
                            } else {
                                skip = true;
                            }
                        }
                        return x;
                    };

                translatedValue = pick(translatedValue, axis.translate(value, null, null, old));
                x1 = x2 = mathRound(translatedValue + transB);
                y1 = y2 = mathRound(cHeight - translatedValue - transB);

                if (isNaN(translatedValue)) { // no min or max
                    skip = true;

                } else if (axis.horiz) {
                    y1 = axisTop;
                    y2 = cHeight - axis.bottom;
                    x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
                } else {
                    x1 = axisLeft;
                    x2 = cWidth - axis.right;
                    y1 = y2 = between(y1, axisTop, axisTop + axis.height);
                }
                return skip && !force ?
                    null :
                    chart.renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 1);
            },

            /**
             * Set the tick positions of a linear axis to round values like whole tens or every five.
             */
            getLinearTickPositions: function (tickInterval, min, max) {
                var pos,
                    lastPos,
                    roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),
                    roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval),
                    tickPositions = [];

                // For single points, add a tick regardless of the relative position (#2662)
                if (min === max && isNumber(min)) {
                    return [min];
                }

                // Populate the intermediate values
                pos = roundedMin;
                while (pos <= roundedMax) {

                    // Place the tick on the rounded value
                    tickPositions.push(pos);

                    // Always add the raw tickInterval, not the corrected one.
                    pos = correctFloat(pos + tickInterval);

                    // If the interval is not big enough in the current min - max range to actually increase
                    // the loop variable, we need to break out to prevent endless loop. Issue #619
                    if (pos === lastPos) {
                        break;
                    }

                    // Record the last value
                    lastPos = pos;
                }
                return tickPositions;
            },

            /**
             * Return the minor tick positions. For logarithmic axes, reuse the same logic
             * as for major ticks.
             */
            getMinorTickPositions: function () {
                var axis = this,
                    options = axis.options,
                    tickPositions = axis.tickPositions,
                    minorTickInterval = axis.minorTickInterval,
                    minorTickPositions = [],
                    pos,
                    i,
                    min = axis.min,
                    max = axis.max,
                    range = max - min,
                    len;

                // If minor ticks get too dense, they are hard to read, and may cause long running script. So we don't draw them.
                if (range && range / minorTickInterval < axis.len / 3) { // #3875

                    if (axis.isLog) {
                        len = tickPositions.length;
                        for (i = 1; i < len; i++) {
                            minorTickPositions = minorTickPositions.concat(
                                axis.getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true)
                            );
                        }
                    } else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') { // #1314
                        minorTickPositions = minorTickPositions.concat(
                            axis.getTimeTicks(
                                axis.normalizeTimeTickInterval(minorTickInterval),
                                min,
                                max,
                                options.startOfWeek
                            )
                        );
                    } else {
                        for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {
                            minorTickPositions.push(pos);
                        }
                    }
                }

                axis.trimTicks(minorTickPositions); // #3652 #3743
                return minorTickPositions;
            },

            /**
             * Adjust the min and max for the minimum range. Keep in mind that the series data is
             * not yet processed, so we don't have information on data cropping and grouping, or
             * updated axis.pointRange or series.pointRange. The data can't be processed until
             * we have finally established min and max.
             */
            adjustForMinRange: function () {
                var axis = this,
                    options = axis.options,
                    min = axis.min,
                    max = axis.max,
                    zoomOffset,
                    spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange,
                    closestDataRange,
                    i,
                    distance,
                    xData,
                    loopLength,
                    minArgs,
                    maxArgs;

                // Set the automatic minimum range based on the closest point distance
                if (axis.isXAxis && axis.minRange === UNDEFINED && !axis.isLog) {

                    if (defined(options.min) || defined(options.max)) {
                        axis.minRange = null; // don't do this again

                    } else {

                        // Find the closest distance between raw data points, as opposed to
                        // closestPointRange that applies to processed points (cropped and grouped)
                        each(axis.series, function (series) {
                            xData = series.xData;
                            loopLength = series.xIncrement ? 1 : xData.length - 1;
                            for (i = loopLength; i > 0; i--) {
                                distance = xData[i] - xData[i - 1];
                                if (closestDataRange === UNDEFINED || distance < closestDataRange) {
                                    closestDataRange = distance;
                                }
                            }
                        });
                        axis.minRange = mathMin(closestDataRange * 5, axis.dataMax - axis.dataMin);
                    }
                }

                // if minRange is exceeded, adjust
                if (max - min < axis.minRange) {
                    var minRange = axis.minRange;
                    zoomOffset = (minRange - max + min) / 2;

                    // if min and max options have been set, don't go beyond it
                    minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];
                    if (spaceAvailable) { // if space is available, stay within the data range
                        minArgs[2] = axis.dataMin;
                    }
                    min = arrayMax(minArgs);

                    maxArgs = [min + minRange, pick(options.max, min + minRange)];
                    if (spaceAvailable) { // if space is availabe, stay within the data range
                        maxArgs[2] = axis.dataMax;
                    }

                    max = arrayMin(maxArgs);

                    // now if the max is adjusted, adjust the min back
                    if (max - min < minRange) {
                        minArgs[0] = max - minRange;
                        minArgs[1] = pick(options.min, max - minRange);
                        min = arrayMax(minArgs);
                    }
                }

                // Record modified extremes
                axis.min = min;
                axis.max = max;
            },

            /**
             * Update translation information
             */
            setAxisTranslation: function (saveOld) {
                var axis = this,
                    range = axis.max - axis.min,
                    pointRange = axis.axisPointRange || 0,
                    closestPointRange,
                    minPointOffset = 0,
                    pointRangePadding = 0,
                    linkedParent = axis.linkedParent,
                    ordinalCorrection,
                    hasCategories = !!axis.categories,
                    transA = axis.transA,
                    isXAxis = axis.isXAxis;

                // Adjust translation for padding. Y axis with categories need to go through the same (#1784).
                if (isXAxis || hasCategories || pointRange) {
                    if (linkedParent) {
                        minPointOffset = linkedParent.minPointOffset;
                        pointRangePadding = linkedParent.pointRangePadding;

                    } else {
                        each(axis.series, function (series) {
                            var seriesPointRange = hasCategories ? 1 : (isXAxis ? series.pointRange : (axis.axisPointRange || 0)), // #2806
                                pointPlacement = series.options.pointPlacement,
                                seriesClosestPointRange = series.closestPointRange;

                            if (seriesPointRange > range) { // #1446
                                seriesPointRange = 0;
                            }
                            pointRange = mathMax(pointRange, seriesPointRange);

                            if (!axis.single) {
                                // minPointOffset is the value padding to the left of the axis in order to make
                                // room for points with a pointRange, typically columns. When the pointPlacement option
                                // is 'between' or 'on', this padding does not apply.
                                minPointOffset = mathMax(
                                    minPointOffset,
                                    isString(pointPlacement) ? 0 : seriesPointRange / 2
                                );

                                // Determine the total padding needed to the length of the axis to make room for the
                                // pointRange. If the series' pointPlacement is 'on', no padding is added.
                                pointRangePadding = mathMax(
                                    pointRangePadding,
                                    pointPlacement === 'on' ? 0 : seriesPointRange
                                );
                            }

                            // Set the closestPointRange
                            if (!series.noSharedTooltip && defined(seriesClosestPointRange)) {
                                closestPointRange = defined(closestPointRange) ?
                                    mathMin(closestPointRange, seriesClosestPointRange) :
                                    seriesClosestPointRange;
                            }
                        });
                    }

                    // Record minPointOffset and pointRangePadding
                    ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853
                    axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
                    axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;

                    // pointRange means the width reserved for each point, like in a column chart
                    axis.pointRange = mathMin(pointRange, range);

                    // closestPointRange means the closest distance between points. In columns
                    // it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange
                    // is some other value
                    if (isXAxis) {
                        axis.closestPointRange = closestPointRange;
                    }
                }

                // Secondary values
                if (saveOld) {
                    axis.oldTransA = transA;
                }
                axis.translationSlope = axis.transA = transA = axis.len / ((range + pointRangePadding) || 1);
                axis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend
                axis.minPixelPadding = transA * minPointOffset;
            },

            /**
             * Set the tick positions to round values and optionally extend the extremes
             * to the nearest tick
             */
            setTickInterval: function (secondPass) {
                var axis = this,
                    chart = axis.chart,
                    options = axis.options,
                    isLog = axis.isLog,
                    isDatetimeAxis = axis.isDatetimeAxis,
                    isXAxis = axis.isXAxis,
                    isLinked = axis.isLinked,
                    maxPadding = options.maxPadding,
                    minPadding = options.minPadding,
                    length,
                    linkedParentExtremes,
                    tickIntervalOption = options.tickInterval,
                    minTickInterval,
                    tickPixelIntervalOption = options.tickPixelInterval,
                    categories = axis.categories;

                if (!isDatetimeAxis && !categories && !isLinked) {
                    this.getTickAmount();
                }

                // linked axis gets the extremes from the parent axis
                if (isLinked) {
                    axis.linkedParent = chart[axis.coll][options.linkedTo];
                    linkedParentExtremes = axis.linkedParent.getExtremes();
                    axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
                    axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
                    if (options.type !== axis.linkedParent.options.type) {
                        error(11, 1); // Can't link axes of different type
                    }
                } else { // initial min and max from the extreme data values
                    axis.min = pick(axis.userMin, options.min, axis.dataMin);
                    axis.max = pick(axis.userMax, options.max, axis.dataMax);
                }

                if (isLog) {
                    if (!secondPass && mathMin(axis.min, pick(axis.dataMin, axis.min)) <= 0) { // #978
                        error(10, 1); // Can't plot negative values on log axis
                    }
                    axis.min = correctFloat(log2lin(axis.min)); // correctFloat cures #934
                    axis.max = correctFloat(log2lin(axis.max));
                }

                // handle zoomed range
                if (axis.range && defined(axis.max)) {
                    axis.userMin = axis.min = mathMax(axis.min, axis.max - axis.range); // #618
                    axis.userMax = axis.max;

                    axis.range = null;  // don't use it when running setExtremes
                }

                // Hook for adjusting this.min and this.max. Used by bubble series.
                if (axis.beforePadding) {
                    axis.beforePadding();
                }

                // adjust min and max for the minimum range
                axis.adjustForMinRange();

                // Pad the values to get clear of the chart's edges. To avoid tickInterval taking the padding
                // into account, we do this after computing tick interval (#1337).
                if (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {
                    length = axis.max - axis.min;
                    if (length) {
                        if (!defined(options.min) && !defined(axis.userMin) && minPadding && (axis.dataMin < 0 || !axis.ignoreMinPadding)) {
                            axis.min -= length * minPadding;
                        }
                        if (!defined(options.max) && !defined(axis.userMax) && maxPadding && (axis.dataMax > 0 || !axis.ignoreMaxPadding)) {
                            axis.max += length * maxPadding;
                        }
                    }
                }

                // Stay within floor and ceiling
                if (isNumber(options.floor)) {
                    axis.min = mathMax(axis.min, options.floor);
                }
                if (isNumber(options.ceiling)) {
                    axis.max = mathMin(axis.max, options.ceiling);
                }

                // get tickInterval
                if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {
                    axis.tickInterval = 1;
                } else if (isLinked && !tickIntervalOption &&
                        tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
                    axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;
                } else {
                    axis.tickInterval = pick(
                        tickIntervalOption,
                        this.tickAmount ? ((axis.max - axis.min) / mathMax(this.tickAmount - 1, 1)) : undefined,
                        categories ? // for categoried axis, 1 is default, for linear axis use tickPix
                            1 :
                            // don't let it be more than the data range
                            (axis.max - axis.min) * tickPixelIntervalOption / mathMax(axis.len, tickPixelIntervalOption)
                    );
                }

                // Now we're finished detecting min and max, crop and group series data. This
                // is in turn needed in order to find tick positions in ordinal axes.
                if (isXAxis && !secondPass) {
                    each(axis.series, function (series) {
                        series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);
                    });
                }

                // set the translation factor used in translate function
                axis.setAxisTranslation(true);

                // hook for ordinal axes and radial axes
                if (axis.beforeSetTickPositions) {
                    axis.beforeSetTickPositions();
                }

                // hook for extensions, used in Highstock ordinal axes
                if (axis.postProcessTickInterval) {
                    axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);
                }

                // In column-like charts, don't cramp in more ticks than there are points (#1943)
                if (axis.pointRange) {
                    axis.tickInterval = mathMax(axis.pointRange, axis.tickInterval);
                }

                // Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.
                minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);
                if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
                    axis.tickInterval = minTickInterval;
                }

                // for linear axes, get magnitude and normalize the interval
                if (!isDatetimeAxis && !isLog && !tickIntervalOption) {
                    axis.tickInterval = normalizeTickInterval(
                        axis.tickInterval,
                        null,
                        getMagnitude(axis.tickInterval),
                        // If the tick interval is between 0.5 and 5 and the axis max is in the order of
                        // thousands, chances are we are dealing with years. Don't allow decimals. #3363.
                        pick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)),
                        !!this.tickAmount
                    );
                }

                // Prevent ticks from getting so close that we can't draw the labels
                if (!this.tickAmount && this.len) { // Color axis with disabled legend has no length
                    axis.tickInterval = axis.unsquish();
                }

                this.setTickPositions();
            },

            /**
             * Now we have computed the normalized tickInterval, get the tick positions
             */
            setTickPositions: function () {

                var options = this.options,
                    tickPositions,
                    tickPositionsOption = options.tickPositions,
                    tickPositioner = options.tickPositioner,
                    startOnTick = options.startOnTick,
                    endOnTick = options.endOnTick,
                    single;

                // Set the tickmarkOffset
                this.tickmarkOffset = (this.categories && options.tickmarkPlacement === 'between' &&
                    this.tickInterval === 1) ? 0.5 : 0; // #3202


                // get minorTickInterval
                this.minorTickInterval = options.minorTickInterval === 'auto' && this.tickInterval ?
                    this.tickInterval / 5 : options.minorTickInterval;

                // Find the tick positions
                this.tickPositions = tickPositions = tickPositionsOption && tickPositionsOption.slice(); // Work on a copy (#1565)
                if (!tickPositions) {

                    if (this.isDatetimeAxis) {
                        tickPositions = this.getTimeTicks(
                            this.normalizeTimeTickInterval(this.tickInterval, options.units),
                            this.min,
                            this.max,
                            options.startOfWeek,
                            this.ordinalPositions,
                            this.closestPointRange,
                            true
                        );
                    } else if (this.isLog) {
                        tickPositions = this.getLogTickPositions(this.tickInterval, this.min, this.max);
                    } else {
                        tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);
                    }

                    this.tickPositions = tickPositions;

                    // Run the tick positioner callback, that allows modifying auto tick positions.
                    if (tickPositioner) {
                        tickPositioner = tickPositioner.apply(this, [this.min, this.max]);
                        if (tickPositioner) {
                            this.tickPositions = tickPositions = tickPositioner;
                        }
                    }

                }

                if (!this.isLinked) {

                    // reset min/max or remove extremes based on start/end on tick
                    this.trimTicks(tickPositions, startOnTick, endOnTick);

                    // When there is only one point, or all points have the same value on this axis, then min
                    // and max are equal and tickPositions.length is 0 or 1. In this case, add some padding
                    // in order to center the point, but leave it with one tick. #1337.
                    if (this.min === this.max && defined(this.min) && !this.tickAmount) {
                        // Substract half a unit (#2619, #2846, #2515, #3390)
                        single = true;
                        this.min -= 0.5;
                        this.max += 0.5;
                    }
                    this.single = single;

                    if (!tickPositionsOption && !tickPositioner) {
                        this.adjustTickAmount();
                    }
                }
            },

            /**
             * Handle startOnTick and endOnTick by either adapting to padding min/max or rounded min/max
             */
            trimTicks: function (tickPositions, startOnTick, endOnTick) {
                var roundedMin = tickPositions[0],
                    roundedMax = tickPositions[tickPositions.length - 1],
                    minPointOffset = this.minPointOffset || 0;

                if (startOnTick) {
                    this.min = roundedMin;
                } else if (this.min - minPointOffset > roundedMin) {
                    tickPositions.shift();
                }

                if (endOnTick) {
                    this.max = roundedMax;
                } else if (this.max + minPointOffset < roundedMax) {
                    tickPositions.pop();
                }

                // If no tick are left, set one tick in the middle (#3195) 
                if (tickPositions.length === 0 && defined(roundedMin)) {
                    tickPositions.push((roundedMax + roundedMin) / 2);
                }
            },

            /**
             * Set the max ticks of either the x and y axis collection
             */
            getTickAmount: function () {
                var others = {}, // Whether there is another axis to pair with this one
                    hasOther,
                    options = this.options,
                    tickAmount = options.tickAmount,
                    tickPixelInterval = options.tickPixelInterval;

                if (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial &&
                        !this.isLog && options.startOnTick && options.endOnTick) {
                    tickAmount = 2;
                }

                if (!tickAmount && this.chart.options.chart.alignTicks !== false && options.alignTicks !== false) {
                    // Check if there are multiple axes in the same pane
                    each(this.chart[this.coll], function (axis) {
                        var options = axis.options,
                            horiz = axis.horiz,
                            key = [horiz ? options.left : options.top, horiz ? options.width : options.height, options.pane].join(',');

                        if (others[key]) {
                            if (axis.series.length) {
                                hasOther = true; // #4201
                            }
                        } else {
                            others[key] = 1;
                        }
                    });

                    if (hasOther) {
                        // Add 1 because 4 tick intervals require 5 ticks (including first and last)
                        tickAmount = mathCeil(this.len / tickPixelInterval) + 1;
                    }
                }

                // For tick amounts of 2 and 3, compute five ticks and remove the intermediate ones. This
                // prevents the axis from adding ticks that are too far away from the data extremes.
                if (tickAmount < 4) {
                    this.finalTickAmt = tickAmount;
                    tickAmount = 5;
                }

                this.tickAmount = tickAmount;
            },

            /**
             * When using multiple axes, adjust the number of ticks to match the highest
             * number of ticks in that group
             */
            adjustTickAmount: function () {
                var tickInterval = this.tickInterval,
                    tickPositions = this.tickPositions,
                    tickAmount = this.tickAmount,
                    finalTickAmt = this.finalTickAmt,
                    currentTickAmount = tickPositions && tickPositions.length,
                    i,
                    len;

                if (currentTickAmount < tickAmount) { // TODO: Check #3411
                    while (tickPositions.length < tickAmount) {
                        tickPositions.push(correctFloat(
                            tickPositions[tickPositions.length - 1] + tickInterval
                        ));
                    }
                    this.transA *= (currentTickAmount - 1) / (tickAmount - 1);
                    this.max = tickPositions[tickPositions.length - 1];

                    // We have too many ticks, run second pass to try to reduce ticks
                } else if (currentTickAmount > tickAmount) {
                    this.tickInterval *= 2;
                    this.setTickPositions();
                }

                // The finalTickAmt property is set in getTickAmount
                if (defined(finalTickAmt)) {
                    i = len = tickPositions.length;
                    while (i--) {
                        if (
                            (finalTickAmt === 3 && i % 2 === 1) || // Remove every other tick
                            (finalTickAmt <= 2 && i > 0 && i < len - 1) // Remove all but first and last
                        ) {
                            tickPositions.splice(i, 1);
                        }
                    }
                    this.finalTickAmt = UNDEFINED;
                }
            },

            /**
             * Set the scale based on data min and max, user set min and max or options
             *
             */
            setScale: function () {
                var axis = this,
                    stacks = axis.stacks,
                    type,
                    i,
                    isDirtyData,
                    isDirtyAxisLength;

                axis.oldMin = axis.min;
                axis.oldMax = axis.max;
                axis.oldAxisLength = axis.len;

                // set the new axisLength
                axis.setAxisSize();
                //axisLength = horiz ? axisWidth : axisHeight;
                isDirtyAxisLength = axis.len !== axis.oldAxisLength;

                // is there new data?
                each(axis.series, function (series) {
                    if (series.isDirtyData || series.isDirty ||
                            series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well
                        isDirtyData = true;
                    }
                });

                // do we really need to go through all this?
                if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||
                    axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax) {

                    // reset stacks
                    if (!axis.isXAxis) {
                        for (type in stacks) {
                            for (i in stacks[type]) {
                                stacks[type][i].total = null;
                                stacks[type][i].cum = 0;
                            }
                        }
                    }

                    axis.forceRedraw = false;

                    // get data extremes if needed
                    axis.getSeriesExtremes();

                    // get fixed positions based on tickInterval
                    axis.setTickInterval();

                    // record old values to decide whether a rescale is necessary later on (#540)
                    axis.oldUserMin = axis.userMin;
                    axis.oldUserMax = axis.userMax;

                    // Mark as dirty if it is not already set to dirty and extremes have changed. #595.
                    if (!axis.isDirty) {
                        axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;
                    }
                } else if (!axis.isXAxis) {
                    if (axis.oldStacks) {
                        stacks = axis.stacks = axis.oldStacks;
                    }

                    // reset stacks
                    for (type in stacks) {
                        for (i in stacks[type]) {
                            stacks[type][i].cum = stacks[type][i].total;
                        }
                    }
                }
            },

            /**
             * Set the extremes and optionally redraw
             * @param {Number} newMin
             * @param {Number} newMax
             * @param {Boolean} redraw
             * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
             *    configuration
             * @param {Object} eventArguments
             *
             */
            setExtremes: function (newMin, newMax, redraw, animation, eventArguments) {
                var axis = this,
                    chart = axis.chart;

                redraw = pick(redraw, true); // defaults to true

                each(axis.series, function (serie) {
                    delete serie.kdTree;
                });

                // Extend the arguments with min and max
                eventArguments = extend(eventArguments, {
                    min: newMin,
                    max: newMax
                });

                // Fire the event
                fireEvent(axis, 'setExtremes', eventArguments, function () { // the default event handler

                    axis.userMin = newMin;
                    axis.userMax = newMax;
                    axis.eventArgs = eventArguments;

                    // Mark for running afterSetExtremes
                    axis.isDirtyExtremes = true;

                    // redraw
                    if (redraw) {
                        chart.redraw(animation);
                    }
                });
            },

            /**
             * Overridable method for zooming chart. Pulled out in a separate method to allow overriding
             * in stock charts.
             */
            zoom: function (newMin, newMax) {
                var dataMin = this.dataMin,
                    dataMax = this.dataMax,
                    options = this.options;

                // Prevent pinch zooming out of range. Check for defined is for #1946. #1734.
                if (!this.allowZoomOutside) {
                    if (defined(dataMin) && newMin <= mathMin(dataMin, pick(options.min, dataMin))) {
                        newMin = UNDEFINED;
                    }
                    if (defined(dataMax) && newMax >= mathMax(dataMax, pick(options.max, dataMax))) {
                        newMax = UNDEFINED;
                    }
                }

                // In full view, displaying the reset zoom button is not required
                this.displayBtn = newMin !== UNDEFINED || newMax !== UNDEFINED;

                // Do it
                this.setExtremes(
                    newMin,
                    newMax,
                    false,
                    UNDEFINED,
                    { trigger: 'zoom' }
                );
                return true;
            },

            /**
             * Update the axis metrics
             */
            setAxisSize: function () {
                var chart = this.chart,
                    options = this.options,
                    offsetLeft = options.offsetLeft || 0,
                    offsetRight = options.offsetRight || 0,
                    horiz = this.horiz,
                    width = pick(options.width, chart.plotWidth - offsetLeft + offsetRight),
                    height = pick(options.height, chart.plotHeight),
                    top = pick(options.top, chart.plotTop),
                    left = pick(options.left, chart.plotLeft + offsetLeft),
                    percentRegex = /%$/;

                // Check for percentage based input values
                if (percentRegex.test(height)) {
                    height = parseFloat(height) / 100 * chart.plotHeight;
                }
                if (percentRegex.test(top)) {
                    top = parseFloat(top) / 100 * chart.plotHeight + chart.plotTop;
                }

                // Expose basic values to use in Series object and navigator
                this.left = left;
                this.top = top;
                this.width = width;
                this.height = height;
                this.bottom = chart.chartHeight - height - top;
                this.right = chart.chartWidth - width - left;

                // Direction agnostic properties
                this.len = mathMax(horiz ? width : height, 0); // mathMax fixes #905
                this.pos = horiz ? left : top; // distance from SVG origin
            },

            /**
             * Get the actual axis extremes
             */
            getExtremes: function () {
                var axis = this,
                    isLog = axis.isLog;

                return {
                    min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,
                    max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,
                    dataMin: axis.dataMin,
                    dataMax: axis.dataMax,
                    userMin: axis.userMin,
                    userMax: axis.userMax
                };
            },

            /**
             * Get the zero plane either based on zero or on the min or max value.
             * Used in bar and area plots
             */
            getThreshold: function (threshold) {
                var axis = this,
                    isLog = axis.isLog,
                    realMin = isLog ? lin2log(axis.min) : axis.min,
                    realMax = isLog ? lin2log(axis.max) : axis.max;

                // With a threshold of null, make the columns/areas rise from the top or bottom 
                // depending on the value, assuming an actual threshold of 0 (#4233).
                if (threshold === null) {
                    threshold = realMax < 0 ? realMax : realMin;
                } else if (realMin > threshold) {
                    threshold = realMin;
                } else if (realMax < threshold) {
                    threshold = realMax;
                }

                return axis.translate(threshold, 0, 1, 0, 1);
            },

            /**
             * Compute auto alignment for the axis label based on which side the axis is on
             * and the given rotation for the label
             */
            autoLabelAlign: function (rotation) {
                var ret,
                    angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;

                if (angle > 15 && angle < 165) {
                    ret = 'right';
                } else if (angle > 195 && angle < 345) {
                    ret = 'left';
                } else {
                    ret = 'center';
                }
                return ret;
            },

            /**
             * Prevent the ticks from getting so close we can't draw the labels. On a horizontal
             * axis, this is handled by rotating the labels, removing ticks and adding ellipsis. 
             * On a vertical axis remove ticks and add ellipsis.
             */
            unsquish: function () {
                var chart = this.chart,
                    ticks = this.ticks,
                    labelOptions = this.options.labels,
                    horiz = this.horiz,
                    tickInterval = this.tickInterval,
                    newTickInterval = tickInterval,
                    slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),
                    rotation,
                    rotationOption = labelOptions.rotation,
                    labelMetrics = chart.renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),
                    step,
                    bestScore = Number.MAX_VALUE,
                    autoRotation,
                    // Return the multiple of tickInterval that is needed to avoid collision
                    getStep = function (spaceNeeded) {
                        var step = spaceNeeded / (slotSize || 1);
                        step = step > 1 ? mathCeil(step) : 1;
                        return step * tickInterval;
                    };

                if (horiz) {
                    autoRotation = defined(rotationOption) ?
                        [rotationOption] :
                        slotSize < pick(labelOptions.autoRotationLimit, 80) && !labelOptions.staggerLines && !labelOptions.step && labelOptions.autoRotation;

                    if (autoRotation) {

                        // Loop over the given autoRotation options, and determine which gives the best score. The 
                        // best score is that with the lowest number of steps and a rotation closest to horizontal.
                        each(autoRotation, function (rot) {
                            var score;

                            if (rot === rotationOption || (rot && rot >= -90 && rot <= 90)) { // #3891

                                step = getStep(mathAbs(labelMetrics.h / mathSin(deg2rad * rot)));

                                score = step + mathAbs(rot / 360);

                                if (score < bestScore) {
                                    bestScore = score;
                                    rotation = rot;
                                    newTickInterval = step;
                                }
                            }
                        });
                    }

                } else {
                    newTickInterval = getStep(labelMetrics.h);
                }

                this.autoRotation = autoRotation;
                this.labelRotation = rotation;

                return newTickInterval;
            },

            renderUnsquish: function () {
                var chart = this.chart,
                    renderer = chart.renderer,
                    tickPositions = this.tickPositions,
                    ticks = this.ticks,
                    labelOptions = this.options.labels,
                    horiz = this.horiz,
                    margin = chart.margin,
                    slotCount = this.categories ? tickPositions.length : tickPositions.length - 1,
                    slotWidth = this.slotWidth = (horiz && !labelOptions.step && !labelOptions.rotation &&
                        ((this.staggerLines || 1) * chart.plotWidth) / slotCount) ||
                        (!horiz && ((margin[3] && (margin[3] - chart.spacing[3])) || chart.chartWidth * 0.33)), // #1580, #1931,
                    innerWidth = mathMax(1, mathRound(slotWidth - 2 * (labelOptions.padding || 5))),
                    attr = {},
                    labelMetrics = renderer.fontMetrics(labelOptions.style.fontSize, ticks[0] && ticks[0].label),
                    textOverflowOption = labelOptions.style.textOverflow,
                    css,
                    labelLength = 0,
                    label,
                    i,
                    pos;

                // Set rotation option unless it is "auto", like in gauges
                if (!isString(labelOptions.rotation)) {
                    attr.rotation = labelOptions.rotation;
                }

                // Handle auto rotation on horizontal axis
                if (this.autoRotation) {

                    // Get the longest label length
                    each(tickPositions, function (tick) {
                        tick = ticks[tick];
                        if (tick && tick.labelLength > labelLength) {
                            labelLength = tick.labelLength;
                        }
                    });

                    // Apply rotation only if the label is too wide for the slot, and
                    // the label is wider than its height.
                    if (labelLength > innerWidth && labelLength > labelMetrics.h) {
                        attr.rotation = this.labelRotation;
                    } else {
                        this.labelRotation = 0;
                    }

                    // Handle word-wrap or ellipsis on vertical axis
                } else if (slotWidth) {
                    // For word-wrap or ellipsis
                    css = { width: innerWidth + PX };

                    if (!textOverflowOption) {
                        css.textOverflow = 'clip';

                        // On vertical axis, only allow word wrap if there is room for more lines.
                        i = tickPositions.length;
                        while (!horiz && i--) {
                            pos = tickPositions[i];
                            label = ticks[pos].label;
                            if (label) {
                                // Reset ellipsis in order to get the correct bounding box (#4070)
                                if (label.styles.textOverflow === 'ellipsis') {
                                    label.css({ textOverflow: 'clip' });
                                }
                                if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {
                                    label.specCss = { textOverflow: 'ellipsis' };
                                }
                            }
                        }
                    }
                }


                // Add ellipsis if the label length is significantly longer than ideal
                if (attr.rotation) {
                    css = {
                        width: (labelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : chart.chartHeight) + PX
                    };
                    if (!textOverflowOption) {
                        css.textOverflow = 'ellipsis';
                    }
                }

                // Set the explicit or automatic label alignment
                this.labelAlign = attr.align = labelOptions.align || this.autoLabelAlign(this.labelRotation);

                // Apply general and specific CSS
                each(tickPositions, function (pos) {
                    var tick = ticks[pos],
                        label = tick && tick.label;
                    if (label) {
                        if (css) {
                            label.css(merge(css, label.specCss));
                        }
                        delete label.specCss;
                        label.attr(attr);
                        tick.rotation = attr.rotation;
                    }
                });

                // TODO: Why not part of getLabelPosition?
                this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side === 2);
            },

            /**
             * Return true if the axis has associated data
             */
            hasData: function () {
                return this.hasVisibleSeries || (defined(this.min) && defined(this.max) && !!this.tickPositions);
            },

            /**
             * Render the tick labels to a preliminary position to get their sizes
             */
            getOffset: function () {
                var axis = this,
                    chart = axis.chart,
                    renderer = chart.renderer,
                    options = axis.options,
                    tickPositions = axis.tickPositions,
                    ticks = axis.ticks,
                    horiz = axis.horiz,
                    side = axis.side,
                    invertedSide = chart.inverted ? [1, 0, 3, 2][side] : side,
                    hasData,
                    showAxis,
                    titleOffset = 0,
                    titleOffsetOption,
                    titleMargin = 0,
                    axisTitleOptions = options.title,
                    labelOptions = options.labels,
                    labelOffset = 0, // reset
                    labelOffsetPadded,
                    axisOffset = chart.axisOffset,
                    clipOffset = chart.clipOffset,
                    clip,
                    directionFactor = [-1, 1, 1, -1][side],
                    n,
                    lineHeightCorrection;

                // For reuse in Axis.render
                hasData = axis.hasData();
                axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);

                // Set/reset staggerLines
                axis.staggerLines = axis.horiz && labelOptions.staggerLines;

                // Create the axisGroup and gridGroup elements on first iteration
                if (!axis.axisGroup) {
                    axis.gridGroup = renderer.g('grid')
                        .attr({ zIndex: options.gridZIndex || 1 })
                        .add();
                    axis.axisGroup = renderer.g('axis')
                        .attr({ zIndex: options.zIndex || 2 })
                        .add();
                    axis.labelGroup = renderer.g('axis-labels')
                        .attr({ zIndex: labelOptions.zIndex || 7 })
                        .addClass(PREFIX + axis.coll.toLowerCase() + '-labels')
                        .add();
                }

                if (hasData || axis.isLinked) {

                    // Generate ticks
                    each(tickPositions, function (pos) {
                        if (!ticks[pos]) {
                            ticks[pos] = new Tick(axis, pos);
                        } else {
                            ticks[pos].addLabel(); // update labels depending on tick interval
                        }
                    });

                    axis.renderUnsquish();

                    each(tickPositions, function (pos) {
                        // left side must be align: right and right side must have align: left for labels
                        if (side === 0 || side === 2 || { 1: 'left', 3: 'right' }[side] === axis.labelAlign) {

                            // get the highest offset
                            labelOffset = mathMax(
                                ticks[pos].getLabelSize(),
                                labelOffset
                            );
                        }
                    });

                    if (axis.staggerLines) {
                        labelOffset *= axis.staggerLines;
                        axis.labelOffset = labelOffset;
                    }


                } else { // doesn't have data
                    for (n in ticks) {
                        ticks[n].destroy();
                        delete ticks[n];
                    }
                }

                if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {
                    if (!axis.axisTitle) {
                        axis.axisTitle = renderer.text(
                            axisTitleOptions.text,
                            0,
                            0,
                            axisTitleOptions.useHTML
                        )
                        .attr({
                            zIndex: 7,
                            rotation: axisTitleOptions.rotation || 0,
                            align:
                                axisTitleOptions.textAlign ||
                                { low: 'left', middle: 'center', high: 'right' }[axisTitleOptions.align]
                        })
                        .addClass(PREFIX + this.coll.toLowerCase() + '-title')
                        .css(axisTitleOptions.style)
                        .add(axis.axisGroup);
                        axis.axisTitle.isNew = true;
                    }

                    if (showAxis) {
                        titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
                        titleOffsetOption = axisTitleOptions.offset;
                        titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);
                    }

                    // hide or show the title depending on whether showEmpty is set
                    axis.axisTitle[showAxis ? 'show' : 'hide']();
                }

                // handle automatic or user set offset
                axis.offset = directionFactor * pick(options.offset, axisOffset[side]);

                axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 }; // polar
                lineHeightCorrection = side === 2 ? axis.tickRotCorr.y : 0;
                labelOffsetPadded = labelOffset + titleMargin +
                    (labelOffset && (directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + 8) : labelOptions.x) - lineHeightCorrection));
                axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);

                axisOffset[side] = mathMax(
                    axisOffset[side],
                    axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,
                    labelOffsetPadded // #3027
                );

                // Decide the clipping needed to keep the graph inside the plot area and axis lines
                clip = mathFloor(options.lineWidth / 2) * 2;
                if (options.offset) {
                    clip = mathMax(0, clip - options.offset);
                }
                clipOffset[invertedSide] = mathMax(clipOffset[invertedSide], clip);
            },

            /**
             * Get the path for the axis line
             */
            getLinePath: function (lineWidth) {
                var chart = this.chart,
                    opposite = this.opposite,
                    offset = this.offset,
                    horiz = this.horiz,
                    lineLeft = this.left + (opposite ? this.width : 0) + offset,
                    lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;

                if (opposite) {
                    lineWidth *= -1; // crispify the other way - #1480, #1687
                }

                return chart.renderer.crispLine([
                        M,
                        horiz ?
                            this.left :
                            lineLeft,
                        horiz ?
                    lineTop :
                            this.top,
                        L,
                        horiz ?
                            chart.chartWidth - this.right :
                            lineLeft,
                        horiz ?
                    lineTop :
                            chart.chartHeight - this.bottom
                ], lineWidth);
            },

            /**
             * Position the title
             */
            getTitlePosition: function () {
                // compute anchor points for each of the title align options
                var horiz = this.horiz,
                    axisLeft = this.left,
                    axisTop = this.top,
                    axisLength = this.len,
                    axisTitleOptions = this.options.title,
                    margin = horiz ? axisLeft : axisTop,
                    opposite = this.opposite,
                    offset = this.offset,
                    xOption = axisTitleOptions.x || 0,
                    yOption = axisTitleOptions.y || 0,
                    fontSize = pInt(axisTitleOptions.style.fontSize || 12),

                    // the position in the length direction of the axis
                    alongAxis = {
                        low: margin + (horiz ? 0 : axisLength),
                        middle: margin + axisLength / 2,
                        high: margin + (horiz ? axisLength : 0)
                    }[axisTitleOptions.align],

                    // the position in the perpendicular direction of the axis
                    offAxis = (horiz ? axisTop + this.height : axisLeft) +
                        (horiz ? 1 : -1) * // horizontal axis reverses the margin
                        (opposite ? -1 : 1) * // so does opposite axes
                        this.axisTitleMargin +
                        (this.side === 2 ? fontSize : 0);

                return {
                    x: horiz ?
                        alongAxis + xOption :
                        offAxis + (opposite ? this.width : 0) + offset + xOption,
                    y: horiz ?
                        offAxis + yOption - (opposite ? this.height : 0) + offset :
                        alongAxis + yOption
                };
            },

            /**
             * Render the axis
             */
            render: function () {
                var axis = this,
                    chart = axis.chart,
                    renderer = chart.renderer,
                    options = axis.options,
                    isLog = axis.isLog,
                    isLinked = axis.isLinked,
                    tickPositions = axis.tickPositions,
                    axisTitle = axis.axisTitle,
                    ticks = axis.ticks,
                    minorTicks = axis.minorTicks,
                    alternateBands = axis.alternateBands,
                    stackLabelOptions = options.stackLabels,
                    alternateGridColor = options.alternateGridColor,
                    tickmarkOffset = axis.tickmarkOffset,
                    lineWidth = options.lineWidth,
                    linePath,
                    hasRendered = chart.hasRendered,
                    slideInTicks = hasRendered && defined(axis.oldMin) && !isNaN(axis.oldMin),
                    showAxis = axis.showAxis,
                    from,
                    to;

                // Reset
                axis.labelEdge.length = 0;
                //axis.justifyToPlot = overflow === 'justify';
                axis.overlap = false;

                // Mark all elements inActive before we go over and mark the active ones
                each([ticks, minorTicks, alternateBands], function (coll) {
                    var pos;
                    for (pos in coll) {
                        coll[pos].isActive = false;
                    }
                });

                // If the series has data draw the ticks. Else only the line and title
                if (axis.hasData() || isLinked) {

                    // minor ticks
                    if (axis.minorTickInterval && !axis.categories) {
                        each(axis.getMinorTickPositions(), function (pos) {
                            if (!minorTicks[pos]) {
                                minorTicks[pos] = new Tick(axis, pos, 'minor');
                            }

                            // render new ticks in old position
                            if (slideInTicks && minorTicks[pos].isNew) {
                                minorTicks[pos].render(null, true);
                            }

                            minorTicks[pos].render(null, false, 1);
                        });
                    }

                    // Major ticks. Pull out the first item and render it last so that
                    // we can get the position of the neighbour label. #808.
                    if (tickPositions.length) { // #1300
                        each(tickPositions, function (pos, i) {

                            // linked axes need an extra check to find out if
                            if (!isLinked || (pos >= axis.min && pos <= axis.max)) {

                                if (!ticks[pos]) {
                                    ticks[pos] = new Tick(axis, pos);
                                }

                                // render new ticks in old position
                                if (slideInTicks && ticks[pos].isNew) {
                                    ticks[pos].render(i, true, 0.1);
                                }

                                ticks[pos].render(i);
                            }

                        });
                        // In a categorized axis, the tick marks are displayed between labels. So
                        // we need to add a tick mark and grid line at the left edge of the X axis.
                        if (tickmarkOffset && (axis.min === 0 || axis.single)) {
                            if (!ticks[-1]) {
                                ticks[-1] = new Tick(axis, -1, null, true);
                            }
                            ticks[-1].render(-1);
                        }

                    }

                    // alternate grid color
                    if (alternateGridColor) {
                        each(tickPositions, function (pos, i) {
                            if (i % 2 === 0 && pos < axis.max) {
                                if (!alternateBands[pos]) {
                                    alternateBands[pos] = new Highcharts.PlotLineOrBand(axis);
                                }
                                from = pos + tickmarkOffset; // #949
                                to = tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] + tickmarkOffset : axis.max;
                                alternateBands[pos].options = {
                                    from: isLog ? lin2log(from) : from,
                                    to: isLog ? lin2log(to) : to,
                                    color: alternateGridColor
                                };
                                alternateBands[pos].render();
                                alternateBands[pos].isActive = true;
                            }
                        });
                    }

                    // custom plot lines and bands
                    if (!axis._addedPlotLB) { // only first time
                        each((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {
                            axis.addPlotBandOrLine(plotLineOptions);
                        });
                        axis._addedPlotLB = true;
                    }

                } // end if hasData

                // Remove inactive ticks
                each([ticks, minorTicks, alternateBands], function (coll) {
                    var pos,
                        i,
                        forDestruction = [],
                        delay = globalAnimation ? globalAnimation.duration || 500 : 0,
                        destroyInactiveItems = function () {
                            i = forDestruction.length;
                            while (i--) {
                                // When resizing rapidly, the same items may be destroyed in different timeouts,
                                // or the may be reactivated
                                if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
                                    coll[forDestruction[i]].destroy();
                                    delete coll[forDestruction[i]];
                                }
                            }

                        };

                    for (pos in coll) {

                        if (!coll[pos].isActive) {
                            // Render to zero opacity
                            coll[pos].render(pos, false, 0);
                            coll[pos].isActive = false;
                            forDestruction.push(pos);
                        }
                    }

                    // When the objects are finished fading out, destroy them
                    if (coll === alternateBands || !chart.hasRendered || !delay) {
                        destroyInactiveItems();
                    } else if (delay) {
                        setTimeout(destroyInactiveItems, delay);
                    }
                });

                // Static items. As the axis group is cleared on subsequent calls
                // to render, these items are added outside the group.
                // axis line
                if (lineWidth) {
                    linePath = axis.getLinePath(lineWidth);
                    if (!axis.axisLine) {
                        axis.axisLine = renderer.path(linePath)
                            .attr({
                                stroke: options.lineColor,
                                'stroke-width': lineWidth,
                                zIndex: 7
                            })
                            .add(axis.axisGroup);
                    } else {
                        axis.axisLine.animate({ d: linePath });
                    }

                    // show or hide the line depending on options.showEmpty
                    axis.axisLine[showAxis ? 'show' : 'hide']();
                }

                if (axisTitle && showAxis) {

                    axisTitle[axisTitle.isNew ? 'attr' : 'animate'](
                        axis.getTitlePosition()
                    );
                    axisTitle.isNew = false;
                }

                // Stacked totals:
                if (stackLabelOptions && stackLabelOptions.enabled) {
                    axis.renderStackTotals();
                }
                // End stacked totals

                axis.isDirty = false;
            },

            /**
             * Redraw the axis to reflect changes in the data or axis extremes
             */
            redraw: function () {

                // render the axis
                this.render();

                // move plot lines and bands
                each(this.plotLinesAndBands, function (plotLine) {
                    plotLine.render();
                });

                // mark associated series as dirty and ready for redraw
                each(this.series, function (series) {
                    series.isDirty = true;
                });

            },

            /**
             * Destroys an Axis instance.
             */
            destroy: function (keepEvents) {
                var axis = this,
                    stacks = axis.stacks,
                    stackKey,
                    plotLinesAndBands = axis.plotLinesAndBands,
                    i;

                // Remove the events
                if (!keepEvents) {
                    removeEvent(axis);
                }

                // Destroy each stack total
                for (stackKey in stacks) {
                    destroyObjectProperties(stacks[stackKey]);

                    stacks[stackKey] = null;
                }

                // Destroy collections
                each([axis.ticks, axis.minorTicks, axis.alternateBands], function (coll) {
                    destroyObjectProperties(coll);
                });
                i = plotLinesAndBands.length;
                while (i--) { // #1975
                    plotLinesAndBands[i].destroy();
                }

                // Destroy local variables
                each(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'cross', 'gridGroup', 'labelGroup'], function (prop) {
                    if (axis[prop]) {
                        axis[prop] = axis[prop].destroy();
                    }
                });

                // Destroy crosshair
                if (this.cross) {
                    this.cross.destroy();
                }
            },

            /**
             * Draw the crosshair
             */
            drawCrosshair: function (e, point) { // docs: Missing docs for Axis.crosshair. Also for properties.

                var path,
                    options = this.crosshair,
                    animation = options.animation,
                    pos,
                    attribs,
                    categorized;

                if (
                    // Disabled in options
                    !this.crosshair ||
                    // Snap
                    ((defined(point) || !pick(this.crosshair.snap, true)) === false) ||
                    // Not on this axis (#4095, #2888)
                    (point && point.series && point.series[this.coll] !== this)
                ) {
                    this.hideCrosshair();

                } else {

                    // Get the path
                    if (!pick(options.snap, true)) {
                        pos = (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);
                    } else if (defined(point)) {
                        /*jslint eqeq: true*/
                        pos = this.isXAxis ? point.plotX : this.len - point.plotY; // #3834
                        /*jslint eqeq: false*/
                    }

                    if (this.isRadial) {
                        path = this.getPlotLinePath(this.isXAxis ? point.x : pick(point.stackY, point.y)) || null; // #3189
                    } else {
                        path = this.getPlotLinePath(null, null, null, null, pos) || null; // #3189
                    }

                    if (path === null) {
                        this.hideCrosshair();
                        return;
                    }

                    // Draw the cross
                    if (this.cross) {
                        this.cross
                            .attr({ visibility: VISIBLE })[animation ? 'animate' : 'attr']({ d: path }, animation);
                    } else {
                        categorized = this.categories && !this.isRadial;
                        attribs = {
                            'stroke-width': options.width || (categorized ? this.transA : 1),
                            stroke: options.color || (categorized ? 'rgba(155,200,255,0.2)' : '#C0C0C0'),
                            zIndex: options.zIndex || 2
                        };
                        if (options.dashStyle) {
                            attribs.dashstyle = options.dashStyle;
                        }
                        this.cross = this.chart.renderer.path(path).attr(attribs).add();
                    }

                }

            },

            /**
             *	Hide the crosshair.
             */
            hideCrosshair: function () {
                if (this.cross) {
                    this.cross.hide();
                }
            }
        }; // end Axis

        extend(Axis.prototype, AxisPlotLineOrBandExtension);

        /**
         * Set the tick positions to a time unit that makes sense, for example
         * on the first of each month or on every Monday. Return an array
         * with the time positions. Used in datetime axes as well as for grouping
         * data on a datetime axis.
         *
         * @param {Object} normalizedInterval The interval in axis values (ms) and the count
         * @param {Number} min The minimum in axis values
         * @param {Number} max The maximum in axis values
         * @param {Number} startOfWeek
         */
        Axis.prototype.getTimeTicks = function (normalizedInterval, min, max, startOfWeek) {
            var tickPositions = [],
                i,
                higherRanks = {},
                useUTC = defaultOptions.global.useUTC,
                minYear, // used in months and years as a basis for Date.UTC()
                minDate = new Date(min - getTZOffset(min)),
                interval = normalizedInterval.unitRange,
                count = normalizedInterval.count;

            if (defined(min)) { // #1300
                minDate[setMilliseconds](interval >= timeUnits.second ? 0 : // #3935
                    count * mathFloor(minDate.getMilliseconds() / count)); // #3652, #3654

                if (interval >= timeUnits.second) { // second
                    minDate[setSeconds](interval >= timeUnits.minute ? 0 : // #3935
                        count * mathFloor(minDate.getSeconds() / count));
                }

                if (interval >= timeUnits.minute) { // minute
                    minDate[setMinutes](interval >= timeUnits.hour ? 0 :
                        count * mathFloor(minDate[getMinutes]() / count));
                }

                if (interval >= timeUnits.hour) { // hour
                    minDate[setHours](interval >= timeUnits.day ? 0 :
                        count * mathFloor(minDate[getHours]() / count));
                }

                if (interval >= timeUnits.day) { // day
                    minDate[setDate](interval >= timeUnits.month ? 1 :
                        count * mathFloor(minDate[getDate]() / count));
                }

                if (interval >= timeUnits.month) { // month
                    minDate[setMonth](interval >= timeUnits.year ? 0 :
                        count * mathFloor(minDate[getMonth]() / count));
                    minYear = minDate[getFullYear]();
                }

                if (interval >= timeUnits.year) { // year
                    minYear -= minYear % count;
                    minDate[setFullYear](minYear);
                }

                // week is a special case that runs outside the hierarchy
                if (interval === timeUnits.week) {
                    // get start of current week, independent of count
                    minDate[setDate](minDate[getDate]() - minDate[getDay]() +
                        pick(startOfWeek, 1));
                }


                // get tick positions
                i = 1;
                if (timezoneOffset || getTimezoneOffset) {
                    minDate = minDate.getTime();
                    minDate = new Date(minDate + getTZOffset(minDate));
                }
                minYear = minDate[getFullYear]();
                var time = minDate.getTime(),
                    minMonth = minDate[getMonth](),
                    minDateDate = minDate[getDate](),
                    localTimezoneOffset = (timeUnits.day +
                            (useUTC ? getTZOffset(minDate) : minDate.getTimezoneOffset() * 60 * 1000)
                        ) % timeUnits.day; // #950, #3359

                // iterate and add tick positions at appropriate values
                while (time < max) {
                    tickPositions.push(time);

                    // if the interval is years, use Date.UTC to increase years
                    if (interval === timeUnits.year) {
                        time = makeTime(minYear + i * count, 0);

                        // if the interval is months, use Date.UTC to increase months
                    } else if (interval === timeUnits.month) {
                        time = makeTime(minYear, minMonth + i * count);

                        // if we're using global time, the interval is not fixed as it jumps
                        // one hour at the DST crossover
                    } else if (!useUTC && (interval === timeUnits.day || interval === timeUnits.week)) {
                        time = makeTime(minYear, minMonth, minDateDate +
                            i * count * (interval === timeUnits.day ? 1 : 7));

                        // else, the interval is fixed and we use simple addition
                    } else {
                        time += interval * count;
                    }

                    i++;
                }

                // push the last time
                tickPositions.push(time);


                // mark new days if the time is dividible by day (#1649, #1760)
                each(grep(tickPositions, function (time) {
                    return interval <= timeUnits.hour && time % timeUnits.day === localTimezoneOffset;
                }), function (time) {
                    higherRanks[time] = 'day';
                });
            }


            // record information on the chosen unit - for dynamic label formatter
            tickPositions.info = extend(normalizedInterval, {
                higherRanks: higherRanks,
                totalRange: interval * count
            });

            return tickPositions;
        };

        /**
         * Get a normalized tick interval for dates. Returns a configuration object with
         * unit range (interval), count and name. Used to prepare data for getTimeTicks. 
         * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs
         * of segments in stock charts, the normalizing logic was extracted in order to 
         * prevent it for running over again for each segment having the same interval. 
         * #662, #697.
         */
        Axis.prototype.normalizeTimeTickInterval = function (tickInterval, unitsOption) {
            var units = unitsOption || [[
                        'millisecond', // unit name
                        [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
            ], [
                        'second',
                        [1, 2, 5, 10, 15, 30]
            ], [
                        'minute',
                        [1, 2, 5, 10, 15, 30]
            ], [
                        'hour',
                        [1, 2, 3, 4, 6, 8, 12]
            ], [
                        'day',
                        [1, 2]
            ], [
                        'week',
                        [1, 2]
            ], [
                        'month',
                        [1, 2, 3, 4, 6]
            ], [
                        'year',
                        null
            ]],
                unit = units[units.length - 1], // default unit is years
                interval = timeUnits[unit[0]],
                multiples = unit[1],
                count,
                i;

            // loop through the units to find the one that best fits the tickInterval
            for (i = 0; i < units.length; i++) {
                unit = units[i];
                interval = timeUnits[unit[0]];
                multiples = unit[1];


                if (units[i + 1]) {
                    // lessThan is in the middle between the highest multiple and the next unit.
                    var lessThan = (interval * multiples[multiples.length - 1] +
                                timeUnits[units[i + 1][0]]) / 2;

                    // break and keep the current unit
                    if (tickInterval <= lessThan) {
                        break;
                    }
                }
            }

            // prevent 2.5 years intervals, though 25, 250 etc. are allowed
            if (interval === timeUnits.year && tickInterval < 5 * interval) {
                multiples = [1, 2, 5];
            }

            // get the count
            count = normalizeTickInterval(
                tickInterval / interval,
                multiples,
                unit[0] === 'year' ? mathMax(getMagnitude(tickInterval / interval), 1) : 1 // #1913, #2360
            );

            return {
                unitRange: interval,
                count: count,
                unitName: unit[0]
            };
        };/**
 * Methods defined on the Axis prototype
 */

        /**
         * Set the tick positions of a logarithmic axis
         */
        Axis.prototype.getLogTickPositions = function (interval, min, max, minor) {
            var axis = this,
                options = axis.options,
                axisLength = axis.len,
                // Since we use this method for both major and minor ticks,
                // use a local variable and return the result
                positions = [];

            // Reset
            if (!minor) {
                axis._minorAutoInterval = null;
            }

            // First case: All ticks fall on whole logarithms: 1, 10, 100 etc.
            if (interval >= 0.5) {
                interval = mathRound(interval);
                positions = axis.getLinearTickPositions(interval, min, max);

                // Second case: We need intermediary ticks. For example 
                // 1, 2, 4, 6, 8, 10, 20, 40 etc. 
            } else if (interval >= 0.08) {
                var roundedMin = mathFloor(min),
                    intermediate,
                    i,
                    j,
                    len,
                    pos,
                    lastPos,
                    break2;

                if (interval > 0.3) {
                    intermediate = [1, 2, 4];
                } else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc
                    intermediate = [1, 2, 4, 6, 8];
                } else { // 0.1 equals ten minor ticks per 1, 10, 100 etc
                    intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                }

                for (i = roundedMin; i < max + 1 && !break2; i++) {
                    len = intermediate.length;
                    for (j = 0; j < len && !break2; j++) {
                        pos = log2lin(lin2log(i) * intermediate[j]);
                        if (pos > min && (!minor || lastPos <= max) && lastPos !== UNDEFINED) { // #1670, lastPos is #3113
                            positions.push(lastPos);
                        }

                        if (lastPos > max) {
                            break2 = true;
                        }
                        lastPos = pos;
                    }
                }

                // Third case: We are so deep in between whole logarithmic values that
                // we might as well handle the tick positions like a linear axis. For
                // example 1.01, 1.02, 1.03, 1.04.
            } else {
                var realMin = lin2log(min),
                    realMax = lin2log(max),
                    tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],
                    filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,
                    tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),
                    totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;

                interval = pick(
                    filteredTickIntervalOption,
                    axis._minorAutoInterval,
                    (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)
                );

                interval = normalizeTickInterval(
                    interval,
                    null,
                    getMagnitude(interval)
                );

                positions = map(axis.getLinearTickPositions(
                    interval,
                    realMin,
                    realMax
                ), log2lin);

                if (!minor) {
                    axis._minorAutoInterval = interval / 5;
                }
            }

            // Set the axis-level tickInterval variable 
            if (!minor) {
                axis.tickInterval = interval;
            }
            return positions;
        };/**
 * The tooltip object
 * @param {Object} chart The chart instance
 * @param {Object} options Tooltip options
 */
        var Tooltip = Highcharts.Tooltip = function () {
            this.init.apply(this, arguments);
        };

        Tooltip.prototype = {

            init: function (chart, options) {

                var borderWidth = options.borderWidth,
                    style = options.style,
                    padding = pInt(style.padding);

                // Save the chart and options
                this.chart = chart;
                this.options = options;

                // Keep track of the current series
                //this.currentSeries = UNDEFINED;

                // List of crosshairs
                this.crosshairs = [];

                // Current values of x and y when animating
                this.now = { x: 0, y: 0 };

                // The tooltip is initially hidden
                this.isHidden = true;


                // create the label		
                this.label = chart.renderer.label('', 0, 0, options.shape || 'callout', null, null, options.useHTML, null, 'tooltip')
                    .attr({
                        padding: padding,
                        fill: options.backgroundColor,
                        'stroke-width': borderWidth,
                        r: options.borderRadius,
                        zIndex: 8
                    })
                    .css(style)
                    .css({ padding: 0 }) // Remove it from VML, the padding is applied as an attribute instead (#1117)
                    .add()
                    .attr({ y: -9999 }); // #2301, #2657

                // When using canVG the shadow shows up as a gray circle
                // even if the tooltip is hidden.
                if (!useCanVG) {
                    this.label.shadow(options.shadow);
                }

                // Public property for getting the shared state.
                this.shared = options.shared;
            },

            /**
             * Destroy the tooltip and its elements.
             */
            destroy: function () {
                // Destroy and clear local variables
                if (this.label) {
                    this.label = this.label.destroy();
                }
                clearTimeout(this.hideTimer);
                clearTimeout(this.tooltipTimeout);
            },

            /**
             * Provide a soft movement for the tooltip
             *
             * @param {Number} x
             * @param {Number} y
             * @private
             */
            move: function (x, y, anchorX, anchorY) {
                var tooltip = this,
                    now = tooltip.now,
                    animate = tooltip.options.animation !== false && !tooltip.isHidden &&
                        // When we get close to the target position, abort animation and land on the right place (#3056)
                        (mathAbs(x - now.x) > 1 || mathAbs(y - now.y) > 1),
                    skipAnchor = tooltip.followPointer || tooltip.len > 1;

                // Get intermediate values for animation
                extend(now, {
                    x: animate ? (2 * now.x + x) / 3 : x,
                    y: animate ? (now.y + y) / 2 : y,
                    anchorX: skipAnchor ? UNDEFINED : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,
                    anchorY: skipAnchor ? UNDEFINED : animate ? (now.anchorY + anchorY) / 2 : anchorY
                });

                // Move to the intermediate value
                tooltip.label.attr(now);


                // Run on next tick of the mouse tracker
                if (animate) {

                    // Never allow two timeouts
                    clearTimeout(this.tooltipTimeout);

                    // Set the fixed interval ticking for the smooth tooltip
                    this.tooltipTimeout = setTimeout(function () {
                        // The interval function may still be running during destroy, so check that the chart is really there before calling.
                        if (tooltip) {
                            tooltip.move(x, y, anchorX, anchorY);
                        }
                    }, 32);

                }
            },

            /**
             * Hide the tooltip
             */
            hide: function (delay) {
                var tooltip = this,
                    hoverPoints;

                clearTimeout(this.hideTimer); // disallow duplicate timers (#1728, #1766)
                if (!this.isHidden) {
                    hoverPoints = this.chart.hoverPoints;

                    this.hideTimer = setTimeout(function () {
                        tooltip.label.fadeOut();
                        tooltip.isHidden = true;
                    }, pick(delay, this.options.hideDelay, 500));
                }
            },

            /** 
             * Extendable method to get the anchor position of the tooltip
             * from a point or set of points
             */
            getAnchor: function (points, mouseEvent) {
                var ret,
                    chart = this.chart,
                    inverted = chart.inverted,
                    plotTop = chart.plotTop,
                    plotLeft = chart.plotLeft,
                    plotX = 0,
                    plotY = 0,
                    yAxis,
                    xAxis;

                points = splat(points);

                // Pie uses a special tooltipPos
                ret = points[0].tooltipPos;

                // When tooltip follows mouse, relate the position to the mouse
                if (this.followPointer && mouseEvent) {
                    if (mouseEvent.chartX === UNDEFINED) {
                        mouseEvent = chart.pointer.normalize(mouseEvent);
                    }
                    ret = [
                        mouseEvent.chartX - chart.plotLeft,
                        mouseEvent.chartY - plotTop
                    ];
                }
                // When shared, use the average position
                if (!ret) {
                    each(points, function (point) {
                        yAxis = point.series.yAxis;
                        xAxis = point.series.xAxis;
                        plotX += point.plotX + (!inverted && xAxis ? xAxis.left - plotLeft : 0);
                        plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +
                            (!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151
                    });

                    plotX /= points.length;
                    plotY /= points.length;

                    ret = [
                        inverted ? chart.plotWidth - plotY : plotX,
                        this.shared && !inverted && points.length > 1 && mouseEvent ?
                            mouseEvent.chartY - plotTop : // place shared tooltip next to the mouse (#424)
                            inverted ? chart.plotHeight - plotX : plotY
                    ];
                }

                return map(ret, mathRound);
            },

            /**
             * Place the tooltip in a chart without spilling over
             * and not covering the point it self.
             */
            getPosition: function (boxWidth, boxHeight, point) {

                var chart = this.chart,
                    distance = this.distance,
                    ret = {},
                    h = point.h || 0, // #4117
                    swapped,
                    first = ['y', chart.chartHeight, boxHeight, point.plotY + chart.plotTop],
                    second = ['x', chart.chartWidth, boxWidth, point.plotX + chart.plotLeft],
                    // The far side is right or bottom
                    preferFarSide = pick(point.ttBelow, (chart.inverted && !point.negative) || (!chart.inverted && point.negative)),
                    /**
                     * Handle the preferred dimension. When the preferred dimension is tooltip
                     * on top or bottom of the point, it will look for space there.
                     */
                    firstDimension = function (dim, outerSize, innerSize, point) {
                        var roomLeft = innerSize < point - distance,
                            roomRight = point + distance + innerSize < outerSize,
                            alignedLeft = point - distance - innerSize,
                            alignedRight = point + distance;

                        if (preferFarSide && roomRight) {
                            ret[dim] = alignedRight;
                        } else if (!preferFarSide && roomLeft) {
                            ret[dim] = alignedLeft;
                        } else if (roomLeft) {
                            ret[dim] = alignedLeft - h < 0 ? alignedLeft : alignedLeft - h;
                        } else if (roomRight) {
                            ret[dim] = alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h;
                        } else {
                            return false;
                        }
                    },
                    /**
                     * Handle the secondary dimension. If the preferred dimension is tooltip
                     * on top or bottom of the point, the second dimension is to align the tooltip
                     * above the point, trying to align center but allowing left or right
                     * align within the chart box.
                     */
                    secondDimension = function (dim, outerSize, innerSize, point) {
                        // Too close to the edge, return false and swap dimensions
                        if (point < distance || point > outerSize - distance) {
                            return false;

                            // Align left/top
                        } else if (point < innerSize / 2) {
                            ret[dim] = 1;
                            // Align right/bottom
                        } else if (point > outerSize - innerSize / 2) {
                            ret[dim] = outerSize - innerSize - 2;
                            // Align center
                        } else {
                            ret[dim] = point - innerSize / 2;
                        }
                    },
                    /**
                     * Swap the dimensions 
                     */
                    swap = function (count) {
                        var temp = first;
                        first = second;
                        second = temp;
                        swapped = count;
                    },
                    run = function () {
                        if (firstDimension.apply(0, first) !== false) {
                            if (secondDimension.apply(0, second) === false && !swapped) {
                                swap(true);
                                run();
                            }
                        } else if (!swapped) {
                            swap(true);
                            run();
                        } else {
                            ret.x = ret.y = 0;
                        }
                    };

                // Under these conditions, prefer the tooltip on the side of the point
                if (chart.inverted || this.len > 1) {
                    swap();
                }
                run();

                return ret;

            },

            /**
             * In case no user defined formatter is given, this will be used. Note that the context
             * here is an object holding point, series, x, y etc.
             */
            defaultFormatter: function (tooltip) {
                var items = this.points || splat(this),
                    s;

                // build the header
                s = [tooltip.tooltipFooterHeaderFormatter(items[0])]; //#3397: abstraction to enable formatting of footer and header

                // build the values
                s = s.concat(tooltip.bodyFormatter(items));

                // footer
                s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true)); //#3397: abstraction to enable formatting of footer and header

                return s.join('');
            },

            /**
             * Refresh the tooltip's text and position.
             * @param {Object} point
             */
            refresh: function (point, mouseEvent) {
                var tooltip = this,
                    chart = tooltip.chart,
                    label = tooltip.label,
                    options = tooltip.options,
                    x,
                    y,
                    anchor,
                    textConfig = {},
                    text,
                    pointConfig = [],
                    formatter = options.formatter || tooltip.defaultFormatter,
                    hoverPoints = chart.hoverPoints,
                    borderColor,
                    shared = tooltip.shared,
                    currentSeries;

                clearTimeout(this.hideTimer);

                // get the reference point coordinates (pie charts use tooltipPos)
                tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;
                anchor = tooltip.getAnchor(point, mouseEvent);
                x = anchor[0];
                y = anchor[1];

                // shared tooltip, array is sent over
                if (shared && !(point.series && point.series.noSharedTooltip)) {

                    // hide previous hoverPoints and set new

                    chart.hoverPoints = point;
                    if (hoverPoints) {
                        each(hoverPoints, function (point) {
                            point.setState();
                        });
                    }

                    each(point, function (item) {
                        item.setState(HOVER_STATE);

                        pointConfig.push(item.getLabelConfig());
                    });

                    textConfig = {
                        x: point[0].category,
                        y: point[0].y
                    };
                    textConfig.points = pointConfig;
                    this.len = pointConfig.length;
                    point = point[0];

                    // single point tooltip
                } else {
                    textConfig = point.getLabelConfig();
                }
                text = formatter.call(textConfig, tooltip);

                // register the current series
                currentSeries = point.series;
                this.distance = pick(currentSeries.tooltipOptions.distance, 16);

                // update the inner HTML
                if (text === false) {
                    this.hide();
                } else {

                    // show it
                    if (tooltip.isHidden) {
                        stop(label);
                        label.attr('opacity', 1).show();
                    }

                    // update text
                    label.attr({
                        text: text
                    });

                    // set the stroke color of the box
                    borderColor = options.borderColor || point.color || currentSeries.color || '#606060';
                    label.attr({
                        stroke: borderColor
                    });
                    tooltip.updatePosition({
                        plotX: x,
                        plotY: y,
                        negative: point.negative,
                        ttBelow: point.ttBelow,
                        h: anchor[2] || 0
                    });

                    this.isHidden = false;
                }
                fireEvent(chart, 'tooltipRefresh', {
                    text: text,
                    x: x + chart.plotLeft,
                    y: y + chart.plotTop,
                    borderColor: borderColor
                });
            },

            /**
             * Find the new position and perform the move
             */
            updatePosition: function (point) {
                var chart = this.chart,
                    label = this.label,
                    pos = (this.options.positioner || this.getPosition).call(
                        this,
                        label.width,
                        label.height,
                        point
                    );

                // do the move
                this.move(
                    mathRound(pos.x),
                    mathRound(pos.y || 0), // can be undefined (#3977) 
                    point.plotX + chart.plotLeft,
                    point.plotY + chart.plotTop
                );
            },

            /** 
             * Get the best X date format based on the closest point range on the axis.
             */
            getXDateFormat: function (point, options, xAxis) {
                var xDateFormat,
                    dateTimeLabelFormats = options.dateTimeLabelFormats,
                    closestPointRange = xAxis && xAxis.closestPointRange,
                    n,
                    blank = '01-01 00:00:00.000',
                    strpos = {
                        millisecond: 15,
                        second: 12,
                        minute: 9,
                        hour: 6,
                        day: 3
                    },
                    date,
                    lastN = 'millisecond'; // for sub-millisecond data, #4223

                if (closestPointRange) {
                    date = dateFormat('%m-%d %H:%M:%S.%L', point.x);
                    for (n in timeUnits) {

                        // If the range is exactly one week and we're looking at a Sunday/Monday, go for the week format
                        if (closestPointRange === timeUnits.week && +dateFormat('%w', point.x) === xAxis.options.startOfWeek &&
                                date.substr(6) === blank.substr(6)) {
                            n = 'week';
                            break;

                            // The first format that is too great for the range
                        } else if (timeUnits[n] > closestPointRange) {
                            n = lastN;
                            break;

                            // If the point is placed every day at 23:59, we need to show
                            // the minutes as well. #2637.
                        } else if (strpos[n] && date.substr(strpos[n]) !== blank.substr(strpos[n])) {
                            break;
                        }

                        // Weeks are outside the hierarchy, only apply them on Mondays/Sundays like in the first condition
                        if (n !== 'week') {
                            lastN = n;
                        }
                    }

                    if (n) {
                        xDateFormat = dateTimeLabelFormats[n];
                    }
                } else {
                    xDateFormat = dateTimeLabelFormats.day;
                }

                return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581
            },

            /**
             * Format the footer/header of the tooltip
             * #3397: abstraction to enable formatting of footer and header
             */
            tooltipFooterHeaderFormatter: function (point, isFooter) {
                var footOrHead = isFooter ? 'footer' : 'header',
                    series = point.series,
                    tooltipOptions = series.tooltipOptions,
                    xDateFormat = tooltipOptions.xDateFormat,
                    xAxis = series.xAxis,
                    isDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(point.key),
                    formatString = tooltipOptions[footOrHead + 'Format'];

                // Guess the best date format based on the closest point distance (#568, #3418)
                if (isDateTime && !xDateFormat) {
                    xDateFormat = this.getXDateFormat(point, tooltipOptions, xAxis);
                }

                // Insert the footer date format if any
                if (isDateTime && xDateFormat) {
                    formatString = formatString.replace('{point.key}', '{point.key:' + xDateFormat + '}');
                }

                return format(formatString, {
                    point: point,
                    series: series
                });
            },

            /**
             * Build the body (lines) of the tooltip by iterating over the items and returning one entry for each item,
             * abstracting this functionality allows to easily overwrite and extend it. 
             */
            bodyFormatter: function (items) {
                return map(items, function (item) {
                    var tooltipOptions = item.series.tooltipOptions;
                    return (tooltipOptions.pointFormatter || item.point.tooltipFormatter).call(item.point, tooltipOptions.pointFormat);
                });
            }

        };

        var hoverChartIndex;

        // Global flag for touch support
        hasTouch = doc.documentElement.ontouchstart !== UNDEFINED;

        /**
         * The mouse tracker object. All methods starting with "on" are primary DOM event handlers. 
         * Subsequent methods should be named differently from what they are doing.
         * @param {Object} chart The Chart instance
         * @param {Object} options The root options object
         */
        var Pointer = Highcharts.Pointer = function (chart, options) {
            this.init(chart, options);
        };

        Pointer.prototype = {
            /**
             * Initialize Pointer
             */
            init: function (chart, options) {

                var chartOptions = options.chart,
                    chartEvents = chartOptions.events,
                    zoomType = useCanVG ? '' : chartOptions.zoomType,
                    inverted = chart.inverted,
                    zoomX,
                    zoomY;

                // Store references
                this.options = options;
                this.chart = chart;

                // Zoom status
                this.zoomX = zoomX = /x/.test(zoomType);
                this.zoomY = zoomY = /y/.test(zoomType);
                this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);
                this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);
                this.hasZoom = zoomX || zoomY;

                // Do we need to handle click on a touch device?
                this.runChartClick = chartEvents && !!chartEvents.click;

                this.pinchDown = [];
                this.lastValidTouch = {};

                if (Highcharts.Tooltip && options.tooltip.enabled) {
                    chart.tooltip = new Tooltip(chart, options.tooltip);
                    this.followTouchMove = pick(options.tooltip.followTouchMove, true);
                }

                this.setDOMEvents();
            },

            /**
             * Add crossbrowser support for chartX and chartY
             * @param {Object} e The event object in standard browsers
             */
            normalize: function (e, chartPosition) {
                var chartX,
                    chartY,
                    ePos;

                // common IE normalizing
                e = e || window.event;

                // Framework specific normalizing (#1165)
                e = washMouseEvent(e);

                // More IE normalizing, needs to go after washMouseEvent
                if (!e.target) {
                    e.target = e.srcElement;
                }

                // iOS (#2757)
                ePos = e.touches ? (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;

                // Get mouse position
                if (!chartPosition) {
                    this.chartPosition = chartPosition = offset(this.chart.container);
                }

                // chartX and chartY
                if (ePos.pageX === UNDEFINED) { // IE < 9. #886.
                    chartX = mathMax(e.x, e.clientX - chartPosition.left); // #2005, #2129: the second case is 
                    // for IE10 quirks mode within framesets
                    chartY = e.y;
                } else {
                    chartX = ePos.pageX - chartPosition.left;
                    chartY = ePos.pageY - chartPosition.top;
                }

                return extend(e, {
                    chartX: mathRound(chartX),
                    chartY: mathRound(chartY)
                });
            },

            /**
             * Get the click position in terms of axis values.
             *
             * @param {Object} e A pointer event
             */
            getCoordinates: function (e) {
                var coordinates = {
                    xAxis: [],
                    yAxis: []
                };

                each(this.chart.axes, function (axis) {
                    coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({
                        axis: axis,
                        value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])
                    });
                });
                return coordinates;
            },

            /**
             * With line type charts with a single tracker, get the point closest to the mouse.
             * Run Point.onMouseOver and display tooltip for the point or points.
             */
            runPointActions: function (e) {

                var pointer = this,
                    chart = pointer.chart,
                    series = chart.series,
                    tooltip = chart.tooltip,
                    shared = tooltip ? tooltip.shared : false,
                    followPointer,
                    hoverPoint = chart.hoverPoint,
                    hoverSeries = chart.hoverSeries,
                    i,
                    distance = chart.chartWidth,
                    anchor,
                    noSharedTooltip,
                    directTouch,
                    kdpoints = [],
                    kdpoint,
                    kdpointT;

                // For hovering over the empty parts of the plot area (hoverSeries is undefined). 
                // If there is one series with point tracking (combo chart), don't go to nearest neighbour.
                if (!shared && !hoverSeries) {
                    for (i = 0; i < series.length; i++) {
                        if (series[i].directTouch || !series[i].options.stickyTracking) {
                            series = [];
                        }
                    }
                }

                // If it has a hoverPoint and that series requires direct touch (like columns), 
                // use the hoverPoint (#3899). Otherwise, search the k-d tree.
                if (!shared && hoverSeries && hoverSeries.directTouch && hoverPoint) {
                    kdpoint = hoverPoint;

                    // Handle shared tooltip or cases where a series is not yet hovered
                } else {
                    // Find nearest points on all series
                    each(series, function (s) {
                        // Skip hidden series
                        noSharedTooltip = s.noSharedTooltip && shared;
                        directTouch = !shared && s.directTouch;
                        if (s.visible && !noSharedTooltip && !directTouch && pick(s.options.enableMouseTracking, true)) { // #3821
                            kdpointT = s.searchPoint(e, !noSharedTooltip && s.kdDimensions === 1); // #3828
                            if (kdpointT) {
                                kdpoints.push(kdpointT);
                            }
                        }
                    });
                    // Find absolute nearest point
                    each(kdpoints, function (p) {
                        if (p && typeof p.dist === 'number' && p.dist < distance) {
                            distance = p.dist;
                            kdpoint = p;
                        }
                    });
                }

                // Refresh tooltip for kdpoint if new hover point or tooltip was hidden // #3926, #4200
                if (kdpoint && (kdpoint !== this.prevKDPoint || (tooltip && tooltip.isHidden))) {
                    // Draw tooltip if necessary
                    if (shared && !kdpoint.series.noSharedTooltip) {
                        i = kdpoints.length;
                        while (i--) {
                            if (kdpoints[i].clientX !== kdpoint.clientX || kdpoints[i].series.noSharedTooltip) {
                                kdpoints.splice(i, 1);
                            }
                        }
                        if (kdpoints.length && tooltip) {
                            tooltip.refresh(kdpoints, e);
                        }

                        // do mouseover on all points except the closest
                        each(kdpoints, function (point) {
                            if (point !== kdpoint) {
                                point.onMouseOver(e);
                            }
                        });
                        // #3919, #3985 do mouseover on the closest point last to ensure it is the hoverpoint
                        ((hoverSeries && hoverSeries.directTouch && hoverPoint) || kdpoint).onMouseOver(e);
                    } else {
                        if (tooltip) {
                            tooltip.refresh(kdpoint, e);
                        }
                        kdpoint.onMouseOver(e);
                    }
                    this.prevKDPoint = kdpoint;

                    // Update positions (regardless of kdpoint or hoverPoint)
                } else {
                    followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;
                    if (tooltip && followPointer && !tooltip.isHidden) {
                        anchor = tooltip.getAnchor([{}], e);
                        tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });
                    }
                }

                // Start the event listener to pick up the tooltip 
                if (tooltip && !pointer._onDocumentMouseMove) {
                    pointer._onDocumentMouseMove = function (e) {
                        if (charts[hoverChartIndex]) {
                            charts[hoverChartIndex].pointer.onDocumentMouseMove(e);
                        }
                    };
                    addEvent(doc, 'mousemove', pointer._onDocumentMouseMove);
                }

                // Crosshair
                each(chart.axes, function (axis) {
                    axis.drawCrosshair(e, pick(kdpoint, hoverPoint));
                });


            },



            /**
             * Reset the tracking by hiding the tooltip, the hover series state and the hover point
             * 
             * @param allowMove {Boolean} Instead of destroying the tooltip altogether, allow moving it if possible
             */
            reset: function (allowMove, delay) {
                var pointer = this,
                    chart = pointer.chart,
                    hoverSeries = chart.hoverSeries,
                    hoverPoint = chart.hoverPoint,
                    hoverPoints = chart.hoverPoints,
                    tooltip = chart.tooltip,
                    tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;

                // Narrow in allowMove
                allowMove = allowMove && tooltip && tooltipPoints;

                // Check if the points have moved outside the plot area, #1003		
                if (allowMove && splat(tooltipPoints)[0].plotX === UNDEFINED) {
                    allowMove = false;
                }
                // Just move the tooltip, #349
                if (allowMove) {
                    tooltip.refresh(tooltipPoints);
                    if (hoverPoint) { // #2500
                        hoverPoint.setState(hoverPoint.state, true);
                        each(chart.axes, function (axis) {
                            if (pick(axis.options.crosshair && axis.options.crosshair.snap, true)) {
                                axis.drawCrosshair(null, hoverPoint);
                            } else {
                                axis.hideCrosshair();
                            }
                        });

                    }

                    // Full reset
                } else {

                    if (hoverPoint) {
                        hoverPoint.onMouseOut();
                    }

                    if (hoverPoints) {
                        each(hoverPoints, function (point) {
                            point.setState();
                        });
                    }

                    if (hoverSeries) {
                        hoverSeries.onMouseOut();
                    }

                    if (tooltip) {
                        tooltip.hide(delay);
                    }

                    if (pointer._onDocumentMouseMove) {
                        removeEvent(doc, 'mousemove', pointer._onDocumentMouseMove);
                        pointer._onDocumentMouseMove = null;
                    }

                    // Remove crosshairs
                    each(chart.axes, function (axis) {
                        axis.hideCrosshair();
                    });

                    pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;

                }
            },

            /**
             * Scale series groups to a certain scale and translation
             */
            scaleGroups: function (attribs, clip) {

                var chart = this.chart,
                    seriesAttribs;

                // Scale each series
                each(chart.series, function (series) {
                    seriesAttribs = attribs || series.getPlotBox(); // #1701
                    if (series.xAxis && series.xAxis.zoomEnabled) {
                        series.group.attr(seriesAttribs);
                        if (series.markerGroup) {
                            series.markerGroup.attr(seriesAttribs);
                            series.markerGroup.clip(clip ? chart.clipRect : null);
                        }
                        if (series.dataLabelsGroup) {
                            series.dataLabelsGroup.attr(seriesAttribs);
                        }
                    }
                });

                // Clip
                chart.clipRect.attr(clip || chart.clipBox);
            },

            /**
             * Start a drag operation
             */
            dragStart: function (e) {
                var chart = this.chart;

                // Record the start position
                chart.mouseIsDown = e.type;
                chart.cancelClick = false;
                chart.mouseDownX = this.mouseDownX = e.chartX;
                chart.mouseDownY = this.mouseDownY = e.chartY;
            },

            /**
             * Perform a drag operation in response to a mousemove event while the mouse is down
             */
            drag: function (e) {

                var chart = this.chart,
                    chartOptions = chart.options.chart,
                    chartX = e.chartX,
                    chartY = e.chartY,
                    zoomHor = this.zoomHor,
                    zoomVert = this.zoomVert,
                    plotLeft = chart.plotLeft,
                    plotTop = chart.plotTop,
                    plotWidth = chart.plotWidth,
                    plotHeight = chart.plotHeight,
                    clickedInside,
                    size,
                    mouseDownX = this.mouseDownX,
                    mouseDownY = this.mouseDownY,
                    panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];

                // If the mouse is outside the plot area, adjust to cooordinates
                // inside to prevent the selection marker from going outside
                if (chartX < plotLeft) {
                    chartX = plotLeft;
                } else if (chartX > plotLeft + plotWidth) {
                    chartX = plotLeft + plotWidth;
                }

                if (chartY < plotTop) {
                    chartY = plotTop;
                } else if (chartY > plotTop + plotHeight) {
                    chartY = plotTop + plotHeight;
                }

                // determine if the mouse has moved more than 10px
                this.hasDragged = Math.sqrt(
                    Math.pow(mouseDownX - chartX, 2) +
                    Math.pow(mouseDownY - chartY, 2)
                );

                if (this.hasDragged > 10) {
                    clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);

                    // make a selection
                    if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {
                        if (!this.selectionMarker) {
                            this.selectionMarker = chart.renderer.rect(
                                plotLeft,
                                plotTop,
                                zoomHor ? 1 : plotWidth,
                                zoomVert ? 1 : plotHeight,
                                0
                            )
                            .attr({
                                fill: chartOptions.selectionMarkerFill || 'rgba(69,114,167,0.25)',
                                zIndex: 7
                            })
                            .add();
                        }
                    }

                    // adjust the width of the selection marker
                    if (this.selectionMarker && zoomHor) {
                        size = chartX - mouseDownX;
                        this.selectionMarker.attr({
                            width: mathAbs(size),
                            x: (size > 0 ? 0 : size) + mouseDownX
                        });
                    }
                    // adjust the height of the selection marker
                    if (this.selectionMarker && zoomVert) {
                        size = chartY - mouseDownY;
                        this.selectionMarker.attr({
                            height: mathAbs(size),
                            y: (size > 0 ? 0 : size) + mouseDownY
                        });
                    }

                    // panning
                    if (clickedInside && !this.selectionMarker && chartOptions.panning) {
                        chart.pan(e, chartOptions.panning);
                    }
                }
            },

            /**
             * On mouse up or touch end across the entire document, drop the selection.
             */
            drop: function (e) {
                var pointer = this,
                    chart = this.chart,
                    hasPinched = this.hasPinched;

                if (this.selectionMarker) {
                    var selectionData = {
                        xAxis: [],
                        yAxis: [],
                        originalEvent: e.originalEvent || e
                    },
                        selectionBox = this.selectionMarker,
                        selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,
                        selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,
                        selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,
                        selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,
                        runZoom;

                    // a selection has been made
                    if (this.hasDragged || hasPinched) {

                        // record each axis' min and max
                        each(chart.axes, function (axis) {
                            if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{ xAxis: 'zoomX', yAxis: 'zoomY' }[axis.coll]])) { // #859, #3569
                                var horiz = axis.horiz,
                                    minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding : 0, // #1207, #3075
                                    selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),
                                    selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);

                                selectionData[axis.coll].push({
                                    axis: axis,
                                    min: mathMin(selectionMin, selectionMax), // for reversed axes
                                    max: mathMax(selectionMin, selectionMax)
                                });
                                runZoom = true;
                            }
                        });
                        if (runZoom) {
                            fireEvent(chart, 'selection', selectionData, function (args) {
                                chart.zoom(extend(args, hasPinched ? { animation: false } : null));
                            });
                        }

                    }
                    this.selectionMarker = this.selectionMarker.destroy();

                    // Reset scaling preview
                    if (hasPinched) {
                        this.scaleGroups();
                    }
                }

                // Reset all
                if (chart) { // it may be destroyed on mouse up - #877
                    css(chart.container, { cursor: chart._cursor });
                    chart.cancelClick = this.hasDragged > 10; // #370
                    chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
                    this.pinchDown = [];
                }
            },

            onContainerMouseDown: function (e) {

                e = this.normalize(e);

                // issue #295, dragging not always working in Firefox
                if (e.preventDefault) {
                    e.preventDefault();
                }

                this.dragStart(e);
            },



            onDocumentMouseUp: function (e) {
                if (charts[hoverChartIndex]) {
                    charts[hoverChartIndex].pointer.drop(e);
                }
            },

            /**
             * Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.
             * Issue #149 workaround. The mouseleave event does not always fire. 
             */
            onDocumentMouseMove: function (e) {
                var chart = this.chart,
                    chartPosition = this.chartPosition;

                e = this.normalize(e, chartPosition);

                // If we're outside, hide the tooltip
                if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') &&
                        !chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {
                    this.reset();
                }
            },

            /**
             * When mouse leaves the container, hide the tooltip.
             */
            onContainerMouseLeave: function () {
                var chart = charts[hoverChartIndex];
                if (chart) {
                    chart.pointer.reset();
                    chart.pointer.chartPosition = null; // also reset the chart position, used in #149 fix
                }
            },

            // The mousemove, touchmove and touchstart event handler
            onContainerMouseMove: function (e) {

                var chart = this.chart;

                hoverChartIndex = chart.index;

                e = this.normalize(e);
                e.returnValue = false; // #2251, #3224

                if (chart.mouseIsDown === 'mousedown') {
                    this.drag(e);
                }

                // Show the tooltip and run mouse over events (#977)
                if ((this.inClass(e.target, 'highcharts-tracker') ||
                        chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {
                    this.runPointActions(e);
                }
            },

            /**
             * Utility to detect whether an element has, or has a parent with, a specific
             * class name. Used on detection of tracker objects and on deciding whether
             * hovering the tooltip should cause the active series to mouse out.
             */
            inClass: function (element, className) {
                var elemClassName;
                while (element) {
                    elemClassName = attr(element, 'class');
                    if (elemClassName) {
                        if (elemClassName.indexOf(className) !== -1) {
                            return true;
                        } else if (elemClassName.indexOf(PREFIX + 'container') !== -1) {
                            return false;
                        }
                    }
                    element = element.parentNode;
                }
            },

            onTrackerMouseOut: function (e) {
                var series = this.chart.hoverSeries,
                    relatedTarget = e.relatedTarget || e.toElement,
                    relatedSeries = relatedTarget && relatedTarget.point && relatedTarget.point.series; // #2499

                if (series && !series.options.stickyTracking && !this.inClass(relatedTarget, PREFIX + 'tooltip') &&
                        relatedSeries !== series) {
                    series.onMouseOut();
                }
            },

            onContainerClick: function (e) {
                var chart = this.chart,
                    hoverPoint = chart.hoverPoint,
                    plotLeft = chart.plotLeft,
                    plotTop = chart.plotTop;

                e = this.normalize(e);
                e.originalEvent = e; // #3913

                if (!chart.cancelClick) {

                    // On tracker click, fire the series and point events. #783, #1583
                    if (hoverPoint && this.inClass(e.target, PREFIX + 'tracker')) {

                        // the series click event
                        fireEvent(hoverPoint.series, 'click', extend(e, {
                            point: hoverPoint
                        }));

                        // the point click event
                        if (chart.hoverPoint) { // it may be destroyed (#1844)
                            hoverPoint.firePointEvent('click', e);
                        }

                        // When clicking outside a tracker, fire a chart event
                    } else {
                        extend(e, this.getCoordinates(e));

                        // fire a click event in the chart
                        if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
                            fireEvent(chart, 'click', e);
                        }
                    }


                }
            },

            /**
             * Set the JS DOM events on the container and document. This method should contain
             * a one-to-one assignment between methods and their handlers. Any advanced logic should
             * be moved to the handler reflecting the event's name.
             */
            setDOMEvents: function () {

                var pointer = this,
                    container = pointer.chart.container;

                container.onmousedown = function (e) {
                    pointer.onContainerMouseDown(e);
                };
                container.onmousemove = function (e) {
                    pointer.onContainerMouseMove(e);
                };
                container.onclick = function (e) {
                    pointer.onContainerClick(e);
                };
                addEvent(container, 'mouseleave', pointer.onContainerMouseLeave);
                if (chartCount === 1) {
                    addEvent(doc, 'mouseup', pointer.onDocumentMouseUp);
                }
                if (hasTouch) {
                    container.ontouchstart = function (e) {
                        pointer.onContainerTouchStart(e);
                    };
                    container.ontouchmove = function (e) {
                        pointer.onContainerTouchMove(e);
                    };
                    if (chartCount === 1) {
                        addEvent(doc, 'touchend', pointer.onDocumentTouchEnd);
                    }
                }

            },

            /**
             * Destroys the Pointer object and disconnects DOM events.
             */
            destroy: function () {
                var prop;

                removeEvent(this.chart.container, 'mouseleave', this.onContainerMouseLeave);
                if (!chartCount) {
                    removeEvent(doc, 'mouseup', this.onDocumentMouseUp);
                    removeEvent(doc, 'touchend', this.onDocumentTouchEnd);
                }

                // memory and CPU leak
                clearInterval(this.tooltipTimeout);

                for (prop in this) {
                    this[prop] = null;
                }
            }
        };


        /* Support for touch devices */
        extend(Highcharts.Pointer.prototype, {

            /**
             * Run translation operations
             */
            pinchTranslate: function (pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {
                if (this.zoomHor || this.pinchHor) {
                    this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
                }
                if (this.zoomVert || this.pinchVert) {
                    this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
                }
            },

            /**
             * Run translation operations for each direction (horizontal and vertical) independently
             */
            pinchTranslateDirection: function (horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch, forcedScale) {
                var chart = this.chart,
                    xy = horiz ? 'x' : 'y',
                    XY = horiz ? 'X' : 'Y',
                    sChartXY = 'chart' + XY,
                    wh = horiz ? 'width' : 'height',
                    plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],
                    selectionWH,
                    selectionXY,
                    clipXY,
                    scale = forcedScale || 1,
                    inverted = chart.inverted,
                    bounds = chart.bounds[horiz ? 'h' : 'v'],
                    singleTouch = pinchDown.length === 1,
                    touch0Start = pinchDown[0][sChartXY],
                    touch0Now = touches[0][sChartXY],
                    touch1Start = !singleTouch && pinchDown[1][sChartXY],
                    touch1Now = !singleTouch && touches[1][sChartXY],
                    outOfBounds,
                    transformScale,
                    scaleKey,
                    setScale = function () {
                        if (!singleTouch && mathAbs(touch0Start - touch1Start) > 20) { // Don't zoom if fingers are too close on this axis
                            scale = forcedScale || mathAbs(touch0Now - touch1Now) / mathAbs(touch0Start - touch1Start);
                        }

                        clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;
                        selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;
                    };

                // Set the scale, first pass
                setScale();

                selectionXY = clipXY; // the clip position (x or y) is altered if out of bounds, the selection position is not

                // Out of bounds
                if (selectionXY < bounds.min) {
                    selectionXY = bounds.min;
                    outOfBounds = true;
                } else if (selectionXY + selectionWH > bounds.max) {
                    selectionXY = bounds.max - selectionWH;
                    outOfBounds = true;
                }

                // Is the chart dragged off its bounds, determined by dataMin and dataMax?
                if (outOfBounds) {

                    // Modify the touchNow position in order to create an elastic drag movement. This indicates
                    // to the user that the chart is responsive but can't be dragged further.
                    touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);
                    if (!singleTouch) {
                        touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);
                    }

                    // Set the scale, second pass to adapt to the modified touchNow positions
                    setScale();

                } else {
                    lastValidTouch[xy] = [touch0Now, touch1Now];
                }

                // Set geometry for clipping, selection and transformation
                if (!inverted) { // TODO: implement clipping for inverted charts
                    clip[xy] = clipXY - plotLeftTop;
                    clip[wh] = selectionWH;
                }
                scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;
                transformScale = inverted ? 1 / scale : scale;

                selectionMarker[wh] = selectionWH;
                selectionMarker[xy] = selectionXY;
                transform[scaleKey] = scale;
                transform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));
            },

            /**
             * Handle touch events with two touches
             */
            pinch: function (e) {

                var self = this,
                    chart = self.chart,
                    pinchDown = self.pinchDown,
                    touches = e.touches,
                    touchesLength = touches.length,
                    lastValidTouch = self.lastValidTouch,
                    hasZoom = self.hasZoom,
                    selectionMarker = self.selectionMarker,
                    transform = {},
                    fireClickEvent = touchesLength === 1 && ((self.inClass(e.target, PREFIX + 'tracker') &&
                        chart.runTrackerClick) || self.runChartClick),
                    clip = {};

                // Don't initiate panning until the user has pinched. This prevents us from 
                // blocking page scrolling as users scroll down a long page (#4210).
                if (touchesLength > 1) {
                    self.initiated = true;
                }

                // On touch devices, only proceed to trigger click if a handler is defined
                if (hasZoom && self.initiated && !fireClickEvent) {
                    e.preventDefault();
                }

                // Normalize each touch
                map(touches, function (e) {
                    return self.normalize(e);
                });

                // Register the touch start position
                if (e.type === 'touchstart') {
                    each(touches, function (e, i) {
                        pinchDown[i] = { chartX: e.chartX, chartY: e.chartY };
                    });
                    lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];
                    lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];

                    // Identify the data bounds in pixels
                    each(chart.axes, function (axis) {
                        if (axis.zoomEnabled) {
                            var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],
                                minPixelPadding = axis.minPixelPadding,
                                min = axis.toPixels(pick(axis.options.min, axis.dataMin)),
                                max = axis.toPixels(pick(axis.options.max, axis.dataMax)),
                                absMin = mathMin(min, max),
                                absMax = mathMax(min, max);

                            // Store the bounds for use in the touchmove handler
                            bounds.min = mathMin(axis.pos, absMin - minPixelPadding);
                            bounds.max = mathMax(axis.pos + axis.len, absMax + minPixelPadding);
                        }
                    });
                    self.res = true; // reset on next move

                    // Event type is touchmove, handle panning and pinching
                } else if (pinchDown.length) { // can be 0 when releasing, if touchend fires first


                    // Set the marker
                    if (!selectionMarker) {
                        self.selectionMarker = selectionMarker = extend({
                            destroy: noop
                        }, chart.plotBox);
                    }

                    self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);

                    self.hasPinched = hasZoom;

                    // Scale and translate the groups to provide visual feedback during pinching
                    self.scaleGroups(transform, clip);

                    // Optionally move the tooltip on touchmove
                    if (!hasZoom && self.followTouchMove && touchesLength === 1) {
                        this.runPointActions(self.normalize(e));
                    } else if (self.res) {
                        self.res = false;
                        this.reset(false, 0);
                    }
                }
            },

            /**
             * General touch handler shared by touchstart and touchmove.
             */
            touch: function (e, start) {
                var chart = this.chart;

                hoverChartIndex = chart.index;

                if (e.touches.length === 1) {

                    e = this.normalize(e);

                    if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop) && !chart.openMenu) {

                        // Run mouse events and display tooltip etc
                        if (start) {
                            this.runPointActions(e);
                        }

                        this.pinch(e);

                    } else if (start) {
                        // Hide the tooltip on touching outside the plot area (#1203)
                        this.reset();
                    }

                } else if (e.touches.length === 2) {
                    this.pinch(e);
                }
            },

            onContainerTouchStart: function (e) {
                this.touch(e, true);
            },

            onContainerTouchMove: function (e) {
                this.touch(e);
            },

            onDocumentTouchEnd: function (e) {
                if (charts[hoverChartIndex]) {
                    charts[hoverChartIndex].pointer.drop(e);
                }
            }

        });
        if (win.PointerEvent || win.MSPointerEvent) {

            // The touches object keeps track of the points being touched at all times
            var touches = {},
                hasPointerEvent = !!win.PointerEvent,
                getWebkitTouches = function () {
                    var key, fake = [];
                    fake.item = function (i) { return this[i]; };
                    for (key in touches) {
                        if (touches.hasOwnProperty(key)) {
                            fake.push({
                                pageX: touches[key].pageX,
                                pageY: touches[key].pageY,
                                target: touches[key].target
                            });
                        }
                    }
                    return fake;
                },
                translateMSPointer = function (e, method, wktype, callback) {
                    var p;
                    e = e.originalEvent || e;
                    if ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts[hoverChartIndex]) {
                        callback(e);
                        p = charts[hoverChartIndex].pointer;
                        p[method]({
                            type: wktype,
                            target: e.currentTarget,
                            preventDefault: noop,
                            touches: getWebkitTouches()
                        });
                    }
                };

            /**
             * Extend the Pointer prototype with methods for each event handler and more
             */
            extend(Pointer.prototype, {
                onContainerPointerDown: function (e) {
                    translateMSPointer(e, 'onContainerTouchStart', 'touchstart', function (e) {
                        touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY, target: e.currentTarget };
                    });
                },
                onContainerPointerMove: function (e) {
                    translateMSPointer(e, 'onContainerTouchMove', 'touchmove', function (e) {
                        touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY };
                        if (!touches[e.pointerId].target) {
                            touches[e.pointerId].target = e.currentTarget;
                        }
                    });
                },
                onDocumentPointerUp: function (e) {
                    translateMSPointer(e, 'onDocumentTouchEnd', 'touchend', function (e) {
                        delete touches[e.pointerId];
                    });
                },

                /**
                 * Add or remove the MS Pointer specific events
                 */
                batchMSEvents: function (fn) {
                    fn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);
                    fn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);
                    fn(doc, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);
                }
            });

            // Disable default IE actions for pinch and such on chart element
            wrap(Pointer.prototype, 'init', function (proceed, chart, options) {
                proceed.call(this, chart, options);
                if (this.hasZoom) { // #4014
                    css(chart.container, {
                        '-ms-touch-action': NONE,
                        'touch-action': NONE
                    });
                }
            });

            // Add IE specific touch events to chart
            wrap(Pointer.prototype, 'setDOMEvents', function (proceed) {
                proceed.apply(this);
                if (this.hasZoom || this.followTouchMove) {
                    this.batchMSEvents(addEvent);
                }
            });
            // Destroy MS events also
            wrap(Pointer.prototype, 'destroy', function (proceed) {
                this.batchMSEvents(removeEvent);
                proceed.call(this);
            });
        }
        /**
         * The overview of the chart's series
         */
        var Legend = Highcharts.Legend = function (chart, options) {
            this.init(chart, options);
        };

        Legend.prototype = {

            /**
             * Initialize the legend
             */
            init: function (chart, options) {

                var legend = this,
                    itemStyle = options.itemStyle,
                    padding,
                    itemMarginTop = options.itemMarginTop || 0;

                this.options = options;

                if (!options.enabled) {
                    return;
                }

                legend.itemStyle = itemStyle;
                legend.itemHiddenStyle = merge(itemStyle, options.itemHiddenStyle);
                legend.itemMarginTop = itemMarginTop;
                legend.padding = padding = pick(options.padding, 8);
                legend.initialItemX = padding;
                legend.initialItemY = padding - 5; // 5 is the number of pixels above the text
                legend.maxItemWidth = 0;
                legend.chart = chart;
                legend.itemHeight = 0;
                legend.symbolWidth = pick(options.symbolWidth, 16);
                legend.pages = [];


                // Render it
                legend.render();

                // move checkboxes
                addEvent(legend.chart, 'endResize', function () {
                    legend.positionCheckboxes();
                });

            },

            /**
             * Set the colors for the legend item
             * @param {Object} item A Series or Point instance
             * @param {Object} visible Dimmed or colored
             */
            colorizeItem: function (item, visible) {
                var legend = this,
                    options = legend.options,
                    legendItem = item.legendItem,
                    legendLine = item.legendLine,
                    legendSymbol = item.legendSymbol,
                    hiddenColor = legend.itemHiddenStyle.color,
                    textColor = visible ? options.itemStyle.color : hiddenColor,
                    symbolColor = visible ? (item.legendColor || item.color || '#CCC') : hiddenColor,
                    markerOptions = item.options && item.options.marker,
                    symbolAttr = { fill: symbolColor },
                    key,
                    val;

                if (legendItem) {
                    legendItem.css({ fill: textColor, color: textColor }); // color for #1553, oldIE
                }
                if (legendLine) {
                    legendLine.attr({ stroke: symbolColor });
                }

                if (legendSymbol) {

                    // Apply marker options
                    if (markerOptions && legendSymbol.isMarker) { // #585
                        symbolAttr.stroke = symbolColor;
                        markerOptions = item.convertAttribs(markerOptions);
                        for (key in markerOptions) {
                            val = markerOptions[key];
                            if (val !== UNDEFINED) {
                                symbolAttr[key] = val;
                            }
                        }
                    }

                    legendSymbol.attr(symbolAttr);
                }
            },

            /**
             * Position the legend item
             * @param {Object} item A Series or Point instance
             */
            positionItem: function (item) {
                var legend = this,
                    options = legend.options,
                    symbolPadding = options.symbolPadding,
                    ltr = !options.rtl,
                    legendItemPos = item._legendItemPos,
                    itemX = legendItemPos[0],
                    itemY = legendItemPos[1],
                    checkbox = item.checkbox,
                    legendGroup = item.legendGroup;

                if (legendGroup && legendGroup.element) {
                    legendGroup.translate(
                        ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,
                        itemY
                    );
                }

                if (checkbox) {
                    checkbox.x = itemX;
                    checkbox.y = itemY;
                }
            },

            /**
             * Destroy a single legend item
             * @param {Object} item The series or point
             */
            destroyItem: function (item) {
                var checkbox = item.checkbox;

                // destroy SVG elements
                each(['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'], function (key) {
                    if (item[key]) {
                        item[key] = item[key].destroy();
                    }
                });

                if (checkbox) {
                    discardElement(item.checkbox);
                }
            },

            /**
             * Destroys the legend.
             */
            destroy: function () {
                var legend = this,
                    legendGroup = legend.group,
                    box = legend.box;

                if (box) {
                    legend.box = box.destroy();
                }

                if (legendGroup) {
                    legend.group = legendGroup.destroy();
                }
            },

            /**
             * Position the checkboxes after the width is determined
             */
            positionCheckboxes: function (scrollOffset) {
                var alignAttr = this.group.alignAttr,
                    translateY,
                    clipHeight = this.clipHeight || this.legendHeight;

                if (alignAttr) {
                    translateY = alignAttr.translateY;
                    each(this.allItems, function (item) {
                        var checkbox = item.checkbox,
                            top;

                        if (checkbox) {
                            top = (translateY + checkbox.y + (scrollOffset || 0) + 3);
                            css(checkbox, {
                                left: (alignAttr.translateX + item.checkboxOffset + checkbox.x - 20) + PX,
                                top: top + PX,
                                display: top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : NONE
                            });
                        }
                    });
                }
            },

            /**
             * Render the legend title on top of the legend
             */
            renderTitle: function () {
                var options = this.options,
                    padding = this.padding,
                    titleOptions = options.title,
                    titleHeight = 0,
                    bBox;

                if (titleOptions.text) {
                    if (!this.title) {
                        this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, null, null, 'legend-title')
                            .attr({ zIndex: 1 })
                            .css(titleOptions.style)
                            .add(this.group);
                    }
                    bBox = this.title.getBBox();
                    titleHeight = bBox.height;
                    this.offsetWidth = bBox.width; // #1717
                    this.contentGroup.attr({ translateY: titleHeight });
                }
                this.titleHeight = titleHeight;
            },

            /**
             * Set the legend item text
             */
            setText: function (item) {
                var options = this.options;
                item.legendItem.attr({
                    text: options.labelFormat ? format(options.labelFormat, item) : options.labelFormatter.call(item)
                });
            },

            /**
             * Render a single specific legend item
             * @param {Object} item A series or point
             */
            renderItem: function (item) {
                var legend = this,
                    chart = legend.chart,
                    renderer = chart.renderer,
                    options = legend.options,
                    horizontal = options.layout === 'horizontal',
                    symbolWidth = legend.symbolWidth,
                    symbolPadding = options.symbolPadding,
                    itemStyle = legend.itemStyle,
                    itemHiddenStyle = legend.itemHiddenStyle,
                    padding = legend.padding,
                    itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,
                    ltr = !options.rtl,
                    itemHeight,
                    widthOption = options.width,
                    itemMarginBottom = options.itemMarginBottom || 0,
                    itemMarginTop = legend.itemMarginTop,
                    initialItemX = legend.initialItemX,
                    bBox,
                    itemWidth,
                    li = item.legendItem,
                    series = item.series && item.series.drawLegendSymbol ? item.series : item,
                    seriesOptions = series.options,
                    showCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox,
                    useHTML = options.useHTML;

                if (!li) { // generate it once, later move it

                    // Generate the group box
                    // A group to hold the symbol and text. Text is to be appended in Legend class.
                    item.legendGroup = renderer.g('legend-item')
                        .attr({ zIndex: 1 })
                        .add(legend.scrollGroup);

                    // Generate the list item text and add it to the group
                    item.legendItem = li = renderer.text(
                            '',
                            ltr ? symbolWidth + symbolPadding : -symbolPadding,
                            legend.baseline || 0,
                            useHTML
                        )
                        .css(merge(item.visible ? itemStyle : itemHiddenStyle)) // merge to prevent modifying original (#1021)
                        .attr({
                            align: ltr ? 'left' : 'right',
                            zIndex: 2
                        })
                        .add(item.legendGroup);

                    // Get the baseline for the first item - the font size is equal for all
                    if (!legend.baseline) {
                        legend.fontMetrics = renderer.fontMetrics(itemStyle.fontSize, li);
                        legend.baseline = legend.fontMetrics.f + 3 + itemMarginTop;
                        li.attr('y', legend.baseline);
                    }

                    // Draw the legend symbol inside the group box
                    series.drawLegendSymbol(legend, item);

                    if (legend.setItemEvents) {
                        legend.setItemEvents(item, li, useHTML, itemStyle, itemHiddenStyle);
                    }

                    // Colorize the items
                    legend.colorizeItem(item, item.visible);

                    // add the HTML checkbox on top
                    if (showCheckbox) {
                        legend.createCheckboxForItem(item);
                    }
                }

                // Always update the text
                legend.setText(item);

                // calculate the positions for the next line
                bBox = li.getBBox();

                itemWidth = item.checkboxOffset =
                    options.itemWidth ||
                    item.legendItemWidth ||
                    symbolWidth + symbolPadding + bBox.width + itemDistance + (showCheckbox ? 20 : 0);
                legend.itemHeight = itemHeight = mathRound(item.legendItemHeight || bBox.height);

                // if the item exceeds the width, start a new line
                if (horizontal && legend.itemX - initialItemX + itemWidth >
                        (widthOption || (chart.chartWidth - 2 * padding - initialItemX - options.x))) {
                    legend.itemX = initialItemX;
                    legend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;
                    legend.lastLineHeight = 0; // reset for next line (#915, #3976)
                }

                // If the item exceeds the height, start a new column
                /*if (!horizontal && legend.itemY + options.y + itemHeight > chart.chartHeight - spacingTop - spacingBottom) {
                    legend.itemY = legend.initialItemY;
                    legend.itemX += legend.maxItemWidth;
                    legend.maxItemWidth = 0;
                }*/

                // Set the edge positions
                legend.maxItemWidth = mathMax(legend.maxItemWidth, itemWidth);
                legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;
                legend.lastLineHeight = mathMax(itemHeight, legend.lastLineHeight); // #915

                // cache the position of the newly generated or reordered items
                item._legendItemPos = [legend.itemX, legend.itemY];

                // advance
                if (horizontal) {
                    legend.itemX += itemWidth;

                } else {
                    legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;
                    legend.lastLineHeight = itemHeight;
                }

                // the width of the widest item
                legend.offsetWidth = widthOption || mathMax(
                    (horizontal ? legend.itemX - initialItemX - itemDistance : itemWidth) + padding,
                    legend.offsetWidth
                );
            },

            /**
             * Get all items, which is one item per series for normal series and one item per point
             * for pie series.
             */
            getAllItems: function () {
                var allItems = [];
                each(this.chart.series, function (series) {
                    var seriesOptions = series.options;

                    // Handle showInLegend. If the series is linked to another series, defaults to false.
                    if (!pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? UNDEFINED : false, true)) {
                        return;
                    }

                    // use points or series for the legend item depending on legendType
                    allItems = allItems.concat(
                            series.legendItems ||
                            (seriesOptions.legendType === 'point' ?
                                    series.data :
                                    series)
                    );
                });
                return allItems;
            },

            /**
             * Adjust the chart margins by reserving space for the legend on only one side
             * of the chart. If the position is set to a corner, top or bottom is reserved
             * for horizontal legends and left or right for vertical ones.
             */
            adjustMargins: function (margin, spacing) {
                var chart = this.chart,
                    options = this.options,
                    // Use the first letter of each alignment option in order to detect the side 
                    alignment = options.align[0] + options.verticalAlign[0] + options.layout[0];

                if (this.display && !options.floating) {

                    each([
                        /(lth|ct|rth)/,
                        /(rtv|rm|rbv)/,
                        /(rbh|cb|lbh)/,
                        /(lbv|lm|ltv)/
                    ], function (alignments, side) {
                        if (alignments.test(alignment) && !defined(margin[side])) {
                            // Now we have detected on which side of the chart we should reserve space for the legend
                            chart[marginNames[side]] = mathMax(
                                chart[marginNames[side]],
                                chart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] +
                                    [1, -1, -1, 1][side] * options[(side % 2) ? 'x' : 'y'] +
                                    pick(options.margin, 12) +
                                    spacing[side]
                            );
                        }
                    });
                }
            },

            /**
             * Render the legend. This method can be called both before and after
             * chart.render. If called after, it will only rearrange items instead
             * of creating new ones.
             */
            render: function () {
                var legend = this,
                    chart = legend.chart,
                    renderer = chart.renderer,
                    legendGroup = legend.group,
                    allItems,
                    display,
                    legendWidth,
                    legendHeight,
                    box = legend.box,
                    options = legend.options,
                    padding = legend.padding,
                    legendBorderWidth = options.borderWidth,
                    legendBackgroundColor = options.backgroundColor;

                legend.itemX = legend.initialItemX;
                legend.itemY = legend.initialItemY;
                legend.offsetWidth = 0;
                legend.lastItemY = 0;

                if (!legendGroup) {
                    legend.group = legendGroup = renderer.g('legend')
                        .attr({ zIndex: 7 })
                        .add();
                    legend.contentGroup = renderer.g()
                        .attr({ zIndex: 1 }) // above background
                        .add(legendGroup);
                    legend.scrollGroup = renderer.g()
                        .add(legend.contentGroup);
                }

                legend.renderTitle();

                // add each series or point
                allItems = legend.getAllItems();

                // sort by legendIndex
                stableSort(allItems, function (a, b) {
                    return ((a.options && a.options.legendIndex) || 0) - ((b.options && b.options.legendIndex) || 0);
                });

                // reversed legend
                if (options.reversed) {
                    allItems.reverse();
                }

                legend.allItems = allItems;
                legend.display = display = !!allItems.length;

                // render the items
                legend.lastLineHeight = 0;
                each(allItems, function (item) {
                    legend.renderItem(item);
                });

                // Get the box
                legendWidth = (options.width || legend.offsetWidth) + padding;
                legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;
                legendHeight = legend.handleOverflow(legendHeight);
                legendHeight += padding;

                // Draw the border and/or background
                if (legendBorderWidth || legendBackgroundColor) {

                    if (!box) {
                        legend.box = box = renderer.rect(
                            0,
                            0,
                            legendWidth,
                            legendHeight,
                            options.borderRadius,
                            legendBorderWidth || 0
                        ).attr({
                            stroke: options.borderColor,
                            'stroke-width': legendBorderWidth || 0,
                            fill: legendBackgroundColor || NONE
                        })
                        .add(legendGroup)
                        .shadow(options.shadow);
                        box.isNew = true;

                    } else if (legendWidth > 0 && legendHeight > 0) {
                        box[box.isNew ? 'attr' : 'animate'](
                            box.crisp({ width: legendWidth, height: legendHeight })
                        );
                        box.isNew = false;
                    }

                    // hide the border if no items
                    box[display ? 'show' : 'hide']();
                }

                legend.legendWidth = legendWidth;
                legend.legendHeight = legendHeight;

                // Now that the legend width and height are established, put the items in the 
                // final position
                each(allItems, function (item) {
                    legend.positionItem(item);
                });

                // 1.x compatibility: positioning based on style
                /*var props = ['left', 'right', 'top', 'bottom'],
                    prop,
                    i = 4;
                while (i--) {
                    prop = props[i];
                    if (options.style[prop] && options.style[prop] !== 'auto') {
                        options[i < 2 ? 'align' : 'verticalAlign'] = prop;
                        options[i < 2 ? 'x' : 'y'] = pInt(options.style[prop]) * (i % 2 ? -1 : 1);
                    }
                }*/

                if (display) {
                    legendGroup.align(extend({
                        width: legendWidth,
                        height: legendHeight
                    }, options), true, 'spacingBox');
                }

                if (!chart.isResizing) {
                    this.positionCheckboxes();
                }
            },

            /**
             * Set up the overflow handling by adding navigation with up and down arrows below the
             * legend.
             */
            handleOverflow: function (legendHeight) {
                var legend = this,
                    chart = this.chart,
                    renderer = chart.renderer,
                    options = this.options,
                    optionsY = options.y,
                    alignTop = options.verticalAlign === 'top',
                    spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - this.padding,
                    maxHeight = options.maxHeight,
                    clipHeight,
                    clipRect = this.clipRect,
                    navOptions = options.navigation,
                    animation = pick(navOptions.animation, true),
                    arrowSize = navOptions.arrowSize || 12,
                    nav = this.nav,
                    pages = this.pages,
                    padding = this.padding,
                    lastY,
                    allItems = this.allItems,
                    clipToHeight = function (height) {
                        clipRect.attr({
                            height: height
                        });

                        // useHTML
                        if (legend.contentGroup.div) {
                            legend.contentGroup.div.style.clip = 'rect(' + padding + 'px,9999px,' + (padding + height) + 'px,0)';
                        }
                    };


                // Adjust the height
                if (options.layout === 'horizontal') {
                    spaceHeight /= 2;
                }
                if (maxHeight) {
                    spaceHeight = mathMin(spaceHeight, maxHeight);
                }

                // Reset the legend height and adjust the clipping rectangle
                pages.length = 0;
                if (legendHeight > spaceHeight) {

                    this.clipHeight = clipHeight = mathMax(spaceHeight - 20 - this.titleHeight - padding, 0);
                    this.currentPage = pick(this.currentPage, 1);
                    this.fullHeight = legendHeight;

                    // Fill pages with Y positions so that the top of each a legend item defines
                    // the scroll top for each page (#2098)
                    each(allItems, function (item, i) {
                        var y = item._legendItemPos[1],
                            h = mathRound(item.legendItem.getBBox().height),
                            len = pages.length;

                        if (!len || (y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1])) {
                            pages.push(lastY || y);
                            len++;
                        }

                        if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight) {
                            pages.push(y);
                        }
                        if (y !== lastY) {
                            lastY = y;
                        }
                    });

                    // Only apply clipping if needed. Clipping causes blurred legend in PDF export (#1787)
                    if (!clipRect) {
                        clipRect = legend.clipRect = renderer.clipRect(0, padding, 9999, 0);
                        legend.contentGroup.clip(clipRect);
                    }

                    clipToHeight(clipHeight);

                    // Add navigation elements
                    if (!nav) {
                        this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);
                        this.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize)
                            .on('click', function () {
                                legend.scroll(-1, animation);
                            })
                            .add(nav);
                        this.pager = renderer.text('', 15, 10)
                            .css(navOptions.style)
                            .add(nav);
                        this.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize)
                            .on('click', function () {
                                legend.scroll(1, animation);
                            })
                            .add(nav);
                    }

                    // Set initial position
                    legend.scroll(0);

                    legendHeight = spaceHeight;

                } else if (nav) {
                    clipToHeight(chart.chartHeight);
                    nav.hide();
                    this.scrollGroup.attr({
                        translateY: 1
                    });
                    this.clipHeight = 0; // #1379
                }

                return legendHeight;
            },

            /**
             * Scroll the legend by a number of pages
             * @param {Object} scrollBy
             * @param {Object} animation
             */
            scroll: function (scrollBy, animation) {
                var pages = this.pages,
                    pageCount = pages.length,
                    currentPage = this.currentPage + scrollBy,
                    clipHeight = this.clipHeight,
                    navOptions = this.options.navigation,
                    activeColor = navOptions.activeColor,
                    inactiveColor = navOptions.inactiveColor,
                    pager = this.pager,
                    padding = this.padding,
                    scrollOffset;

                // When resizing while looking at the last page
                if (currentPage > pageCount) {
                    currentPage = pageCount;
                }

                if (currentPage > 0) {

                    if (animation !== UNDEFINED) {
                        setAnimation(animation, this.chart);
                    }

                    this.nav.attr({
                        translateX: padding,
                        translateY: clipHeight + this.padding + 7 + this.titleHeight,
                        visibility: VISIBLE
                    });
                    this.up.attr({
                        fill: currentPage === 1 ? inactiveColor : activeColor
                    })
                        .css({
                            cursor: currentPage === 1 ? 'default' : 'pointer'
                        });
                    pager.attr({
                        text: currentPage + '/' + pageCount
                    });
                    this.down.attr({
                        x: 18 + this.pager.getBBox().width, // adjust to text width
                        fill: currentPage === pageCount ? inactiveColor : activeColor
                    })
                        .css({
                            cursor: currentPage === pageCount ? 'default' : 'pointer'
                        });

                    scrollOffset = -pages[currentPage - 1] + this.initialItemY;

                    this.scrollGroup.animate({
                        translateY: scrollOffset
                    });

                    this.currentPage = currentPage;
                    this.positionCheckboxes(scrollOffset);
                }

            }

        };

        /*
         * LegendSymbolMixin
         */

        var LegendSymbolMixin = Highcharts.LegendSymbolMixin = {

            /**
             * Get the series' symbol in the legend
             * 
             * @param {Object} legend The legend object
             * @param {Object} item The series (this) or point
             */
            drawRectangle: function (legend, item) {
                var symbolHeight = legend.options.symbolHeight || legend.fontMetrics.f;

                item.legendSymbol = this.chart.renderer.rect(
                    0,
                    legend.baseline - symbolHeight + 1, // #3988
                    legend.symbolWidth,
                    symbolHeight,
                    legend.options.symbolRadius || 0
                ).attr({
                    zIndex: 3
                }).add(item.legendGroup);

            },

            /**
             * Get the series' symbol in the legend. This method should be overridable to create custom 
             * symbols through Highcharts.seriesTypes[type].prototype.drawLegendSymbols.
             * 
             * @param {Object} legend The legend object
             */
            drawLineMarker: function (legend) {

                var options = this.options,
                    markerOptions = options.marker,
                    radius,
                    legendSymbol,
                    symbolWidth = legend.symbolWidth,
                    renderer = this.chart.renderer,
                    legendItemGroup = this.legendGroup,
                    verticalCenter = legend.baseline - mathRound(legend.fontMetrics.b * 0.3),
                    attr;

                // Draw the line
                if (options.lineWidth) {
                    attr = {
                        'stroke-width': options.lineWidth
                    };
                    if (options.dashStyle) {
                        attr.dashstyle = options.dashStyle;
                    }
                    this.legendLine = renderer.path([
                        M,
                        0,
                        verticalCenter,
                        L,
                        symbolWidth,
                        verticalCenter
                    ])
                    .attr(attr)
                    .add(legendItemGroup);
                }

                // Draw the marker
                if (markerOptions && markerOptions.enabled !== false) {
                    radius = markerOptions.radius;
                    this.legendSymbol = legendSymbol = renderer.symbol(
                        this.symbol,
                        (symbolWidth / 2) - radius,
                        verticalCenter - radius,
                        2 * radius,
                        2 * radius
                    )
                    .add(legendItemGroup);
                    legendSymbol.isMarker = true;
                }
            }
        };

        // Workaround for #2030, horizontal legend items not displaying in IE11 Preview,
        // and for #2580, a similar drawing flaw in Firefox 26.
        // TODO: Explore if there's a general cause for this. The problem may be related 
        // to nested group elements, as the legend item texts are within 4 group elements.
        if (/Trident\/7\.0/.test(userAgent) || isFirefox) {
            wrap(Legend.prototype, 'positionItem', function (proceed, item) {
                var legend = this,
                    runPositionItem = function () { // If chart destroyed in sync, this is undefined (#2030)
                        if (item._legendItemPos) {
                            proceed.call(legend, item);
                        }
                    };

                // Do it now, for export and to get checkbox placement
                runPositionItem();

                // Do it after to work around the core issue
                setTimeout(runPositionItem);
            });
        }
        /**
         * The chart class
         * @param {Object} options
         * @param {Function} callback Function to run when the chart has loaded
         */
        var Chart = Highcharts.Chart = function () {
            this.init.apply(this, arguments);
        };

        Chart.prototype = {

            /**
             * Hook for modules
             */
            callbacks: [],

            /**
             * Initialize the chart
             */
            init: function (userOptions, callback) {

                // Handle regular options
                var options,
                    seriesOptions = userOptions.series; // skip merging data points to increase performance

                userOptions.series = null;
                options = merge(defaultOptions, userOptions); // do the merge
                options.series = userOptions.series = seriesOptions; // set back the series data
                this.userOptions = userOptions;

                var optionsChart = options.chart;

                // Create margin & spacing array
                this.margin = this.splashArray('margin', optionsChart);
                this.spacing = this.splashArray('spacing', optionsChart);

                var chartEvents = optionsChart.events;

                //this.runChartClick = chartEvents && !!chartEvents.click;
                this.bounds = { h: {}, v: {} }; // Pixel data bounds for touch zoom

                this.callback = callback;
                this.isResizing = 0;
                this.options = options;
                //chartTitleOptions = UNDEFINED;
                //chartSubtitleOptions = UNDEFINED;

                this.axes = [];
                this.series = [];
                this.hasCartesianSeries = optionsChart.showAxes;
                //this.axisOffset = UNDEFINED;
                //this.maxTicks = UNDEFINED; // handle the greatest amount of ticks on grouped axes
                //this.inverted = UNDEFINED;
                //this.loadingShown = UNDEFINED;
                //this.container = UNDEFINED;
                //this.chartWidth = UNDEFINED;
                //this.chartHeight = UNDEFINED;
                //this.marginRight = UNDEFINED;
                //this.marginBottom = UNDEFINED;
                //this.containerWidth = UNDEFINED;
                //this.containerHeight = UNDEFINED;
                //this.oldChartWidth = UNDEFINED;
                //this.oldChartHeight = UNDEFINED;

                //this.renderTo = UNDEFINED;
                //this.renderToClone = UNDEFINED;

                //this.spacingBox = UNDEFINED

                //this.legend = UNDEFINED;

                // Elements
                //this.chartBackground = UNDEFINED;
                //this.plotBackground = UNDEFINED;
                //this.plotBGImage = UNDEFINED;
                //this.plotBorder = UNDEFINED;
                //this.loadingDiv = UNDEFINED;
                //this.loadingSpan = UNDEFINED;

                var chart = this,
                    eventType;

                // Add the chart to the global lookup
                chart.index = charts.length;
                charts.push(chart);
                chartCount++;

                // Set up auto resize
                if (optionsChart.reflow !== false) {
                    addEvent(chart, 'load', function () {
                        chart.initReflow();
                    });
                }

                // Chart event handlers
                if (chartEvents) {
                    for (eventType in chartEvents) {
                        addEvent(chart, eventType, chartEvents[eventType]);
                    }
                }

                chart.xAxis = [];
                chart.yAxis = [];

                // Expose methods and variables
                chart.animation = useCanVG ? false : pick(optionsChart.animation, true);
                chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;

                chart.firstRender();
            },

            /**
             * Initialize an individual series, called internally before render time
             */
            initSeries: function (options) {
                var chart = this,
                    optionsChart = chart.options.chart,
                    type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
                    series,
                    constr = seriesTypes[type];

                // No such series type
                if (!constr) {
                    error(17, true);
                }

                series = new constr();
                series.init(this, options);
                return series;
            },

            /**
             * Check whether a given point is within the plot area
             *
             * @param {Number} plotX Pixel x relative to the plot area
             * @param {Number} plotY Pixel y relative to the plot area
             * @param {Boolean} inverted Whether the chart is inverted
             */
            isInsidePlot: function (plotX, plotY, inverted) {
                var x = inverted ? plotY : plotX,
                    y = inverted ? plotX : plotY;

                return x >= 0 &&
                    x <= this.plotWidth &&
                    y >= 0 &&
                    y <= this.plotHeight;
            },

            /**
             * Redraw legend, axes or series based on updated data
             *
             * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
             *    configuration
             */
            redraw: function (animation) {
                var chart = this,
                    axes = chart.axes,
                    series = chart.series,
                    pointer = chart.pointer,
                    legend = chart.legend,
                    redrawLegend = chart.isDirtyLegend,
                    hasStackedSeries,
                    hasDirtyStacks,
                    hasCartesianSeries = chart.hasCartesianSeries,
                    isDirtyBox = chart.isDirtyBox, // todo: check if it has actually changed?
                    seriesLength = series.length,
                    i = seriesLength,
                    serie,
                    renderer = chart.renderer,
                    isHiddenChart = renderer.isHidden(),
                    afterRedraw = [];

                setAnimation(animation, chart);

                if (isHiddenChart) {
                    chart.cloneRenderTo();
                }

                // Adjust title layout (reflow multiline text)
                chart.layOutTitles();

                // link stacked series
                while (i--) {
                    serie = series[i];

                    if (serie.options.stacking) {
                        hasStackedSeries = true;

                        if (serie.isDirty) {
                            hasDirtyStacks = true;
                            break;
                        }
                    }
                }
                if (hasDirtyStacks) { // mark others as dirty
                    i = seriesLength;
                    while (i--) {
                        serie = series[i];
                        if (serie.options.stacking) {
                            serie.isDirty = true;
                        }
                    }
                }

                // Handle updated data in the series
                each(series, function (serie) {
                    if (serie.isDirty) {
                        if (serie.options.legendType === 'point') {
                            if (serie.updateTotals) {
                                serie.updateTotals();
                            }
                            redrawLegend = true;
                        }
                    }
                });

                // handle added or removed series
                if (redrawLegend && legend.options.enabled) { // series or pie points are added or removed
                    // draw legend graphics
                    legend.render();

                    chart.isDirtyLegend = false;
                }

                // reset stacks
                if (hasStackedSeries) {
                    chart.getStacks();
                }


                if (hasCartesianSeries) {
                    if (!chart.isResizing) {

                        // reset maxTicks
                        chart.maxTicks = null;

                        // set axes scales
                        each(axes, function (axis) {
                            axis.setScale();
                        });
                    }
                }

                chart.getMargins(); // #3098

                if (hasCartesianSeries) {
                    // If one axis is dirty, all axes must be redrawn (#792, #2169)
                    each(axes, function (axis) {
                        if (axis.isDirty) {
                            isDirtyBox = true;
                        }
                    });

                    // redraw axes
                    each(axes, function (axis) {

                        // Fire 'afterSetExtremes' only if extremes are set
                        if (axis.isDirtyExtremes) { // #821
                            axis.isDirtyExtremes = false;
                            afterRedraw.push(function () { // prevent a recursive call to chart.redraw() (#1119)
                                fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751
                                delete axis.eventArgs;
                            });
                        }

                        if (isDirtyBox || hasStackedSeries) {
                            axis.redraw();
                        }
                    });
                }

                // the plot areas size has changed
                if (isDirtyBox) {
                    chart.drawChartBox();
                }


                // redraw affected series
                each(series, function (serie) {
                    if (serie.isDirty && serie.visible &&
                            (!serie.isCartesian || serie.xAxis)) { // issue #153
                        serie.redraw();
                    }
                });

                // move tooltip or reset
                if (pointer) {
                    pointer.reset(true);
                }

                // redraw if canvas
                renderer.draw();

                // fire the event
                fireEvent(chart, 'redraw'); // jQuery breaks this when calling it from addEvent. Overwrites chart.redraw

                if (isHiddenChart) {
                    chart.cloneRenderTo(true);
                }

                // Fire callbacks that are put on hold until after the redraw
                each(afterRedraw, function (callback) {
                    callback.call();
                });
            },

            /**
             * Get an axis, series or point object by id.
             * @param id {String} The id as given in the configuration options
             */
            get: function (id) {
                var chart = this,
                    axes = chart.axes,
                    series = chart.series;

                var i,
                    j,
                    points;

                // search axes
                for (i = 0; i < axes.length; i++) {
                    if (axes[i].options.id === id) {
                        return axes[i];
                    }
                }

                // search series
                for (i = 0; i < series.length; i++) {
                    if (series[i].options.id === id) {
                        return series[i];
                    }
                }

                // search points
                for (i = 0; i < series.length; i++) {
                    points = series[i].points || [];
                    for (j = 0; j < points.length; j++) {
                        if (points[j].id === id) {
                            return points[j];
                        }
                    }
                }
                return null;
            },

            /**
             * Create the Axis instances based on the config options
             */
            getAxes: function () {
                var chart = this,
                    options = this.options,
                    xAxisOptions = options.xAxis = splat(options.xAxis || {}),
                    yAxisOptions = options.yAxis = splat(options.yAxis || {}),
                    optionsArray,
                    axis;

                // make sure the options are arrays and add some members
                each(xAxisOptions, function (axis, i) {
                    axis.index = i;
                    axis.isX = true;
                });

                each(yAxisOptions, function (axis, i) {
                    axis.index = i;
                });

                // concatenate all axis options into one array
                optionsArray = xAxisOptions.concat(yAxisOptions);

                each(optionsArray, function (axisOptions) {
                    axis = new Axis(chart, axisOptions);
                });
            },


            /**
             * Get the currently selected points from all series
             */
            getSelectedPoints: function () {
                var points = [];
                each(this.series, function (serie) {
                    points = points.concat(grep(serie.points || [], function (point) {
                        return point.selected;
                    }));
                });
                return points;
            },

            /**
             * Get the currently selected series
             */
            getSelectedSeries: function () {
                return grep(this.series, function (serie) {
                    return serie.selected;
                });
            },

            /**
             * Generate stacks for each series and calculate stacks total values
             */
            getStacks: function () {
                var chart = this;

                // reset stacks for each yAxis
                each(chart.yAxis, function (axis) {
                    if (axis.stacks && axis.hasVisibleSeries) {
                        axis.oldStacks = axis.stacks;
                    }
                });

                each(chart.series, function (series) {
                    if (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {
                        series.stackKey = series.type + pick(series.options.stack, '');
                    }
                });
            },

            /**
             * Show the title and subtitle of the chart
             *
             * @param titleOptions {Object} New title options
             * @param subtitleOptions {Object} New subtitle options
             *
             */
            setTitle: function (titleOptions, subtitleOptions, redraw) {
                var chart = this,
                    options = chart.options,
                    chartTitleOptions,
                    chartSubtitleOptions;

                chartTitleOptions = options.title = merge(options.title, titleOptions);
                chartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions);

                // add title and subtitle
                each([
                    ['title', titleOptions, chartTitleOptions],
                    ['subtitle', subtitleOptions, chartSubtitleOptions]
                ], function (arr) {
                    var name = arr[0],
                        title = chart[name],
                        titleOptions = arr[1],
                        chartTitleOptions = arr[2];

                    if (title && titleOptions) {
                        chart[name] = title = title.destroy(); // remove old
                    }

                    if (chartTitleOptions && chartTitleOptions.text && !title) {
                        chart[name] = chart.renderer.text(
                            chartTitleOptions.text,
                            0,
                            0,
                            chartTitleOptions.useHTML
                        )
                        .attr({
                            align: chartTitleOptions.align,
                            'class': PREFIX + name,
                            zIndex: chartTitleOptions.zIndex || 4
                        })
                        .css(chartTitleOptions.style)
                        .add();
                    }
                });
                chart.layOutTitles(redraw);
            },

            /**
             * Lay out the chart titles and cache the full offset height for use in getMargins
             */
            layOutTitles: function (redraw) {
                var titleOffset = 0,
                    title = this.title,
                    subtitle = this.subtitle,
                    options = this.options,
                    titleOptions = options.title,
                    subtitleOptions = options.subtitle,
                    requiresDirtyBox,
                    renderer = this.renderer,
                    autoWidth = this.spacingBox.width - 44; // 44 makes room for default context button

                if (title) {
                    title
                        .css({ width: (titleOptions.width || autoWidth) + PX })
                        .align(extend({
                            y: renderer.fontMetrics(titleOptions.style.fontSize, title).b - 3
                        }, titleOptions), false, 'spacingBox');

                    if (!titleOptions.floating && !titleOptions.verticalAlign) {
                        titleOffset = title.getBBox().height;
                    }
                }
                if (subtitle) {
                    subtitle
                        .css({ width: (subtitleOptions.width || autoWidth) + PX })
                        .align(extend({
                            y: titleOffset + (titleOptions.margin - 13) + renderer.fontMetrics(titleOptions.style.fontSize, subtitle).b
                        }, subtitleOptions), false, 'spacingBox');

                    if (!subtitleOptions.floating && !subtitleOptions.verticalAlign) {
                        titleOffset = mathCeil(titleOffset + subtitle.getBBox().height);
                    }
                }

                requiresDirtyBox = this.titleOffset !== titleOffset;
                this.titleOffset = titleOffset; // used in getMargins

                if (!this.isDirtyBox && requiresDirtyBox) {
                    this.isDirtyBox = requiresDirtyBox;
                    // Redraw if necessary (#2719, #2744)		
                    if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {
                        this.redraw();
                    }
                }
            },

            /**
             * Get chart width and height according to options and container size
             */
            getChartSize: function () {
                var chart = this,
                    optionsChart = chart.options.chart,
                    widthOption = optionsChart.width,
                    heightOption = optionsChart.height,
                    renderTo = chart.renderToClone || chart.renderTo;

                // get inner width and height from jQuery (#824)
                if (!defined(widthOption)) {
                    chart.containerWidth = adapterRun(renderTo, 'width');
                }
                if (!defined(heightOption)) {
                    chart.containerHeight = adapterRun(renderTo, 'height');
                }

                chart.chartWidth = mathMax(0, widthOption || chart.containerWidth || 600); // #1393, 1460
                chart.chartHeight = mathMax(0, pick(heightOption,
                    // the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:
                    chart.containerHeight > 19 ? chart.containerHeight : 400));
            },

            /**
             * Create a clone of the chart's renderTo div and place it outside the viewport to allow
             * size computation on chart.render and chart.redraw
             */
            cloneRenderTo: function (revert) {
                var clone = this.renderToClone,
                    container = this.container;

                // Destroy the clone and bring the container back to the real renderTo div
                if (revert) {
                    if (clone) {
                        this.renderTo.appendChild(container);
                        discardElement(clone);
                        delete this.renderToClone;
                    }

                    // Set up the clone
                } else {
                    if (container && container.parentNode === this.renderTo) {
                        this.renderTo.removeChild(container); // do not clone this
                    }
                    this.renderToClone = clone = this.renderTo.cloneNode(0);
                    css(clone, {
                        position: ABSOLUTE,
                        top: '-9999px',
                        display: 'block' // #833
                    });
                    if (clone.style.setProperty) { // #2631
                        clone.style.setProperty('display', 'block', 'important');
                    }
                    doc.body.appendChild(clone);
                    if (container) {
                        clone.appendChild(container);
                    }
                }
            },

            /**
             * Get the containing element, determine the size and create the inner container
             * div to hold the chart
             */
            getContainer: function () {
                var chart = this,
                    container,
                    optionsChart = chart.options.chart,
                    chartWidth,
                    chartHeight,
                    renderTo,
                    indexAttrName = 'data-highcharts-chart',
                    oldChartIndex,
                    containerId;

                chart.renderTo = renderTo = optionsChart.renderTo;
                containerId = PREFIX + idCounter++;

                if (isString(renderTo)) {
                    chart.renderTo = renderTo = doc.getElementById(renderTo);
                }

                // Display an error if the renderTo is wrong
                if (!renderTo) {
                    error(13, true);
                }

                // If the container already holds a chart, destroy it. The check for hasRendered is there
                // because web pages that are saved to disk from the browser, will preserve the data-highcharts-chart
                // attribute and the SVG contents, but not an interactive chart. So in this case,
                // charts[oldChartIndex] will point to the wrong chart if any (#2609).
                oldChartIndex = pInt(attr(renderTo, indexAttrName));
                if (!isNaN(oldChartIndex) && charts[oldChartIndex] && charts[oldChartIndex].hasRendered) {
                    charts[oldChartIndex].destroy();
                }

                // Make a reference to the chart from the div
                attr(renderTo, indexAttrName, chart.index);

                // remove previous chart
                renderTo.innerHTML = '';

                // If the container doesn't have an offsetWidth, it has or is a child of a node
                // that has display:none. We need to temporarily move it out to a visible
                // state to determine the size, else the legend and tooltips won't render
                // properly. The allowClone option is used in sparklines as a micro optimization,
                // saving about 1-2 ms each chart.
                if (!optionsChart.skipClone && !renderTo.offsetWidth) {
                    chart.cloneRenderTo();
                }

                // get the width and height
                chart.getChartSize();
                chartWidth = chart.chartWidth;
                chartHeight = chart.chartHeight;

                // create the inner container
                chart.container = container = createElement(DIV, {
                    className: PREFIX + 'container' +
                        (optionsChart.className ? ' ' + optionsChart.className : ''),
                    id: containerId
                }, extend({
                    position: RELATIVE,
                    overflow: HIDDEN, // needed for context menu (avoid scrollbars) and
                    // content overflow in IE
                    width: chartWidth + PX,
                    height: chartHeight + PX,
                    textAlign: 'left',
                    lineHeight: 'normal', // #427
                    zIndex: 0, // #1072
                    '-webkit-tap-highlight-color': 'rgba(0,0,0,0)'
                }, optionsChart.style),
                    chart.renderToClone || renderTo
                );

                // cache the cursor (#1650)
                chart._cursor = container.style.cursor;

                // Initialize the renderer
                chart.renderer =
                    optionsChart.forExport ? // force SVG, used for SVG export
                        new SVGRenderer(container, chartWidth, chartHeight, optionsChart.style, true) :
                        new Renderer(container, chartWidth, chartHeight, optionsChart.style);

                if (useCanVG) {
                    // If we need canvg library, extend and configure the renderer
                    // to get the tracker for translating mouse events
                    chart.renderer.create(chart, container, chartWidth, chartHeight);
                }
                // Add a reference to the charts index
                chart.renderer.chartIndex = chart.index;
            },

            /**
             * Calculate margins by rendering axis labels in a preliminary position. Title,
             * subtitle and legend have already been rendered at this stage, but will be
             * moved into their final positions
             */
            getMargins: function (skipAxes) {
                var chart = this,
                    spacing = chart.spacing,
                    margin = chart.margin,
                    titleOffset = chart.titleOffset;

                chart.resetMargins();

                // Adjust for title and subtitle
                if (titleOffset && !defined(margin[0])) {
                    chart.plotTop = mathMax(chart.plotTop, titleOffset + chart.options.title.margin + spacing[0]);
                }

                // Adjust for legend
                chart.legend.adjustMargins(margin, spacing);

                // adjust for scroller
                if (chart.extraBottomMargin) {
                    chart.marginBottom += chart.extraBottomMargin;
                }
                if (chart.extraTopMargin) {
                    chart.plotTop += chart.extraTopMargin;
                }
                if (!skipAxes) {
                    this.getAxisMargins();
                }
            },

            getAxisMargins: function () {

                var chart = this,
                    axisOffset = chart.axisOffset = [0, 0, 0, 0], // top, right, bottom, left
                    margin = chart.margin;

                // pre-render axes to get labels offset width
                if (chart.hasCartesianSeries) {
                    each(chart.axes, function (axis) {
                        axis.getOffset();
                    });
                }

                // Add the axis offsets
                each(marginNames, function (m, side) {
                    if (!defined(margin[side])) {
                        chart[m] += axisOffset[side];
                    }
                });

                chart.setChartSize();

            },

            /**
             * Resize the chart to its container if size is not explicitly set
             */
            reflow: function (e) {
                var chart = this,
                    optionsChart = chart.options.chart,
                    renderTo = chart.renderTo,
                    width = optionsChart.width || adapterRun(renderTo, 'width'),
                    height = optionsChart.height || adapterRun(renderTo, 'height'),
                    target = e ? e.target : win, // #805 - MooTools doesn't supply e
                    doReflow = function () {
                        if (chart.container) { // It may have been destroyed in the meantime (#1257)
                            chart.setSize(width, height, false);
                            chart.hasUserSize = null;
                        }
                    };

                // Width and height checks for display:none. Target is doc in IE8 and Opera,
                // win in Firefox, Chrome and IE9.
                if (!chart.hasUserSize && !chart.isPrinting && width && height && (target === win || target === doc)) { // #1093
                    if (width !== chart.containerWidth || height !== chart.containerHeight) {
                        clearTimeout(chart.reflowTimeout);
                        if (e) { // Called from window.resize
                            chart.reflowTimeout = setTimeout(doReflow, 100);
                        } else { // Called directly (#2224)
                            doReflow();
                        }
                    }
                    chart.containerWidth = width;
                    chart.containerHeight = height;
                }
            },

            /**
             * Add the event handlers necessary for auto resizing
             */
            initReflow: function () {
                var chart = this,
                    reflow = function (e) {
                        chart.reflow(e);
                    };


                addEvent(win, 'resize', reflow);
                addEvent(chart, 'destroy', function () {
                    removeEvent(win, 'resize', reflow);
                });
            },

            /**
             * Resize the chart to a given width and height
             * @param {Number} width
             * @param {Number} height
             * @param {Object|Boolean} animation
             */
            setSize: function (width, height, animation) {
                var chart = this,
                    chartWidth,
                    chartHeight,
                    fireEndResize;

                // Handle the isResizing counter
                chart.isResizing += 1;
                fireEndResize = function () {
                    if (chart) {
                        fireEvent(chart, 'endResize', null, function () {
                            chart.isResizing -= 1;
                        });
                    }
                };

                // set the animation for the current process
                setAnimation(animation, chart);

                chart.oldChartHeight = chart.chartHeight;
                chart.oldChartWidth = chart.chartWidth;
                if (defined(width)) {
                    chart.chartWidth = chartWidth = mathMax(0, mathRound(width));
                    chart.hasUserSize = !!chartWidth;
                }
                if (defined(height)) {
                    chart.chartHeight = chartHeight = mathMax(0, mathRound(height));
                }

                // Resize the container with the global animation applied if enabled (#2503)
                (globalAnimation ? animate : css)(chart.container, {
                    width: chartWidth + PX,
                    height: chartHeight + PX
                }, globalAnimation);

                chart.setChartSize(true);
                chart.renderer.setSize(chartWidth, chartHeight, animation);

                // handle axes
                chart.maxTicks = null;
                each(chart.axes, function (axis) {
                    axis.isDirty = true;
                    axis.setScale();
                });

                // make sure non-cartesian series are also handled
                each(chart.series, function (serie) {
                    serie.isDirty = true;
                });

                chart.isDirtyLegend = true; // force legend redraw
                chart.isDirtyBox = true; // force redraw of plot and chart border

                chart.layOutTitles(); // #2857
                chart.getMargins();

                chart.redraw(animation);


                chart.oldChartHeight = null;
                fireEvent(chart, 'resize');

                // fire endResize and set isResizing back
                // If animation is disabled, fire without delay
                if (globalAnimation === false) {
                    fireEndResize();
                } else { // else set a timeout with the animation duration
                    setTimeout(fireEndResize, (globalAnimation && globalAnimation.duration) || 500);
                }
            },

            /**
             * Set the public chart properties. This is done before and after the pre-render
             * to determine margin sizes
             */
            setChartSize: function (skipAxes) {
                var chart = this,
                    inverted = chart.inverted,
                    renderer = chart.renderer,
                    chartWidth = chart.chartWidth,
                    chartHeight = chart.chartHeight,
                    optionsChart = chart.options.chart,
                    spacing = chart.spacing,
                    clipOffset = chart.clipOffset,
                    clipX,
                    clipY,
                    plotLeft,
                    plotTop,
                    plotWidth,
                    plotHeight,
                    plotBorderWidth;

                chart.plotLeft = plotLeft = mathRound(chart.plotLeft);
                chart.plotTop = plotTop = mathRound(chart.plotTop);
                chart.plotWidth = plotWidth = mathMax(0, mathRound(chartWidth - plotLeft - chart.marginRight));
                chart.plotHeight = plotHeight = mathMax(0, mathRound(chartHeight - plotTop - chart.marginBottom));

                chart.plotSizeX = inverted ? plotHeight : plotWidth;
                chart.plotSizeY = inverted ? plotWidth : plotHeight;

                chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;

                // Set boxes used for alignment
                chart.spacingBox = renderer.spacingBox = {
                    x: spacing[3],
                    y: spacing[0],
                    width: chartWidth - spacing[3] - spacing[1],
                    height: chartHeight - spacing[0] - spacing[2]
                };
                chart.plotBox = renderer.plotBox = {
                    x: plotLeft,
                    y: plotTop,
                    width: plotWidth,
                    height: plotHeight
                };

                plotBorderWidth = 2 * mathFloor(chart.plotBorderWidth / 2);
                clipX = mathCeil(mathMax(plotBorderWidth, clipOffset[3]) / 2);
                clipY = mathCeil(mathMax(plotBorderWidth, clipOffset[0]) / 2);
                chart.clipBox = {
                    x: clipX,
                    y: clipY,
                    width: mathFloor(chart.plotSizeX - mathMax(plotBorderWidth, clipOffset[1]) / 2 - clipX),
                    height: mathMax(0, mathFloor(chart.plotSizeY - mathMax(plotBorderWidth, clipOffset[2]) / 2 - clipY))
                };

                if (!skipAxes) {
                    each(chart.axes, function (axis) {
                        axis.setAxisSize();
                        axis.setAxisTranslation();
                    });
                }
            },

            /**
             * Initial margins before auto size margins are applied
             */
            resetMargins: function () {
                var chart = this;

                each(marginNames, function (m, side) {
                    chart[m] = pick(chart.margin[side], chart.spacing[side]);
                });
                chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
                chart.clipOffset = [0, 0, 0, 0];
            },

            /**
             * Draw the borders and backgrounds for chart and plot area
             */
            drawChartBox: function () {
                var chart = this,
                    optionsChart = chart.options.chart,
                    renderer = chart.renderer,
                    chartWidth = chart.chartWidth,
                    chartHeight = chart.chartHeight,
                    chartBackground = chart.chartBackground,
                    plotBackground = chart.plotBackground,
                    plotBorder = chart.plotBorder,
                    plotBGImage = chart.plotBGImage,
                    chartBorderWidth = optionsChart.borderWidth || 0,
                    chartBackgroundColor = optionsChart.backgroundColor,
                    plotBackgroundColor = optionsChart.plotBackgroundColor,
                    plotBackgroundImage = optionsChart.plotBackgroundImage,
                    plotBorderWidth = optionsChart.plotBorderWidth || 0,
                    mgn,
                    bgAttr,
                    plotLeft = chart.plotLeft,
                    plotTop = chart.plotTop,
                    plotWidth = chart.plotWidth,
                    plotHeight = chart.plotHeight,
                    plotBox = chart.plotBox,
                    clipRect = chart.clipRect,
                    clipBox = chart.clipBox;

                // Chart area
                mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);

                if (chartBorderWidth || chartBackgroundColor) {
                    if (!chartBackground) {

                        bgAttr = {
                            fill: chartBackgroundColor || NONE
                        };
                        if (chartBorderWidth) { // #980
                            bgAttr.stroke = optionsChart.borderColor;
                            bgAttr['stroke-width'] = chartBorderWidth;
                        }
                        chart.chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn,
                                optionsChart.borderRadius, chartBorderWidth)
                            .attr(bgAttr)
                            .addClass(PREFIX + 'background')
                            .add()
                            .shadow(optionsChart.shadow);

                    } else { // resize
                        chartBackground.animate(
                            chartBackground.crisp({ width: chartWidth - mgn, height: chartHeight - mgn })
                        );
                    }
                }


                // Plot background
                if (plotBackgroundColor) {
                    if (!plotBackground) {
                        chart.plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)
                            .attr({
                                fill: plotBackgroundColor
                            })
                            .add()
                            .shadow(optionsChart.plotShadow);
                    } else {
                        plotBackground.animate(plotBox);
                    }
                }
                if (plotBackgroundImage) {
                    if (!plotBGImage) {
                        chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)
                            .add();
                    } else {
                        plotBGImage.animate(plotBox);
                    }
                }

                // Plot clip
                if (!clipRect) {
                    chart.clipRect = renderer.clipRect(clipBox);
                } else {
                    clipRect.animate({
                        width: clipBox.width,
                        height: clipBox.height
                    });
                }

                // Plot area border
                if (plotBorderWidth) {
                    if (!plotBorder) {
                        chart.plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, -plotBorderWidth)
                            .attr({
                                stroke: optionsChart.plotBorderColor,
                                'stroke-width': plotBorderWidth,
                                fill: NONE,
                                zIndex: 1
                            })
                            .add();
                    } else {
                        plotBorder.animate(
                            plotBorder.crisp({ x: plotLeft, y: plotTop, width: plotWidth, height: plotHeight, strokeWidth: -plotBorderWidth }) //#3282 plotBorder should be negative
                        );
                    }
                }

                // reset
                chart.isDirtyBox = false;
            },

            /**
             * Detect whether a certain chart property is needed based on inspecting its options
             * and series. This mainly applies to the chart.invert property, and in extensions to 
             * the chart.angular and chart.polar properties.
             */
            propFromSeries: function () {
                var chart = this,
                    optionsChart = chart.options.chart,
                    klass,
                    seriesOptions = chart.options.series,
                    i,
                    value;


                each(['inverted', 'angular', 'polar'], function (key) {

                    // The default series type's class
                    klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];

                    // Get the value from available chart-wide properties
                    value = (
                        chart[key] || // 1. it is set before
                        optionsChart[key] || // 2. it is set in the options
                        (klass && klass.prototype[key]) // 3. it's default series class requires it
                    );

                    // 4. Check if any the chart's series require it
                    i = seriesOptions && seriesOptions.length;
                    while (!value && i--) {
                        klass = seriesTypes[seriesOptions[i].type];
                        if (klass && klass.prototype[key]) {
                            value = true;
                        }
                    }

                    // Set the chart property
                    chart[key] = value;
                });

            },

            /**
             * Link two or more series together. This is done initially from Chart.render,
             * and after Chart.addSeries and Series.remove.
             */
            linkSeries: function () {
                var chart = this,
                    chartSeries = chart.series;

                // Reset links
                each(chartSeries, function (series) {
                    series.linkedSeries.length = 0;
                });

                // Apply new links
                each(chartSeries, function (series) {
                    var linkedTo = series.options.linkedTo;
                    if (isString(linkedTo)) {
                        if (linkedTo === ':previous') {
                            linkedTo = chart.series[series.index - 1];
                        } else {
                            linkedTo = chart.get(linkedTo);
                        }
                        if (linkedTo) {
                            linkedTo.linkedSeries.push(series);
                            series.linkedParent = linkedTo;
                        }
                    }
                });
            },

            /**
             * Render series for the chart
             */
            renderSeries: function () {
                each(this.series, function (serie) {
                    serie.translate();
                    serie.render();
                });
            },

            /**
             * Render labels for the chart
             */
            renderLabels: function () {
                var chart = this,
                    labels = chart.options.labels;
                if (labels.items) {
                    each(labels.items, function (label) {
                        var style = extend(labels.style, label.style),
                            x = pInt(style.left) + chart.plotLeft,
                            y = pInt(style.top) + chart.plotTop + 12;

                        // delete to prevent rewriting in IE
                        delete style.left;
                        delete style.top;

                        chart.renderer.text(
                            label.html,
                            x,
                            y
                        )
                        .attr({ zIndex: 2 })
                        .css(style)
                        .add();

                    });
                }
            },

            /**
             * Render all graphics for the chart
             */
            render: function () {
                var chart = this,
                    axes = chart.axes,
                    renderer = chart.renderer,
                    options = chart.options,
                    tempWidth,
                    tempHeight,
                    redoHorizontal,
                    redoVertical;

                // Title
                chart.setTitle();


                // Legend
                chart.legend = new Legend(chart, options.legend);

                chart.getStacks(); // render stacks

                // Get chart margins
                chart.getMargins(true);
                chart.setChartSize();

                // Record preliminary dimensions for later comparison
                tempWidth = chart.plotWidth;
                tempHeight = chart.plotHeight = chart.plotHeight - 13; // 13 is the most common height of X axis labels

                // Get margins by pre-rendering axes
                each(axes, function (axis) {
                    axis.setScale();
                });
                chart.getAxisMargins();

                // If the plot area size has changed significantly, calculate tick positions again
                redoHorizontal = tempWidth / chart.plotWidth > 1.1;
                redoVertical = tempHeight / chart.plotHeight > 1.1;

                if (redoHorizontal || redoVertical) {

                    chart.maxTicks = null; // reset for second pass
                    each(axes, function (axis) {
                        if ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {
                            axis.setTickInterval(true); // update to reflect the new margins
                        }
                    });
                    chart.getMargins(); // second pass to check for new labels
                }

                // Draw the borders and backgrounds
                chart.drawChartBox();


                // Axes
                if (chart.hasCartesianSeries) {
                    each(axes, function (axis) {
                        axis.render();
                    });
                }

                // The series
                if (!chart.seriesGroup) {
                    chart.seriesGroup = renderer.g('series-group')
                        .attr({ zIndex: 3 })
                        .add();
                }
                chart.renderSeries();

                // Labels
                chart.renderLabels();

                // Credits
                chart.showCredits(options.credits);

                // Set flag
                chart.hasRendered = true;

            },

            /**
             * Show chart credits based on config options
             */
            showCredits: function (credits) {
                if (credits.enabled && !this.credits) {
                    this.credits = this.renderer.text(
                        credits.text,
                        0,
                        0
                    )
                    .on('click', function () {
                        if (credits.href) {
                            location.href = credits.href;
                        }
                    })
                    .attr({
                        align: credits.position.align,
                        zIndex: 8
                    })
                    .css(credits.style)
                    .add()
                    .align(credits.position);
                }
            },

            /**
             * Clean up memory usage
             */
            destroy: function () {
                var chart = this,
                    axes = chart.axes,
                    series = chart.series,
                    container = chart.container,
                    i,
                    parentNode = container && container.parentNode;

                // fire the chart.destoy event
                fireEvent(chart, 'destroy');

                // Delete the chart from charts lookup array
                charts[chart.index] = UNDEFINED;
                chartCount--;
                chart.renderTo.removeAttribute('data-highcharts-chart');

                // remove events
                removeEvent(chart);

                // ==== Destroy collections:
                // Destroy axes
                i = axes.length;
                while (i--) {
                    axes[i] = axes[i].destroy();
                }

                // Destroy each series
                i = series.length;
                while (i--) {
                    series[i] = series[i].destroy();
                }

                // ==== Destroy chart properties:
                each(['title', 'subtitle', 'chartBackground', 'plotBackground', 'plotBGImage',
                        'plotBorder', 'seriesGroup', 'clipRect', 'credits', 'pointer', 'scroller',
                        'rangeSelector', 'legend', 'resetZoomButton', 'tooltip', 'renderer'], function (name) {
                            var prop = chart[name];

                            if (prop && prop.destroy) {
                                chart[name] = prop.destroy();
                            }
                        });

                // remove container and all SVG
                if (container) { // can break in IE when destroyed before finished loading
                    container.innerHTML = '';
                    removeEvent(container);
                    if (parentNode) {
                        discardElement(container);
                    }

                }

                // clean it all up
                for (i in chart) {
                    delete chart[i];
                }

            },


            /**
             * VML namespaces can't be added until after complete. Listening
             * for Perini's doScroll hack is not enough.
             */
            isReadyToRender: function () {
                var chart = this;

                // Note: in spite of JSLint's complaints, win == win.top is required
                /*jslint eqeq: true*/
                if ((!hasSVG && (win == win.top && doc.readyState !== 'complete')) || (useCanVG && !win.canvg)) {
                    /*jslint eqeq: false*/
                    if (useCanVG) {
                        // Delay rendering until canvg library is downloaded and ready
                        CanVGController.push(function () { chart.firstRender(); }, chart.options.global.canvasToolsURL);
                    } else {
                        doc.attachEvent('onreadystatechange', function () {
                            doc.detachEvent('onreadystatechange', chart.firstRender);
                            if (doc.readyState === 'complete') {
                                chart.firstRender();
                            }
                        });
                    }
                    return false;
                }
                return true;
            },

            /**
             * Prepare for first rendering after all data are loaded
             */
            firstRender: function () {
                var chart = this,
                    options = chart.options,
                    callback = chart.callback;

                // Check whether the chart is ready to render
                if (!chart.isReadyToRender()) {
                    return;
                }

                // Create the container
                chart.getContainer();

                // Run an early event after the container and renderer are established
                fireEvent(chart, 'init');


                chart.resetMargins();
                chart.setChartSize();

                // Set the common chart properties (mainly invert) from the given series
                chart.propFromSeries();

                // get axes
                chart.getAxes();

                // Initialize the series
                each(options.series || [], function (serieOptions) {
                    chart.initSeries(serieOptions);
                });

                chart.linkSeries();

                // Run an event after axes and series are initialized, but before render. At this stage,
                // the series data is indexed and cached in the xData and yData arrays, so we can access
                // those before rendering. Used in Highstock. 
                fireEvent(chart, 'beforeRender');

                // depends on inverted and on margins being set
                if (Highcharts.Pointer) {
                    chart.pointer = new Pointer(chart, options);
                }

                chart.render();

                // add canvas
                chart.renderer.draw();
                // run callbacks
                if (callback) {
                    callback.apply(chart, [chart]);
                }
                each(chart.callbacks, function (fn) {
                    if (chart.index !== UNDEFINED) { // Chart destroyed in its own callback (#3600)
                        fn.apply(chart, [chart]);
                    }
                });

                // Fire the load event
                fireEvent(chart, 'load');

                // If the chart was rendered outside the top container, put it back in (#3679)
                chart.cloneRenderTo(true);

            },

            /**
            * Creates arrays for spacing and margin from given options.
            */
            splashArray: function (target, options) {
                var oVar = options[target],
                    tArray = isObject(oVar) ? oVar : [oVar, oVar, oVar, oVar];

                return [pick(options[target + 'Top'], tArray[0]),
                        pick(options[target + 'Right'], tArray[1]),
                        pick(options[target + 'Bottom'], tArray[2]),
                        pick(options[target + 'Left'], tArray[3])];
            }
        }; // end Chart

        var CenteredSeriesMixin = Highcharts.CenteredSeriesMixin = {
            /**
             * Get the center of the pie based on the size and center options relative to the  
             * plot area. Borrowed by the polar and gauge series types.
             */
            getCenter: function () {

                var options = this.options,
                    chart = this.chart,
                    slicingRoom = 2 * (options.slicedOffset || 0),
                    handleSlicingRoom,
                    plotWidth = chart.plotWidth - 2 * slicingRoom,
                    plotHeight = chart.plotHeight - 2 * slicingRoom,
                    centerOption = options.center,
                    positions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],
                    smallestSize = mathMin(plotWidth, plotHeight),
                    i,
                    value;

                for (i = 0; i < 4; ++i) {
                    value = positions[i];
                    handleSlicingRoom = i < 2 || (i === 2 && /%$/.test(value));

                    // i == 0: centerX, relative to width
                    // i == 1: centerY, relative to height
                    // i == 2: size, relative to smallestSize
                    // i == 3: innerSize, relative to size
                    positions[i] = relativeLength(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) +
                        (handleSlicingRoom ? slicingRoom : 0);

                }
                return positions;
            }
        };

        /**
         * The Point object and prototype. Inheritable and used as base for PiePoint
         */
        var Point = function () { };
        Point.prototype = {

            /**
             * Initialize the point
             * @param {Object} series The series object containing this point
             * @param {Object} options The data in either number, array or object format
             */
            init: function (series, options, x) {

                var point = this,
                    colors;
                point.series = series;
                point.color = series.color; // #3445
                point.applyOptions(options, x);
                point.pointAttr = {};

                if (series.options.colorByPoint) {
                    colors = series.options.colors || series.chart.options.colors;
                    point.color = point.color || colors[series.colorCounter++];
                    // loop back to zero
                    if (series.colorCounter === colors.length) {
                        series.colorCounter = 0;
                    }
                }

                series.chart.pointCount++;
                return point;
            },
            /**
             * Apply the options containing the x and y data and possible some extra properties.
             * This is called on point init or from point.update.
             *
             * @param {Object} options
             */
            applyOptions: function (options, x) {
                var point = this,
                    series = point.series,
                    pointValKey = series.options.pointValKey || series.pointValKey;

                options = Point.prototype.optionsToObject.call(this, options);

                // copy options directly to point
                extend(point, options);
                point.options = point.options ? extend(point.options, options) : options;

                // For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.
                if (pointValKey) {
                    point.y = point[pointValKey];
                }

                // If no x is set by now, get auto incremented value. All points must have an
                // x value, however the y value can be null to create a gap in the series
                if (point.x === UNDEFINED && series) {
                    point.x = x === UNDEFINED ? series.autoIncrement() : x;
                }

                return point;
            },

            /**
             * Transform number or array configs into objects
             */
            optionsToObject: function (options) {
                var ret = {},
                    series = this.series,
                    keys = series.options.keys,
                    pointArrayMap = keys || series.pointArrayMap || ['y'],
                    valueCount = pointArrayMap.length,
                    firstItemType,
                    i = 0,
                    j = 0;

                if (typeof options === 'number' || options === null) {
                    ret[pointArrayMap[0]] = options;

                } else if (isArray(options)) {
                    // with leading x value
                    if (!keys && options.length > valueCount) {
                        firstItemType = typeof options[0];
                        if (firstItemType === 'string') {
                            ret.name = options[0];
                        } else if (firstItemType === 'number') {
                            ret.x = options[0];
                        }
                        i++;
                    }
                    while (j < valueCount) {
                        ret[pointArrayMap[j++]] = options[i++];
                    }
                } else if (typeof options === 'object') {
                    ret = options;

                    // This is the fastest way to detect if there are individual point dataLabels that need
                    // to be considered in drawDataLabels. These can only occur in object configs.
                    if (options.dataLabels) {
                        series._hasPointLabels = true;
                    }

                    // Same approach as above for markers
                    if (options.marker) {
                        series._hasPointMarkers = true;
                    }
                }
                return ret;
            },

            /**
             * Destroy a point to clear memory. Its reference still stays in series.data.
             */
            destroy: function () {
                var point = this,
                    series = point.series,
                    chart = series.chart,
                    hoverPoints = chart.hoverPoints,
                    prop;

                chart.pointCount--;

                if (hoverPoints) {
                    point.setState();
                    erase(hoverPoints, point);
                    if (!hoverPoints.length) {
                        chart.hoverPoints = null;
                    }

                }
                if (point === chart.hoverPoint) {
                    point.onMouseOut();
                }

                // remove all events
                if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive
                    removeEvent(point);
                    point.destroyElements();
                }

                if (point.legendItem) { // pies have legend items
                    chart.legend.destroyItem(point);
                }

                for (prop in point) {
                    point[prop] = null;
                }


            },

            /**
             * Destroy SVG elements associated with the point
             */
            destroyElements: function () {
                var point = this,
                    props = ['graphic', 'dataLabel', 'dataLabelUpper', 'group', 'connector', 'shadowGroup'],
                    prop,
                    i = 6;
                while (i--) {
                    prop = props[i];
                    if (point[prop]) {
                        point[prop] = point[prop].destroy();
                    }
                }
            },

            /**
             * Return the configuration hash needed for the data label and tooltip formatters
             */
            getLabelConfig: function () {
                var point = this;
                return {
                    x: point.category,
                    y: point.y,
                    key: point.name || point.category,
                    series: point.series,
                    point: point,
                    percentage: point.percentage,
                    total: point.total || point.stackTotal
                };
            },

            /**
             * Extendable method for formatting each point's tooltip line
             *
             * @return {String} A string to be concatenated in to the common tooltip text
             */
            tooltipFormatter: function (pointFormat) {

                // Insert options for valueDecimals, valuePrefix, and valueSuffix
                var series = this.series,
                    seriesTooltipOptions = series.tooltipOptions,
                    valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),
                    valuePrefix = seriesTooltipOptions.valuePrefix || '',
                    valueSuffix = seriesTooltipOptions.valueSuffix || '';

                // Loop over the point array map and replace unformatted values with sprintf formatting markup
                each(series.pointArrayMap || ['y'], function (key) {
                    key = '{point.' + key; // without the closing bracket
                    if (valuePrefix || valueSuffix) {
                        pointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);
                    }
                    pointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');
                });

                return format(pointFormat, {
                    point: this,
                    series: this.series
                });
            },

            /**
             * Fire an event on the Point object. Must not be renamed to fireEvent, as this
             * causes a name clash in MooTools
             * @param {String} eventType
             * @param {Object} eventArgs Additional event arguments
             * @param {Function} defaultFunction Default event handler
             */
            firePointEvent: function (eventType, eventArgs, defaultFunction) {
                var point = this,
                    series = this.series,
                    seriesOptions = series.options;

                // load event handlers on demand to save time on mouseover/out
                if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {
                    this.importEvents();
                }

                // add default handler if in selection mode
                if (eventType === 'click' && seriesOptions.allowPointSelect) {
                    defaultFunction = function (event) {
                        // Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera
                        if (point.select) { // Could be destroyed by prior event handlers (#2911)
                            point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
                        }
                    };
                }

                fireEvent(this, eventType, eventArgs, defaultFunction);
            }
        };/**
 * @classDescription The base function which all other series types inherit from. The data in the series is stored
 * in various arrays.
 *
 * - First, series.options.data contains all the original config options for
 * each point whether added by options or methods like series.addPoint.
 * - Next, series.data contains those values converted to points, but in case the series data length
 * exceeds the cropThreshold, or if the data is grouped, series.data doesn't contain all the points. It
 * only contains the points that have been created on demand.
 * - Then there's series.points that contains all currently visible point objects. In case of cropping,
 * the cropped-away points are not part of this array. The series.points array starts at series.cropStart
 * compared to series.data and series.options.data. If however the series data is grouped, these can't
 * be correlated one to one.
 * - series.xData and series.processedXData contain clean x values, equivalent to series.data and series.points.
 * - series.yData and series.processedYData contain clean x values, equivalent to series.data and series.points.
 *
 * @param {Object} chart
 * @param {Object} options
 */
        var Series = Highcharts.Series = function () { };

        Series.prototype = {

            isCartesian: true,
            type: 'line',
            pointClass: Point,
            sorted: true, // requires the data to be sorted
            requireSorting: true,
            pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
                stroke: 'lineColor',
                'stroke-width': 'lineWidth',
                fill: 'fillColor',
                r: 'radius'
            },
            axisTypes: ['xAxis', 'yAxis'],
            colorCounter: 0,
            parallelArrays: ['x', 'y'], // each point's x and y values are stored in this.xData and this.yData
            init: function (chart, options) {
                var series = this,
                    eventType,
                    events,
                    chartSeries = chart.series,
                    sortByIndex = function (a, b) {
                        return pick(a.options.index, a._i) - pick(b.options.index, b._i);
                    };

                series.chart = chart;
                series.options = options = series.setOptions(options); // merge with plotOptions
                series.linkedSeries = [];

                // bind the axes
                series.bindAxes();

                // set some variables
                extend(series, {
                    name: options.name,
                    state: NORMAL_STATE,
                    pointAttr: {},
                    visible: options.visible !== false, // true by default
                    selected: options.selected === true // false by default
                });

                // special
                if (useCanVG) {
                    options.animation = false;
                }

                // register event listeners
                events = options.events;
                for (eventType in events) {
                    addEvent(series, eventType, events[eventType]);
                }
                if (
                    (events && events.click) ||
                    (options.point && options.point.events && options.point.events.click) ||
                    options.allowPointSelect
                ) {
                    chart.runTrackerClick = true;
                }

                series.getColor();
                series.getSymbol();

                // Set the data
                each(series.parallelArrays, function (key) {
                    series[key + 'Data'] = [];
                });
                series.setData(options.data, false);

                // Mark cartesian
                if (series.isCartesian) {
                    chart.hasCartesianSeries = true;
                }

                // Register it in the chart
                chartSeries.push(series);
                series._i = chartSeries.length - 1;

                // Sort series according to index option (#248, #1123, #2456)
                stableSort(chartSeries, sortByIndex);
                if (this.yAxis) {
                    stableSort(this.yAxis.series, sortByIndex);
                }

                each(chartSeries, function (series, i) {
                    series.index = i;
                    series.name = series.name || 'Series ' + (i + 1);
                });

            },

            /**
             * Set the xAxis and yAxis properties of cartesian series, and register the series
             * in the axis.series array
             */
            bindAxes: function () {
                var series = this,
                    seriesOptions = series.options,
                    chart = series.chart,
                    axisOptions;

                each(series.axisTypes || [], function (AXIS) { // repeat for xAxis and yAxis

                    each(chart[AXIS], function (axis) { // loop through the chart's axis objects
                        axisOptions = axis.options;

                        // apply if the series xAxis or yAxis option mathches the number of the
                        // axis, or if undefined, use the first axis
                        if ((seriesOptions[AXIS] === axisOptions.index) ||
                                (seriesOptions[AXIS] !== UNDEFINED && seriesOptions[AXIS] === axisOptions.id) ||
                                (seriesOptions[AXIS] === UNDEFINED && axisOptions.index === 0)) {

                            // register this series in the axis.series lookup
                            axis.series.push(series);

                            // set this series.xAxis or series.yAxis reference
                            series[AXIS] = axis;

                            // mark dirty for redraw
                            axis.isDirty = true;
                        }
                    });

                    // The series needs an X and an Y axis
                    if (!series[AXIS] && series.optionalAxis !== AXIS) {
                        error(18, true);
                    }

                });
            },

            /**
             * For simple series types like line and column, the data values are held in arrays like
             * xData and yData for quick lookup to find extremes and more. For multidimensional series
             * like bubble and map, this can be extended with arrays like zData and valueData by
             * adding to the series.parallelArrays array.
             */
            updateParallelArrays: function (point, i) {
                var series = point.series,
                    args = arguments,
                    fn = typeof i === 'number' ?
                         // Insert the value in the given position
                        function (key) {
                            var val = key === 'y' && series.toYData ? series.toYData(point) : point[key];
                            series[key + 'Data'][i] = val;
                        } :
                        // Apply the method specified in i with the following arguments as arguments
                        function (key) {
                            Array.prototype[i].apply(series[key + 'Data'], Array.prototype.slice.call(args, 2));
                        };

                each(series.parallelArrays, fn);
            },

            /**
             * Return an auto incremented x value based on the pointStart and pointInterval options.
             * This is only used if an x value is not given for the point that calls autoIncrement.
             */
            autoIncrement: function () {

                var options = this.options,
                    xIncrement = this.xIncrement,
                    date,
                    pointInterval,
                    pointIntervalUnit = options.pointIntervalUnit;

                xIncrement = pick(xIncrement, options.pointStart, 0);

                this.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1);

                // Added code for pointInterval strings
                if (pointIntervalUnit === 'month' || pointIntervalUnit === 'year') {
                    date = new Date(xIncrement);
                    date = (pointIntervalUnit === 'month') ?
                        +date[setMonth](date[getMonth]() + pointInterval) :
                        +date[setFullYear](date[getFullYear]() + pointInterval);
                    pointInterval = date - xIncrement;
                }

                this.xIncrement = xIncrement + pointInterval;
                return xIncrement;
            },

            /**
             * Divide the series data into segments divided by null values.
             */
            getSegments: function () {
                var series = this,
                    lastNull = -1,
                    segments = [],
                    i,
                    points = series.points,
                    pointsLength = points.length;

                if (pointsLength) { // no action required for []

                    // if connect nulls, just remove null points
                    if (series.options.connectNulls) {
                        i = pointsLength;
                        while (i--) {
                            if (points[i].y === null) {
                                points.splice(i, 1);
                            }
                        }
                        if (points.length) {
                            segments = [points];
                        }

                        // else, split on null points
                    } else {
                        each(points, function (point, i) {
                            if (point.y === null) {
                                if (i > lastNull + 1) {
                                    segments.push(points.slice(lastNull + 1, i));
                                }
                                lastNull = i;
                            } else if (i === pointsLength - 1) { // last value
                                segments.push(points.slice(lastNull + 1, i + 1));
                            }
                        });
                    }
                }

                // register it
                series.segments = segments;
            },

            /**
             * Set the series options by merging from the options tree
             * @param {Object} itemOptions
             */
            setOptions: function (itemOptions) {
                var chart = this.chart,
                    chartOptions = chart.options,
                    plotOptions = chartOptions.plotOptions,
                    userOptions = chart.userOptions || {},
                    userPlotOptions = userOptions.plotOptions || {},
                    typeOptions = plotOptions[this.type],
                    options,
                    zones;

                this.userOptions = itemOptions;

                // General series options take precedence over type options because otherwise, default
                // type options like column.animation would be overwritten by the general option.
                // But issues have been raised here (#3881), and the solution may be to distinguish 
                // between default option and userOptions like in the tooltip below.
                options = merge(
                    typeOptions,
                    plotOptions.series,
                    itemOptions
                );

                // The tooltip options are merged between global and series specific options
                this.tooltipOptions = merge(
                    defaultOptions.tooltip,
                    defaultOptions.plotOptions[this.type].tooltip,
                    userOptions.tooltip,
                    userPlotOptions.series && userPlotOptions.series.tooltip,
                    userPlotOptions[this.type] && userPlotOptions[this.type].tooltip,
                    itemOptions.tooltip
                );

                // Delete marker object if not allowed (#1125)
                if (typeOptions.marker === null) {
                    delete options.marker;
                }

                // Handle color zones
                this.zoneAxis = options.zoneAxis;
                zones = this.zones = (options.zones || []).slice();
                if ((options.negativeColor || options.negativeFillColor) && !options.zones) {
                    zones.push({
                        value: options[this.zoneAxis + 'Threshold'] || options.threshold || 0,
                        color: options.negativeColor,
                        fillColor: options.negativeFillColor
                    });
                }
                if (zones.length) { // Push one extra zone for the rest
                    if (defined(zones[zones.length - 1].value)) {
                        zones.push({
                            color: this.color,
                            fillColor: this.fillColor
                        });
                    }
                }
                return options;
            },

            getCyclic: function (prop, value, defaults) {
                var i,
                    userOptions = this.userOptions,
                    indexName = '_' + prop + 'Index',
                    counterName = prop + 'Counter';

                if (!value) {
                    if (defined(userOptions[indexName])) { // after Series.update()
                        i = userOptions[indexName];
                    } else {
                        userOptions[indexName] = i = this.chart[counterName] % defaults.length;
                        this.chart[counterName] += 1;
                    }
                    value = defaults[i];
                }
                this[prop] = value;
            },

            /**
             * Get the series' color
             */
            getColor: function () {
                if (!this.options.colorByPoint) {
                    this.getCyclic('color', this.options.color || defaultPlotOptions[this.type].color, this.chart.options.colors);
                }
            },
            /**
             * Get the series' symbol
             */
            getSymbol: function () {
                var seriesMarkerOption = this.options.marker;

                this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);

                // don't substract radius in image symbols (#604)
                if (/^url/.test(this.symbol)) {
                    seriesMarkerOption.radius = 0;
                }
            },

            drawLegendSymbol: LegendSymbolMixin.drawLineMarker,

            /**
             * Replace the series data with a new set of data
             * @param {Object} data
             * @param {Object} redraw
             */
            setData: function (data, redraw, animation, updatePoints) {
                var series = this,
                    oldData = series.points,
                    oldDataLength = (oldData && oldData.length) || 0,
                    dataLength,
                    options = series.options,
                    chart = series.chart,
                    firstPoint = null,
                    xAxis = series.xAxis,
                    hasCategories = xAxis && !!xAxis.categories,
                    i,
                    turboThreshold = options.turboThreshold,
                    pt,
                    xData = this.xData,
                    yData = this.yData,
                    pointArrayMap = series.pointArrayMap,
                    valueCount = pointArrayMap && pointArrayMap.length;

                data = data || [];
                dataLength = data.length;
                redraw = pick(redraw, true);

                // If the point count is the same as is was, just run Point.update which is
                // cheaper, allows animation, and keeps references to points.
                if (updatePoints !== false && dataLength && oldDataLength === dataLength && !series.cropped && !series.hasGroupedData && series.visible) {
                    each(data, function (point, i) {
                        if (oldData[i].update) { // Linked, previously hidden series (#3709)
                            oldData[i].update(point, false, null, false);
                        }
                    });

                } else {

                    // Reset properties
                    series.xIncrement = null;
                    series.pointRange = hasCategories ? 1 : options.pointRange;

                    series.colorCounter = 0; // for series with colorByPoint (#1547)

                    // Update parallel arrays
                    each(this.parallelArrays, function (key) {
                        series[key + 'Data'].length = 0;
                    });

                    // In turbo mode, only one- or twodimensional arrays of numbers are allowed. The
                    // first value is tested, and we assume that all the rest are defined the same
                    // way. Although the 'for' loops are similar, they are repeated inside each
                    // if-else conditional for max performance.
                    if (turboThreshold && dataLength > turboThreshold) {

                        // find the first non-null point
                        i = 0;
                        while (firstPoint === null && i < dataLength) {
                            firstPoint = data[i];
                            i++;
                        }


                        if (isNumber(firstPoint)) { // assume all points are numbers
                            var x = pick(options.pointStart, 0),
                                pointInterval = pick(options.pointInterval, 1);

                            for (i = 0; i < dataLength; i++) {
                                xData[i] = x;
                                yData[i] = data[i];
                                x += pointInterval;
                            }
                            series.xIncrement = x;
                        } else if (isArray(firstPoint)) { // assume all points are arrays
                            if (valueCount) { // [x, low, high] or [x, o, h, l, c]
                                for (i = 0; i < dataLength; i++) {
                                    pt = data[i];
                                    xData[i] = pt[0];
                                    yData[i] = pt.slice(1, valueCount + 1);
                                }
                            } else { // [x, y]
                                for (i = 0; i < dataLength; i++) {
                                    pt = data[i];
                                    xData[i] = pt[0];
                                    yData[i] = pt[1];
                                }
                            }
                        } else {
                            error(12); // Highcharts expects configs to be numbers or arrays in turbo mode
                        }
                    } else {
                        for (i = 0; i < dataLength; i++) {
                            if (data[i] !== UNDEFINED) { // stray commas in oldIE
                                pt = { series: series };
                                series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
                                series.updateParallelArrays(pt, i);
                                if (hasCategories && pt.name) {
                                    xAxis.names[pt.x] = pt.name; // #2046
                                }
                            }
                        }
                    }

                    // Forgetting to cast strings to numbers is a common caveat when handling CSV or JSON
                    if (isString(yData[0])) {
                        error(14, true);
                    }

                    series.data = [];
                    series.options.data = data;
                    //series.zData = zData;

                    // destroy old points
                    i = oldDataLength;
                    while (i--) {
                        if (oldData[i] && oldData[i].destroy) {
                            oldData[i].destroy();
                        }
                    }

                    // reset minRange (#878)
                    if (xAxis) {
                        xAxis.minRange = xAxis.userMinRange;
                    }

                    // redraw
                    series.isDirty = series.isDirtyData = chart.isDirtyBox = true;
                    animation = false;
                }

                if (redraw) {
                    chart.redraw(animation);
                }
            },

            /**
             * Process the data by cropping away unused data points if the series is longer
             * than the crop threshold. This saves computing time for lage series.
             */
            processData: function (force) {
                var series = this,
                    processedXData = series.xData, // copied during slice operation below
                    processedYData = series.yData,
                    dataLength = processedXData.length,
                    croppedData,
                    cropStart = 0,
                    cropped,
                    distance,
                    closestPointRange,
                    xAxis = series.xAxis,
                    i, // loop variable
                    options = series.options,
                    cropThreshold = options.cropThreshold,
                    isCartesian = series.isCartesian,
                    xExtremes,
                    min,
                    max;

                // If the series data or axes haven't changed, don't go through this. Return false to pass
                // the message on to override methods like in data grouping.
                if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {
                    return false;
                }

                if (xAxis) {
                    xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)
                    min = xExtremes.min;
                    max = xExtremes.max;
                }

                // optionally filter out points outside the plot area
                if (isCartesian && series.sorted && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {

                    // it's outside current extremes
                    if (processedXData[dataLength - 1] < min || processedXData[0] > max) {
                        processedXData = [];
                        processedYData = [];

                        // only crop if it's actually spilling out
                    } else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {
                        croppedData = this.cropData(series.xData, series.yData, min, max);
                        processedXData = croppedData.xData;
                        processedYData = croppedData.yData;
                        cropStart = croppedData.start;
                        cropped = true;
                    }
                }


                // Find the closest distance between processed points
                for (i = processedXData.length - 1; i >= 0; i--) {
                    distance = processedXData[i] - processedXData[i - 1];

                    if (distance > 0 && (closestPointRange === UNDEFINED || distance < closestPointRange)) {
                        closestPointRange = distance;

                        // Unsorted data is not supported by the line tooltip, as well as data grouping and
                        // navigation in Stock charts (#725) and width calculation of columns (#1900)
                    } else if (distance < 0 && series.requireSorting) {
                        error(15);
                    }
                }

                // Record the properties
                series.cropped = cropped; // undefined or true
                series.cropStart = cropStart;
                series.processedXData = processedXData;
                series.processedYData = processedYData;

                if (options.pointRange === null) { // null means auto, as for columns, candlesticks and OHLC
                    series.pointRange = closestPointRange || 1;
                }
                series.closestPointRange = closestPointRange;

            },

            /**
             * Iterate over xData and crop values between min and max. Returns object containing crop start/end
             * cropped xData with corresponding part of yData, dataMin and dataMax within the cropped range
             */
            cropData: function (xData, yData, min, max) {
                var dataLength = xData.length,
                    cropStart = 0,
                    cropEnd = dataLength,
                    cropShoulder = pick(this.cropShoulder, 1), // line-type series need one point outside
                    i;

                // iterate up to find slice start
                for (i = 0; i < dataLength; i++) {
                    if (xData[i] >= min) {
                        cropStart = mathMax(0, i - cropShoulder);
                        break;
                    }
                }

                // proceed to find slice end
                for (; i < dataLength; i++) {
                    if (xData[i] > max) {
                        cropEnd = i + cropShoulder;
                        break;
                    }
                }

                return {
                    xData: xData.slice(cropStart, cropEnd),
                    yData: yData.slice(cropStart, cropEnd),
                    start: cropStart,
                    end: cropEnd
                };
            },


            /**
             * Generate the data point after the data has been processed by cropping away
             * unused points and optionally grouped in Highcharts Stock.
             */
            generatePoints: function () {
                var series = this,
                    options = series.options,
                    dataOptions = options.data,
                    data = series.data,
                    dataLength,
                    processedXData = series.processedXData,
                    processedYData = series.processedYData,
                    pointClass = series.pointClass,
                    processedDataLength = processedXData.length,
                    cropStart = series.cropStart || 0,
                    cursor,
                    hasGroupedData = series.hasGroupedData,
                    point,
                    points = [],
                    i;

                if (!data && !hasGroupedData) {
                    var arr = [];
                    arr.length = dataOptions.length;
                    data = series.data = arr;
                }

                for (i = 0; i < processedDataLength; i++) {
                    cursor = cropStart + i;
                    if (!hasGroupedData) {
                        if (data[cursor]) {
                            point = data[cursor];
                        } else if (dataOptions[cursor] !== UNDEFINED) { // #970
                            data[cursor] = point = (new pointClass()).init(series, dataOptions[cursor], processedXData[i]);
                        }
                        points[i] = point;
                    } else {
                        // splat the y data in case of ohlc data array
                        points[i] = (new pointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));
                    }
                    points[i].index = cursor; // For faster access in Point.update
                }

                // Hide cropped-away points - this only runs when the number of points is above cropThreshold, or when
                // swithching view from non-grouped data to grouped data (#637)
                if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
                    for (i = 0; i < dataLength; i++) {
                        if (i === cropStart && !hasGroupedData) { // when has grouped data, clear all points
                            i += processedDataLength;
                        }
                        if (data[i]) {
                            data[i].destroyElements();
                            data[i].plotX = UNDEFINED; // #1003
                        }
                    }
                }

                series.data = data;
                series.points = points;
            },

            /**
             * Calculate Y extremes for visible data
             */
            getExtremes: function (yData) {
                var xAxis = this.xAxis,
                    yAxis = this.yAxis,
                    xData = this.processedXData,
                    yDataLength,
                    activeYData = [],
                    activeCounter = 0,
                    xExtremes = xAxis.getExtremes(), // #2117, need to compensate for log X axis
                    xMin = xExtremes.min,
                    xMax = xExtremes.max,
                    validValue,
                    withinRange,
                    x,
                    y,
                    i,
                    j;

                yData = yData || this.stackedYData || this.processedYData;
                yDataLength = yData.length;

                for (i = 0; i < yDataLength; i++) {

                    x = xData[i];
                    y = yData[i];

                    // For points within the visible range, including the first point outside the
                    // visible range, consider y extremes
                    validValue = y !== null && y !== UNDEFINED && (!yAxis.isLog || (y.length || y > 0));
                    withinRange = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped ||
                        ((xData[i + 1] || x) >= xMin && (xData[i - 1] || x) <= xMax);

                    if (validValue && withinRange) {

                        j = y.length;
                        if (j) { // array, like ohlc or range data
                            while (j--) {
                                if (y[j] !== null) {
                                    activeYData[activeCounter++] = y[j];
                                }
                            }
                        } else {
                            activeYData[activeCounter++] = y;
                        }
                    }
                }
                this.dataMin = arrayMin(activeYData);
                this.dataMax = arrayMax(activeYData);
            },

            /**
             * Translate data points from raw data values to chart specific positioning data
             * needed later in drawPoints, drawGraph and drawTracker.
             */
            translate: function () {
                if (!this.processedXData) { // hidden series
                    this.processData();
                }
                this.generatePoints();
                var series = this,
                    options = series.options,
                    stacking = options.stacking,
                    xAxis = series.xAxis,
                    categories = xAxis.categories,
                    yAxis = series.yAxis,
                    points = series.points,
                    dataLength = points.length,
                    hasModifyValue = !!series.modifyValue,
                    i,
                    pointPlacement = options.pointPlacement,
                    dynamicallyPlaced = pointPlacement === 'between' || isNumber(pointPlacement),
                    threshold = options.threshold,
                    stackThreshold = options.startFromThreshold ? threshold : 0,
                    plotX,
                    plotY,
                    lastPlotX,
                    closestPointRangePx = Number.MAX_VALUE;

                // Translate each point
                for (i = 0; i < dataLength; i++) {
                    var point = points[i],
                        xValue = point.x,
                        yValue = point.y,
                        yBottom = point.low,
                        stack = stacking && yAxis.stacks[(series.negStacks && yValue < (stackThreshold ? 0 : threshold) ? '-' : '') + series.stackKey],
                        pointStack,
                        stackValues;

                    // Discard disallowed y values for log axes (#3434)
                    if (yAxis.isLog && yValue !== null && yValue <= 0) {
                        point.y = yValue = null;
                        error(10);
                    }

                    // Get the plotX translation
                    point.plotX = plotX = mathMin(mathMax(-1e5, xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement, this.type === 'flags')), 1e5); // #3923


                    // Calculate the bottom y value for stacked series
                    if (stacking && series.visible && stack && stack[xValue]) {

                        pointStack = stack[xValue];
                        stackValues = pointStack.points[series.index + ',' + i];
                        yBottom = stackValues[0];
                        yValue = stackValues[1];

                        if (yBottom === stackThreshold) {
                            yBottom = pick(threshold, yAxis.min);
                        }
                        if (yAxis.isLog && yBottom <= 0) { // #1200, #1232
                            yBottom = null;
                        }

                        point.total = point.stackTotal = pointStack.total;
                        point.percentage = pointStack.total && (point.y / pointStack.total * 100);
                        point.stackY = yValue;

                        // Place the stack label
                        pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);

                    }

                    // Set translated yBottom or remove it
                    point.yBottom = defined(yBottom) ?
                        yAxis.translate(yBottom, 0, 1, 0, 1) :
                        null;

                    // general hook, used for Highstock compare mode
                    if (hasModifyValue) {
                        yValue = series.modifyValue(yValue, point);
                    }

                    // Set the the plotY value, reset it for redraws
                    point.plotY = plotY = (typeof yValue === 'number' && yValue !== Infinity) ?
                        mathMin(mathMax(-1e5, yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) : // #3201
                        UNDEFINED;
                    point.isInside = plotY !== UNDEFINED && plotY >= 0 && plotY <= yAxis.len && // #3519
                        plotX >= 0 && plotX <= xAxis.len;


                    // Set client related positions for mouse tracking
                    point.clientX = dynamicallyPlaced ? xAxis.translate(xValue, 0, 0, 0, 1) : plotX; // #1514

                    point.negative = point.y < (threshold || 0);

                    // some API data
                    point.category = categories && categories[point.x] !== UNDEFINED ?
                        categories[point.x] : point.x;

                    // Determine auto enabling of markers (#3635)
                    if (i) {
                        closestPointRangePx = mathMin(closestPointRangePx, mathAbs(plotX - lastPlotX));
                    }
                    lastPlotX = plotX;

                }

                series.closestPointRangePx = closestPointRangePx;

                // now that we have the cropped data, build the segments
                series.getSegments();
            },

            /**
             * Set the clipping for the series. For animated series it is called twice, first to initiate
             * animating the clip then the second time without the animation to set the final clip.
             */
            setClip: function (animation) {
                var chart = this.chart,
                    renderer = chart.renderer,
                    inverted = chart.inverted,
                    seriesClipBox = this.clipBox,
                    clipBox = seriesClipBox || chart.clipBox,
                    sharedClipKey = this.sharedClipKey || ['_sharedClip', animation && animation.duration, animation && animation.easing, clipBox.height].join(','),
                    clipRect = chart[sharedClipKey],
                    markerClipRect = chart[sharedClipKey + 'm'];

                // If a clipping rectangle with the same properties is currently present in the chart, use that.
                if (!clipRect) {

                    // When animation is set, prepare the initial positions
                    if (animation) {
                        clipBox.width = 0;

                        chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(
                            -99, // include the width of the first marker
                            inverted ? -chart.plotLeft : -chart.plotTop,
                            99,
                            inverted ? chart.chartWidth : chart.chartHeight
                        );
                    }
                    chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);

                }
                if (animation) {
                    clipRect.count += 1;
                }

                if (this.options.clip !== false) {
                    this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);
                    this.markerGroup.clip(markerClipRect);
                    this.sharedClipKey = sharedClipKey;
                }

                // Remove the shared clipping rectangle when all series are shown
                if (!animation) {
                    clipRect.count -= 1;
                    if (clipRect.count <= 0 && sharedClipKey && chart[sharedClipKey]) {
                        if (!seriesClipBox) {
                            chart[sharedClipKey] = chart[sharedClipKey].destroy();
                        }
                        if (chart[sharedClipKey + 'm']) {
                            chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();
                        }
                    }
                }
            },

            /**
             * Animate in the series
             */
            animate: function (init) {
                var series = this,
                    chart = series.chart,
                    clipRect,
                    animation = series.options.animation,
                    sharedClipKey;

                // Animation option is set to true
                if (animation && !isObject(animation)) {
                    animation = defaultPlotOptions[series.type].animation;
                }

                // Initialize the animation. Set up the clipping rectangle.
                if (init) {

                    series.setClip(animation);

                    // Run the animation
                } else {
                    sharedClipKey = this.sharedClipKey;
                    clipRect = chart[sharedClipKey];
                    if (clipRect) {
                        clipRect.animate({
                            width: chart.plotSizeX
                        }, animation);
                    }
                    if (chart[sharedClipKey + 'm']) {
                        chart[sharedClipKey + 'm'].animate({
                            width: chart.plotSizeX + 99
                        }, animation);
                    }

                    // Delete this function to allow it only once
                    series.animate = null;

                }
            },

            /**
             * This runs after animation to land on the final plot clipping
             */
            afterAnimate: function () {
                this.setClip();
                fireEvent(this, 'afterAnimate');
            },

            /**
             * Draw the markers
             */
            drawPoints: function () {
                var series = this,
                    pointAttr,
                    points = series.points,
                    chart = series.chart,
                    plotX,
                    plotY,
                    i,
                    point,
                    radius,
                    symbol,
                    isImage,
                    graphic,
                    options = series.options,
                    seriesMarkerOptions = options.marker,
                    seriesPointAttr = series.pointAttr[''],
                    pointMarkerOptions,
                    hasPointMarker,
                    enabled,
                    isInside,
                    markerGroup = series.markerGroup,
                    xAxis = series.xAxis,
                    globallyEnabled = pick(
                        seriesMarkerOptions.enabled,
                        xAxis.isRadial,
                        series.closestPointRangePx > 2 * seriesMarkerOptions.radius
                    );

                if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {

                    i = points.length;
                    while (i--) {
                        point = points[i];
                        plotX = mathFloor(point.plotX); // #1843
                        plotY = point.plotY;
                        graphic = point.graphic;
                        pointMarkerOptions = point.marker || {};
                        hasPointMarker = !!point.marker;
                        enabled = (globallyEnabled && pointMarkerOptions.enabled === UNDEFINED) || pointMarkerOptions.enabled;
                        isInside = point.isInside;

                        // only draw the point if y is defined
                        if (enabled && plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {

                            // shortcuts
                            pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || seriesPointAttr;
                            radius = pointAttr.r;
                            symbol = pick(pointMarkerOptions.symbol, series.symbol);
                            isImage = symbol.indexOf('url') === 0;

                            if (graphic) { // update
                                graphic[isInside ? 'show' : 'hide'](true) // Since the marker group isn't clipped, each individual marker must be toggled
                                    .animate(extend({
                                        x: plotX - radius,
                                        y: plotY - radius
                                    }, graphic.symbolName ? { // don't apply to image symbols #507
                                        width: 2 * radius,
                                        height: 2 * radius
                                    } : {}));
                            } else if (isInside && (radius > 0 || isImage)) {
                                point.graphic = graphic = chart.renderer.symbol(
                                    symbol,
                                    plotX - radius,
                                    plotY - radius,
                                    2 * radius,
                                    2 * radius,
                                    hasPointMarker ? pointMarkerOptions : seriesMarkerOptions
                                )
                                .attr(pointAttr)
                                .add(markerGroup);
                            }

                        } else if (graphic) {
                            point.graphic = graphic.destroy(); // #1269
                        }
                    }
                }

            },

            /**
             * Convert state properties from API naming conventions to SVG attributes
             *
             * @param {Object} options API options object
             * @param {Object} base1 SVG attribute object to inherit from
             * @param {Object} base2 Second level SVG attribute object to inherit from
             */
            convertAttribs: function (options, base1, base2, base3) {
                var conversion = this.pointAttrToOptions,
                    attr,
                    option,
                    obj = {};

                options = options || {};
                base1 = base1 || {};
                base2 = base2 || {};
                base3 = base3 || {};

                for (attr in conversion) {
                    option = conversion[attr];
                    obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);
                }
                return obj;
            },

            /**
             * Get the state attributes. Each series type has its own set of attributes
             * that are allowed to change on a point's state change. Series wide attributes are stored for
             * all series, and additionally point specific attributes are stored for all
             * points with individual marker options. If such options are not defined for the point,
             * a reference to the series wide attributes is stored in point.pointAttr.
             */
            getAttribs: function () {
                var series = this,
                    seriesOptions = series.options,
                    normalOptions = defaultPlotOptions[series.type].marker ? seriesOptions.marker : seriesOptions,
                    stateOptions = normalOptions.states,
                    stateOptionsHover = stateOptions[HOVER_STATE],
                    pointStateOptionsHover,
                    seriesColor = series.color,
                    seriesNegativeColor = series.options.negativeColor,
                    normalDefaults = {
                        stroke: seriesColor,
                        fill: seriesColor
                    },
                    points = series.points || [], // #927
                    i,
                    point,
                    seriesPointAttr = [],
                    pointAttr,
                    pointAttrToOptions = series.pointAttrToOptions,
                    hasPointSpecificOptions = series.hasPointSpecificOptions,
                    defaultLineColor = normalOptions.lineColor,
                    defaultFillColor = normalOptions.fillColor,
                    turboThreshold = seriesOptions.turboThreshold,
                    zones = series.zones,
                    zoneAxis = series.zoneAxis || 'y',
                    attr,
                    key;

                // series type specific modifications
                if (seriesOptions.marker) { // line, spline, area, areaspline, scatter

                    // if no hover radius is given, default to normal radius + 2
                    stateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + stateOptionsHover.radiusPlus;
                    stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + stateOptionsHover.lineWidthPlus;

                } else { // column, bar, pie

                    // if no hover color is given, brighten the normal color
                    stateOptionsHover.color = stateOptionsHover.color ||
                        Color(stateOptionsHover.color || seriesColor)
                            .brighten(stateOptionsHover.brightness).get();

                    // if no hover negativeColor is given, brighten the normal negativeColor
                    stateOptionsHover.negativeColor = stateOptionsHover.negativeColor ||
                        Color(stateOptionsHover.negativeColor || seriesNegativeColor)
                            .brighten(stateOptionsHover.brightness).get();
                }

                // general point attributes for the series normal state
                seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);

                // HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius
                each([HOVER_STATE, SELECT_STATE], function (state) {
                    seriesPointAttr[state] =
                            series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);
                });

                // set it
                series.pointAttr = seriesPointAttr;


                // Generate the point-specific attribute collections if specific point
                // options are given. If not, create a referance to the series wide point
                // attributes
                i = points.length;
                if (!turboThreshold || i < turboThreshold || hasPointSpecificOptions) {
                    while (i--) {
                        point = points[i];
                        normalOptions = (point.options && point.options.marker) || point.options;
                        if (normalOptions && normalOptions.enabled === false) {
                            normalOptions.radius = 0;
                        }

                        if (zones.length) {
                            var j = 0,
                                threshold = zones[j];
                            while (point[zoneAxis] >= threshold.value) {
                                threshold = zones[++j];
                            }

                            point.color = point.fillColor = threshold.color;
                        }

                        hasPointSpecificOptions = seriesOptions.colorByPoint || point.color; // #868

                        // check if the point has specific visual options
                        if (point.options) {
                            for (key in pointAttrToOptions) {
                                if (defined(normalOptions[pointAttrToOptions[key]])) {
                                    hasPointSpecificOptions = true;
                                }
                            }
                        }

                        // a specific marker config object is defined for the individual point:
                        // create it's own attribute collection
                        if (hasPointSpecificOptions) {
                            normalOptions = normalOptions || {};
                            pointAttr = [];
                            stateOptions = normalOptions.states || {}; // reassign for individual point
                            pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};

                            // Handle colors for column and pies
                            if (!seriesOptions.marker) { // column, bar, point
                                // If no hover color is given, brighten the normal color. #1619, #2579
                                pointStateOptionsHover.color = pointStateOptionsHover.color || (!point.options.color && stateOptionsHover[(point.negative && seriesNegativeColor ? 'negativeColor' : 'color')]) ||
                                    Color(point.color)
                                        .brighten(pointStateOptionsHover.brightness || stateOptionsHover.brightness)
                                        .get();
                            }

                            // normal point state inherits series wide normal state
                            attr = { color: point.color }; // #868
                            if (!defaultFillColor) { // Individual point color or negative color markers (#2219)
                                attr.fillColor = point.color;
                            }
                            if (!defaultLineColor) {
                                attr.lineColor = point.color; // Bubbles take point color, line markers use white
                            }
                            // Color is explicitly set to null or undefined (#1288, #4068)
                            if (normalOptions.hasOwnProperty('color') && !normalOptions.color) {
                                delete normalOptions.color;
                            }
                            pointAttr[NORMAL_STATE] = series.convertAttribs(extend(attr, normalOptions), seriesPointAttr[NORMAL_STATE]);

                            // inherit from point normal and series hover
                            pointAttr[HOVER_STATE] = series.convertAttribs(
                                stateOptions[HOVER_STATE],
                                seriesPointAttr[HOVER_STATE],
                                pointAttr[NORMAL_STATE]
                            );

                            // inherit from point normal and series hover
                            pointAttr[SELECT_STATE] = series.convertAttribs(
                                stateOptions[SELECT_STATE],
                                seriesPointAttr[SELECT_STATE],
                                pointAttr[NORMAL_STATE]
                            );


                            // no marker config object is created: copy a reference to the series-wide
                            // attribute collection
                        } else {
                            pointAttr = seriesPointAttr;
                        }

                        point.pointAttr = pointAttr;
                    }
                }
            },

            /**
             * Clear DOM objects and free up memory
             */
            destroy: function () {
                var series = this,
                    chart = series.chart,
                    issue134 = /AppleWebKit\/533/.test(userAgent),
                    destroy,
                    i,
                    data = series.data || [],
                    point,
                    prop,
                    axis;

                // add event hook
                fireEvent(series, 'destroy');

                // remove all events
                removeEvent(series);

                // erase from axes
                each(series.axisTypes || [], function (AXIS) {
                    axis = series[AXIS];
                    if (axis) {
                        erase(axis.series, series);
                        axis.isDirty = axis.forceRedraw = true;
                    }
                });

                // remove legend items
                if (series.legendItem) {
                    series.chart.legend.destroyItem(series);
                }

                // destroy all points with their elements
                i = data.length;
                while (i--) {
                    point = data[i];
                    if (point && point.destroy) {
                        point.destroy();
                    }
                }
                series.points = null;

                // Clear the animation timeout if we are destroying the series during initial animation
                clearTimeout(series.animationTimeout);

                // Destroy all SVGElements associated to the series
                for (prop in series) {
                    if (series[prop] instanceof SVGElement && !series[prop].survive) { // Survive provides a hook for not destroying

                        // issue 134 workaround
                        destroy = issue134 && prop === 'group' ?
                            'hide' :
                            'destroy';

                        series[prop][destroy]();
                    }
                }

                // remove from hoverSeries
                if (chart.hoverSeries === series) {
                    chart.hoverSeries = null;
                }
                erase(chart.series, series);

                // clear all members
                for (prop in series) {
                    delete series[prop];
                }
            },

            /**
             * Return the graph path of a segment
             */
            getSegmentPath: function (segment) {
                var series = this,
                    segmentPath = [],
                    step = series.options.step;

                // build the segment line
                each(segment, function (point, i) {

                    var plotX = point.plotX,
                        plotY = point.plotY,
                        lastPoint;

                    if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object
                        segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));

                    } else {

                        // moveTo or lineTo
                        segmentPath.push(i ? L : M);

                        // step line?
                        if (step && i) {
                            lastPoint = segment[i - 1];
                            if (step === 'right') {
                                segmentPath.push(
                                    lastPoint.plotX,
                                    plotY
                                );

                            } else if (step === 'center') {
                                segmentPath.push(
                                    (lastPoint.plotX + plotX) / 2,
                                    lastPoint.plotY,
                                    (lastPoint.plotX + plotX) / 2,
                                    plotY
                                );

                            } else {
                                segmentPath.push(
                                    plotX,
                                    lastPoint.plotY
                                );
                            }
                        }

                        // normal line to next point
                        segmentPath.push(
                            point.plotX,
                            point.plotY
                        );
                    }
                });

                return segmentPath;
            },

            /**
             * Get the graph path
             */
            getGraphPath: function () {
                var series = this,
                    graphPath = [],
                    segmentPath,
                    singlePoints = []; // used in drawTracker

                // Divide into segments and build graph and area paths
                each(series.segments, function (segment) {

                    segmentPath = series.getSegmentPath(segment);

                    // add the segment to the graph, or a single point for tracking
                    if (segment.length > 1) {
                        graphPath = graphPath.concat(segmentPath);
                    } else {
                        singlePoints.push(segment[0]);
                    }
                });

                // Record it for use in drawGraph and drawTracker, and return graphPath
                series.singlePoints = singlePoints;
                series.graphPath = graphPath;

                return graphPath;

            },

            /**
             * Draw the actual graph
             */
            drawGraph: function () {
                var series = this,
                    options = this.options,
                    props = [['graph', options.lineColor || this.color, options.dashStyle]],
                    lineWidth = options.lineWidth,
                    roundCap = options.linecap !== 'square',
                    graphPath = this.getGraphPath(),
                    fillColor = (this.fillGraph && this.color) || NONE, // polygon series use filled graph
                    zones = this.zones;

                each(zones, function (threshold, i) {
                    props.push(['zoneGraph' + i, threshold.color || series.color, threshold.dashStyle || options.dashStyle]);
                });

                // Draw the graph
                each(props, function (prop, i) {
                    var graphKey = prop[0],
                        graph = series[graphKey],
                        attribs;

                    if (graph) {
                        stop(graph); // cancel running animations, #459
                        graph.animate({ d: graphPath });

                    } else if ((lineWidth || fillColor) && graphPath.length) { // #1487
                        attribs = {
                            stroke: prop[1],
                            'stroke-width': lineWidth,
                            fill: fillColor,
                            zIndex: 1 // #1069
                        };
                        if (prop[2]) {
                            attribs.dashstyle = prop[2];
                        } else if (roundCap) {
                            attribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';
                        }

                        series[graphKey] = series.chart.renderer.path(graphPath)
                            .attr(attribs)
                            .add(series.group)
                            .shadow((i < 2) && options.shadow); // add shadow to normal series (0) or to first zone (1) #3932
                    }
                });
            },

            /**
             * Clip the graphs into the positive and negative coloured graphs
             */
            applyZones: function () {
                var series = this,
                    chart = this.chart,
                    renderer = chart.renderer,
                    zones = this.zones,
                    translatedFrom,
                    translatedTo,
                    clips = this.clips || [],
                    clipAttr,
                    graph = this.graph,
                    area = this.area,
                    chartSizeMax = mathMax(chart.chartWidth, chart.chartHeight),
                    zoneAxis = this.zoneAxis || 'y',
                    axis = this[zoneAxis + 'Axis'],
                    extremes,
                    reversed = axis.reversed,
                    inverted = chart.inverted,
                    horiz = axis.horiz,
                    pxRange,
                    pxPosMin,
                    pxPosMax,
                    ignoreZones = false;

                if (zones.length && (graph || area)) {
                    // The use of the Color Threshold assumes there are no gaps
                    // so it is safe to hide the original graph and area
                    if (graph) {
                        graph.hide();
                    }
                    if (area) {
                        area.hide();
                    }

                    // Create the clips
                    extremes = axis.getExtremes();
                    each(zones, function (threshold, i) {

                        translatedFrom = reversed ?
                            (horiz ? chart.plotWidth : 0) :
                            (horiz ? 0 : axis.toPixels(extremes.min));
                        translatedFrom = mathMin(mathMax(pick(translatedTo, translatedFrom), 0), chartSizeMax);
                        translatedTo = mathMin(mathMax(mathRound(axis.toPixels(pick(threshold.value, extremes.max), true)), 0), chartSizeMax);

                        if (ignoreZones) {
                            translatedFrom = translatedTo = axis.toPixels(extremes.max);
                        }

                        pxRange = Math.abs(translatedFrom - translatedTo);
                        pxPosMin = mathMin(translatedFrom, translatedTo);
                        pxPosMax = mathMax(translatedFrom, translatedTo);
                        if (axis.isXAxis) {
                            clipAttr = {
                                x: inverted ? pxPosMax : pxPosMin,
                                y: 0,
                                width: pxRange,
                                height: chartSizeMax
                            };
                            if (!horiz) {
                                clipAttr.x = chart.plotHeight - clipAttr.x;
                            }
                        } else {
                            clipAttr = {
                                x: 0,
                                y: inverted ? pxPosMax : pxPosMin,
                                width: chartSizeMax,
                                height: pxRange
                            };
                            if (horiz) {
                                clipAttr.y = chart.plotWidth - clipAttr.y;
                            }
                        }

                        /// VML SUPPPORT
                        if (chart.inverted && renderer.isVML) {
                            if (axis.isXAxis) {
                                clipAttr = {
                                    x: 0,
                                    y: reversed ? pxPosMin : pxPosMax,
                                    height: clipAttr.width,
                                    width: chart.chartWidth
                                };
                            } else {
                                clipAttr = {
                                    x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,
                                    y: 0,
                                    width: clipAttr.height,
                                    height: chart.chartHeight
                                };
                            }
                        }
                        /// END OF VML SUPPORT

                        if (clips[i]) {
                            clips[i].animate(clipAttr);
                        } else {
                            clips[i] = renderer.clipRect(clipAttr);

                            if (graph) {
                                series['zoneGraph' + i].clip(clips[i]);
                            }

                            if (area) {
                                series['zoneArea' + i].clip(clips[i]);
                            }
                        }
                        // if this zone extends out of the axis, ignore the others
                        ignoreZones = threshold.value > extremes.max;
                    });
                    this.clips = clips;
                }
            },

            /**
             * Initialize and perform group inversion on series.group and series.markerGroup
             */
            invertGroups: function () {
                var series = this,
                    chart = series.chart;

                // Pie, go away (#1736)
                if (!series.xAxis) {
                    return;
                }

                // A fixed size is needed for inversion to work
                function setInvert() {
                    var size = {
                        width: series.yAxis.len,
                        height: series.xAxis.len
                    };

                    each(['group', 'markerGroup'], function (groupName) {
                        if (series[groupName]) {
                            series[groupName].attr(size).invert();
                        }
                    });
                }

                addEvent(chart, 'resize', setInvert); // do it on resize
                addEvent(series, 'destroy', function () {
                    removeEvent(chart, 'resize', setInvert);
                });

                // Do it now
                setInvert(); // do it now

                // On subsequent render and redraw, just do setInvert without setting up events again
                series.invertGroups = setInvert;
            },

            /**
             * General abstraction for creating plot groups like series.group, series.dataLabelsGroup and
             * series.markerGroup. On subsequent calls, the group will only be adjusted to the updated plot size.
             */
            plotGroup: function (prop, name, visibility, zIndex, parent) {
                var group = this[prop],
                    isNew = !group;

                // Generate it on first call
                if (isNew) {
                    this[prop] = group = this.chart.renderer.g(name)
                        .attr({
                            visibility: visibility,
                            zIndex: zIndex || 0.1 // IE8 needs this
                        })
                        .add(parent);
                }
                // Place it on first and subsequent (redraw) calls
                group[isNew ? 'attr' : 'animate'](this.getPlotBox());
                return group;
            },

            /**
             * Get the translation and scale for the plot area of this series
             */
            getPlotBox: function () {
                var chart = this.chart,
                    xAxis = this.xAxis,
                    yAxis = this.yAxis;

                // Swap axes for inverted (#2339)
                if (chart.inverted) {
                    xAxis = yAxis;
                    yAxis = this.xAxis;
                }
                return {
                    translateX: xAxis ? xAxis.left : chart.plotLeft,
                    translateY: yAxis ? yAxis.top : chart.plotTop,
                    scaleX: 1, // #1623
                    scaleY: 1
                };
            },

            /**
             * Render the graph and markers
             */
            render: function () {
                var series = this,
                    chart = series.chart,
                    group,
                    options = series.options,
                    animation = options.animation,
                    // Animation doesn't work in IE8 quirks when the group div is hidden,
                    // and looks bad in other oldIE
                    animDuration = (animation && !!series.animate && chart.renderer.isSVG && pick(animation.duration, 500)) || 0,
                    visibility = series.visible ? VISIBLE : HIDDEN,
                    zIndex = options.zIndex,
                    hasRendered = series.hasRendered,
                    chartSeriesGroup = chart.seriesGroup;

                // the group
                group = series.plotGroup(
                    'group',
                    'series',
                    visibility,
                    zIndex,
                    chartSeriesGroup
                );

                series.markerGroup = series.plotGroup(
                    'markerGroup',
                    'markers',
                    visibility,
                    zIndex,
                    chartSeriesGroup
                );

                // initiate the animation
                if (animDuration) {
                    series.animate(true);
                }

                // cache attributes for shapes
                series.getAttribs();

                // SVGRenderer needs to know this before drawing elements (#1089, #1795)
                group.inverted = series.isCartesian ? chart.inverted : false;

                // draw the graph if any
                if (series.drawGraph) {
                    series.drawGraph();
                    series.applyZones();
                }

                each(series.points, function (point) {
                    if (point.redraw) {
                        point.redraw();
                    }
                });

                // draw the data labels (inn pies they go before the points)
                if (series.drawDataLabels) {
                    series.drawDataLabels();
                }

                // draw the points
                if (series.visible) {
                    series.drawPoints();
                }


                // draw the mouse tracking area
                if (series.drawTracker && series.options.enableMouseTracking !== false) {
                    series.drawTracker();
                }

                // Handle inverted series and tracker groups
                if (chart.inverted) {
                    series.invertGroups();
                }

                // Initial clipping, must be defined after inverting groups for VML. Applies to columns etc. (#3839).
                if (options.clip !== false && !series.sharedClipKey && !hasRendered) {
                    group.clip(chart.clipRect);
                }

                // Run the animation
                if (animDuration) {
                    series.animate();
                }

                // Call the afterAnimate function on animation complete (but don't overwrite the animation.complete option
                // which should be available to the user).
                if (!hasRendered) {
                    if (animDuration) {
                        series.animationTimeout = setTimeout(function () {
                            series.afterAnimate();
                        }, animDuration);
                    } else {
                        series.afterAnimate();
                    }
                }

                series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
                // (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
                series.hasRendered = true;
            },

            /**
             * Redraw the series after an update in the axes.
             */
            redraw: function () {
                var series = this,
                    chart = series.chart,
                    wasDirtyData = series.isDirtyData, // cache it here as it is set to false in render, but used after
                    wasDirty = series.isDirty,
                    group = series.group,
                    xAxis = series.xAxis,
                    yAxis = series.yAxis;

                // reposition on resize
                if (group) {
                    if (chart.inverted) {
                        group.attr({
                            width: chart.plotWidth,
                            height: chart.plotHeight
                        });
                    }

                    group.animate({
                        translateX: pick(xAxis && xAxis.left, chart.plotLeft),
                        translateY: pick(yAxis && yAxis.top, chart.plotTop)
                    });
                }

                series.translate();
                series.render();
                if (wasDirtyData) {
                    fireEvent(series, 'updatedData');
                }
                if (wasDirty || wasDirtyData) {			// #3945 recalculate the kdtree when dirty
                    delete this.kdTree; // #3868 recalculate the kdtree with dirty data
                }
            },

            /**
             * KD Tree && PointSearching Implementation
             */

            kdDimensions: 1,
            kdAxisArray: ['clientX', 'plotY'],

            searchPoint: function (e, compareX) {
                var series = this,
                    xAxis = series.xAxis,
                    yAxis = series.yAxis,
                    inverted = series.chart.inverted;

                return this.searchKDTree({
                    clientX: inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,
                    plotY: inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos
                }, compareX);
            },

            buildKDTree: function () {
                var series = this,
                    dimensions = series.kdDimensions;

                // Internal function
                function _kdtree(points, depth, dimensions) {
                    var axis, median, length = points && points.length;

                    if (length) {

                        // alternate between the axis
                        axis = series.kdAxisArray[depth % dimensions];

                        // sort point array
                        points.sort(function (a, b) {
                            return a[axis] - b[axis];
                        });

                        median = Math.floor(length / 2);

                        // build and return nod
                        return {
                            point: points[median],
                            left: _kdtree(points.slice(0, median), depth + 1, dimensions),
                            right: _kdtree(points.slice(median + 1), depth + 1, dimensions)
                        };

                    }
                }

                // Start the recursive build process with a clone of the points array and null points filtered out (#3873)
                function startRecursive() {
                    var points = grep(series.points, function (point) {
                        return point.y !== null;
                    });

                    series.kdTree = _kdtree(points, dimensions, dimensions);
                }
                delete series.kdTree;

                if (series.options.kdSync) {  // For testing tooltips, don't build async
                    startRecursive();
                } else {
                    setTimeout(startRecursive);
                }
            },

            searchKDTree: function (point, compareX) {
                var series = this,
                    kdX = this.kdAxisArray[0],
                    kdY = this.kdAxisArray[1],
                    kdComparer = compareX ? 'distX' : 'dist';

                // Set the one and two dimensional distance on the point object
                function setDistance(p1, p2) {
                    var x = (defined(p1[kdX]) && defined(p2[kdX])) ? Math.pow(p1[kdX] - p2[kdX], 2) : null,
                        y = (defined(p1[kdY]) && defined(p2[kdY])) ? Math.pow(p1[kdY] - p2[kdY], 2) : null,
                        r = (x || 0) + (y || 0);

                    p2.dist = defined(r) ? Math.sqrt(r) : Number.MAX_VALUE;
                    p2.distX = defined(x) ? Math.sqrt(x) : Number.MAX_VALUE;
                }
                function _search(search, tree, depth, dimensions) {
                    var point = tree.point,
                        axis = series.kdAxisArray[depth % dimensions],
                        tdist,
                        sideA,
                        sideB,
                        ret = point,
                        nPoint1,
                        nPoint2;

                    setDistance(search, point);

                    // Pick side based on distance to splitting point
                    tdist = search[axis] - point[axis];
                    sideA = tdist < 0 ? 'left' : 'right';
                    sideB = tdist < 0 ? 'right' : 'left';

                    // End of tree
                    if (tree[sideA]) {
                        nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);

                        ret = (nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point);
                    }
                    if (tree[sideB]) {
                        // compare distance to current best to splitting point to decide wether to check side B or not
                        if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {
                            nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);
                            ret = (nPoint2[kdComparer] < ret[kdComparer] ? nPoint2 : ret);
                        }
                    }

                    return ret;
                }

                if (!this.kdTree) {
                    this.buildKDTree();
                }

                if (this.kdTree) {
                    return _search(point,
                        this.kdTree, this.kdDimensions, this.kdDimensions);
                }
            }

        }; // end Series prototype

        /**
         * The class for stack items
         */
        function StackItem(axis, options, isNegative, x, stackOption) {

            var inverted = axis.chart.inverted;

            this.axis = axis;

            // Tells if the stack is negative
            this.isNegative = isNegative;

            // Save the options to be able to style the label
            this.options = options;

            // Save the x value to be able to position the label later
            this.x = x;

            // Initialize total value
            this.total = null;

            // This will keep each points' extremes stored by series.index and point index
            this.points = {};

            // Save the stack option on the series configuration object, and whether to treat it as percent
            this.stack = stackOption;

            // The align options and text align varies on whether the stack is negative and
            // if the chart is inverted or not.
            // First test the user supplied value, then use the dynamic.
            this.alignOptions = {
                align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),
                verticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),
                y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),
                x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)
            };

            this.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');
        }

        StackItem.prototype = {
            destroy: function () {
                destroyObjectProperties(this, this.axis);
            },

            /**
             * Renders the stack total label and adds it to the stack label group.
             */
            render: function (group) {
                var options = this.options,
                    formatOption = options.format,
                    str = formatOption ?
                        format(formatOption, this) :
                        options.formatter.call(this);  // format the text in the label

                // Change the text to reflect the new total and set visibility to hidden in case the serie is hidden
                if (this.label) {
                    this.label.attr({ text: str, visibility: HIDDEN });
                    // Create new label
                } else {
                    this.label =
                        this.axis.chart.renderer.text(str, null, null, options.useHTML)		// dummy positions, actual position updated with setOffset method in columnseries
                            .css(options.style)				// apply style
                            .attr({
                                align: this.textAlign,				// fix the text-anchor
                                rotation: options.rotation,	// rotation
                                visibility: HIDDEN					// hidden until setOffset is called
                            })
                            .add(group);							// add to the labels-group
                }
            },

            /**
             * Sets the offset that the stack has from the x value and repositions the label.
             */
            setOffset: function (xOffset, xWidth) {
                var stackItem = this,
                    axis = stackItem.axis,
                    chart = axis.chart,
                    inverted = chart.inverted,
                    reversed = axis.reversed,
                    neg = (this.isNegative && !reversed) || (!this.isNegative && reversed), // #4056
                    y = axis.translate(axis.usePercentage ? 100 : this.total, 0, 0, 0, 1), // stack value translated mapped to chart coordinates
                    yZero = axis.translate(0),						// stack origin
                    h = mathAbs(y - yZero),							// stack height
                    x = chart.xAxis[0].translate(this.x) + xOffset,	// stack x position
                    plotHeight = chart.plotHeight,
                    stackBox = {	// this is the box for the complete stack
                        x: inverted ? (neg ? y : y - h) : x,
                        y: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),
                        width: inverted ? h : xWidth,
                        height: inverted ? xWidth : h
                    },
                    label = this.label,
                    alignAttr;

                if (label) {
                    label.align(this.alignOptions, null, stackBox);	// align the label to the box

                    // Set visibility (#678)
                    alignAttr = label.alignAttr;
                    label[this.options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) ? 'show' : 'hide'](true);
                }
            }
        };


        // Stacking methods defined on the Axis prototype

        /**
         * Build the stacks from top down
         */
        Axis.prototype.buildStacks = function () {
            var series = this.series,
                reversedStacks = pick(this.options.reversedStacks, true),
                i = series.length;
            if (!this.isXAxis) {
                this.usePercentage = false;
                while (i--) {
                    series[reversedStacks ? i : series.length - i - 1].setStackedPoints();
                }
                // Loop up again to compute percent stack
                if (this.usePercentage) {
                    for (i = 0; i < series.length; i++) {
                        series[i].setPercentStacks();
                    }
                }
            }
        };

        Axis.prototype.renderStackTotals = function () {
            var axis = this,
                chart = axis.chart,
                renderer = chart.renderer,
                stacks = axis.stacks,
                stackKey,
                oneStack,
                stackCategory,
                stackTotalGroup = axis.stackTotalGroup;

            // Create a separate group for the stack total labels
            if (!stackTotalGroup) {
                axis.stackTotalGroup = stackTotalGroup =
                    renderer.g('stack-labels')
                        .attr({
                            visibility: VISIBLE,
                            zIndex: 6
                        })
                        .add();
            }

            // plotLeft/Top will change when y axis gets wider so we need to translate the
            // stackTotalGroup at every render call. See bug #506 and #516
            stackTotalGroup.translate(chart.plotLeft, chart.plotTop);

            // Render each stack total
            for (stackKey in stacks) {
                oneStack = stacks[stackKey];
                for (stackCategory in oneStack) {
                    oneStack[stackCategory].render(stackTotalGroup);
                }
            }
        };


        // Stacking methods defnied for Series prototype

        /**
         * Adds series' points value to corresponding stack
         */
        Series.prototype.setStackedPoints = function () {
            if (!this.options.stacking || (this.visible !== true && this.chart.options.chart.ignoreHiddenSeries !== false)) {
                return;
            }

            var series = this,
                xData = series.processedXData,
                yData = series.processedYData,
                stackedYData = [],
                yDataLength = yData.length,
                seriesOptions = series.options,
                threshold = seriesOptions.threshold,
                stackThreshold = seriesOptions.startFromThreshold ? threshold : 0,
                stackOption = seriesOptions.stack,
                stacking = seriesOptions.stacking,
                stackKey = series.stackKey,
                negKey = '-' + stackKey,
                negStacks = series.negStacks,
                yAxis = series.yAxis,
                stacks = yAxis.stacks,
                oldStacks = yAxis.oldStacks,
                isNegative,
                stack,
                other,
                key,
                pointKey,
                i,
                x,
                y;

            // loop over the non-null y values and read them into a local array
            for (i = 0; i < yDataLength; i++) {
                x = xData[i];
                y = yData[i];
                pointKey = series.index + ',' + i;

                // Read stacked values into a stack based on the x value,
                // the sign of y and the stack key. Stacking is also handled for null values (#739)
                isNegative = negStacks && y < (stackThreshold ? 0 : threshold);
                key = isNegative ? negKey : stackKey;

                // Create empty object for this stack if it doesn't exist yet
                if (!stacks[key]) {
                    stacks[key] = {};
                }

                // Initialize StackItem for this x
                if (!stacks[key][x]) {
                    if (oldStacks[key] && oldStacks[key][x]) {
                        stacks[key][x] = oldStacks[key][x];
                        stacks[key][x].total = null;
                    } else {
                        stacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption);
                    }
                }

                // If the StackItem doesn't exist, create it first
                stack = stacks[key][x];
                //stack.points[pointKey] = [stack.cum || stackThreshold];
                stack.points[pointKey] = [pick(stack.cum, stackThreshold)];



                // Add value to the stack total
                if (stacking === 'percent') {

                    // Percent stacked column, totals are the same for the positive and negative stacks
                    other = isNegative ? stackKey : negKey;
                    if (negStacks && stacks[other] && stacks[other][x]) {
                        other = stacks[other][x];
                        stack.total = other.total = mathMax(other.total, stack.total) + mathAbs(y) || 0;

                        // Percent stacked areas
                    } else {
                        stack.total = correctFloat(stack.total + (mathAbs(y) || 0));
                    }
                } else {
                    stack.total = correctFloat(stack.total + (y || 0));
                }

                stack.cum = pick(stack.cum, stackThreshold) + (y || 0);

                stack.points[pointKey].push(stack.cum);
                stackedYData[i] = stack.cum;

            }

            if (stacking === 'percent') {
                yAxis.usePercentage = true;
            }

            this.stackedYData = stackedYData; // To be used in getExtremes

            // Reset old stacks
            yAxis.oldStacks = {};
        };

        /**
         * Iterate over all stacks and compute the absolute values to percent
         */
        Series.prototype.setPercentStacks = function () {
            var series = this,
                stackKey = series.stackKey,
                stacks = series.yAxis.stacks,
                processedXData = series.processedXData;

            each([stackKey, '-' + stackKey], function (key) {
                var i = processedXData.length,
                    x,
                    stack,
                    pointExtremes,
                    totalFactor;

                while (i--) {
                    x = processedXData[i];
                    stack = stacks[key] && stacks[key][x];
                    pointExtremes = stack && stack.points[series.index + ',' + i];
                    if (pointExtremes) {
                        totalFactor = stack.total ? 100 / stack.total : 0;
                        pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor); // Y bottom value
                        pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor); // Y value
                        series.stackedYData[i] = pointExtremes[1];
                    }
                }
            });
        };

        // Extend the Chart prototype for dynamic methods
        extend(Chart.prototype, {

            /**
             * Add a series dynamically after  time
             *
             * @param {Object} options The config options
             * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.
             * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
             *    configuration
             *
             * @return {Object} series The newly created series object
             */
            addSeries: function (options, redraw, animation) {
                var series,
                    chart = this;

                if (options) {
                    redraw = pick(redraw, true); // defaults to true

                    fireEvent(chart, 'addSeries', { options: options }, function () {
                        series = chart.initSeries(options);

                        chart.isDirtyLegend = true; // the series array is out of sync with the display
                        chart.linkSeries();
                        if (redraw) {
                            chart.redraw(animation);
                        }
                    });
                }

                return series;
            },

            /**
             * Add an axis to the chart
             * @param {Object} options The axis option
             * @param {Boolean} isX Whether it is an X axis or a value axis
             */
            addAxis: function (options, isX, redraw, animation) {
                var key = isX ? 'xAxis' : 'yAxis',
                    chartOptions = this.options,
                    axis;

                /*jslint unused: false*/
                axis = new Axis(this, merge(options, {
                    index: this[key].length,
                    isX: isX
                }));
                /*jslint unused: true*/

                // Push the new axis options to the chart options
                chartOptions[key] = splat(chartOptions[key] || {});
                chartOptions[key].push(options);

                if (pick(redraw, true)) {
                    this.redraw(animation);
                }
            },

            /**
             * Dim the chart and show a loading text or symbol
             * @param {String} str An optional text to show in the loading label instead of the default one
             */
            showLoading: function (str) {
                var chart = this,
                    options = chart.options,
                    loadingDiv = chart.loadingDiv,
                    loadingOptions = options.loading,
                    setLoadingSize = function () {
                        if (loadingDiv) {
                            css(loadingDiv, {
                                left: chart.plotLeft + PX,
                                top: chart.plotTop + PX,
                                width: chart.plotWidth + PX,
                                height: chart.plotHeight + PX
                            });
                        }
                    };

                // create the layer at the first call
                if (!loadingDiv) {
                    chart.loadingDiv = loadingDiv = createElement(DIV, {
                        className: PREFIX + 'loading'
                    }, extend(loadingOptions.style, {
                        zIndex: 10,
                        display: NONE
                    }), chart.container);

                    chart.loadingSpan = createElement(
                        'span',
                        null,
                        loadingOptions.labelStyle,
                        loadingDiv
                    );
                    addEvent(chart, 'redraw', setLoadingSize); // #1080
                }

                // update text
                chart.loadingSpan.innerHTML = str || options.lang.loading;

                // show it
                if (!chart.loadingShown) {
                    css(loadingDiv, {
                        opacity: 0,
                        display: ''
                    });
                    animate(loadingDiv, {
                        opacity: loadingOptions.style.opacity
                    }, {
                        duration: loadingOptions.showDuration || 0
                    });
                    chart.loadingShown = true;
                }
                setLoadingSize();
            },

            /**
             * Hide the loading layer
             */
            hideLoading: function () {
                var options = this.options,
                    loadingDiv = this.loadingDiv;

                if (loadingDiv) {
                    animate(loadingDiv, {
                        opacity: 0
                    }, {
                        duration: options.loading.hideDuration || 100,
                        complete: function () {
                            css(loadingDiv, { display: NONE });
                        }
                    });
                }
                this.loadingShown = false;
            }
        });

        // extend the Point prototype for dynamic methods
        extend(Point.prototype, {
            /**
             * Update the point with new options (typically x/y data) and optionally redraw the series.
             *
             * @param {Object} options Point options as defined in the series.data array
             * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
             * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
             *    configuration
             *
             */
            update: function (options, redraw, animation, runEvent) {
                var point = this,
                    series = point.series,
                    graphic = point.graphic,
                    i,
                    chart = series.chart,
                    seriesOptions = series.options,
                    names = series.xAxis && series.xAxis.names;

                redraw = pick(redraw, true);

                function update() {

                    point.applyOptions(options);

                    // Update visuals
                    if (point.y === null && graphic) { // #4146
                        point.graphic = graphic.destroy();
                    }
                    if (isObject(options) && !isArray(options)) {
                        // Defer the actual redraw until getAttribs has been called (#3260)
                        point.redraw = function () {
                            if (graphic) {
                                if (options && options.marker && options.marker.symbol) {
                                    point.graphic = graphic.destroy();
                                } else {
                                    graphic.attr(point.pointAttr[point.state || ''])[point.visible === false ? 'hide' : 'show'](); // #2430
                                }
                            }
                            if (options && options.dataLabels && point.dataLabel) { // #2468
                                point.dataLabel = point.dataLabel.destroy();
                            }
                            point.redraw = null;
                        };
                    }

                    // record changes in the parallel arrays
                    i = point.index;
                    series.updateParallelArrays(point, i);
                    if (names && point.name) {
                        names[point.x] = point.name;
                    }

                    seriesOptions.data[i] = point.options;

                    // redraw
                    series.isDirty = series.isDirtyData = true;
                    if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320
                        chart.isDirtyBox = true;
                    }

                    if (seriesOptions.legendType === 'point') { // #1831, #1885
                        chart.isDirtyLegend = true;
                    }
                    if (redraw) {
                        chart.redraw(animation);
                    }
                }

                // Fire the event with a default handler of doing the update
                if (runEvent === false) { // When called from setData
                    update();
                } else {
                    point.firePointEvent('update', { options: options }, update);
                }
            },

            /**
             * Remove a point and optionally redraw the series and if necessary the axes
             * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
             * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
             *    configuration
             */
            remove: function (redraw, animation) {
                this.series.removePoint(inArray(this, this.series.data), redraw, animation);
            }
        });

        // Extend the series prototype for dynamic methods
        extend(Series.prototype, {
            /**
             * Add a point dynamically after chart load time
             * @param {Object} options Point options as given in series.data
             * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
             * @param {Boolean} shift If shift is true, a point is shifted off the start
             *    of the series as one is appended to the end.
             * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
             *    configuration
             */
            addPoint: function (options, redraw, shift, animation) {
                var series = this,
                    seriesOptions = series.options,
                    data = series.data,
                    graph = series.graph,
                    area = series.area,
                    chart = series.chart,
                    names = series.xAxis && series.xAxis.names,
                    currentShift = (graph && graph.shift) || 0,
                    shiftShapes = ['graph', 'area'],
                    dataOptions = seriesOptions.data,
                    point,
                    isInTheMiddle,
                    xData = series.xData,
                    i,
                    x;

                setAnimation(animation, chart);

                // Make graph animate sideways
                if (shift) {
                    i = series.zones.length;
                    while (i--) {
                        shiftShapes.push('zoneGraph' + i, 'zoneArea' + i);
                    }
                    each(shiftShapes, function (shape) {
                        if (series[shape]) {
                            series[shape].shift = currentShift + 1;
                        }
                    });
                }
                if (area) {
                    area.isArea = true; // needed in animation, both with and without shift
                }

                // Optional redraw, defaults to true
                redraw = pick(redraw, true);

                // Get options and push the point to xData, yData and series.options. In series.generatePoints
                // the Point instance will be created on demand and pushed to the series.data array.
                point = { series: series };
                series.pointClass.prototype.applyOptions.apply(point, [options]);
                x = point.x;

                // Get the insertion point
                i = xData.length;
                if (series.requireSorting && x < xData[i - 1]) {
                    isInTheMiddle = true;
                    while (i && xData[i - 1] > x) {
                        i--;
                    }
                }

                series.updateParallelArrays(point, 'splice', i, 0, 0); // insert undefined item
                series.updateParallelArrays(point, i); // update it

                if (names && point.name) {
                    names[x] = point.name;
                }
                dataOptions.splice(i, 0, options);

                if (isInTheMiddle) {
                    series.data.splice(i, 0, null);
                    series.processData();
                }

                // Generate points to be added to the legend (#1329)
                if (seriesOptions.legendType === 'point') {
                    series.generatePoints();
                }

                // Shift the first point off the parallel arrays
                // todo: consider series.removePoint(i) method
                if (shift) {
                    if (data[0] && data[0].remove) {
                        data[0].remove(false);
                    } else {
                        data.shift();
                        series.updateParallelArrays(point, 'shift');

                        dataOptions.shift();
                    }
                }

                // redraw
                series.isDirty = true;
                series.isDirtyData = true;
                if (redraw) {
                    series.getAttribs(); // #1937
                    chart.redraw();
                }
            },

            /**
             * Remove a point (rendered or not), by index
             */
            removePoint: function (i, redraw, animation) {

                var series = this,
                    data = series.data,
                    point = data[i],
                    points = series.points,
                    chart = series.chart,
                    remove = function () {

                        if (data.length === points.length) {
                            points.splice(i, 1);
                        }
                        data.splice(i, 1);
                        series.options.data.splice(i, 1);
                        series.updateParallelArrays(point || { series: series }, 'splice', i, 1);

                        if (point) {
                            point.destroy();
                        }

                        // redraw
                        series.isDirty = true;
                        series.isDirtyData = true;
                        if (redraw) {
                            chart.redraw();
                        }
                    };

                setAnimation(animation, chart);
                redraw = pick(redraw, true);

                // Fire the event with a default handler of removing the point
                if (point) {
                    point.firePointEvent('remove', null, remove);
                } else {
                    remove();
                }
            },

            /**
             * Remove a series and optionally redraw the chart
             *
             * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
             * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
             *    configuration
             */

            remove: function (redraw, animation) {
                var series = this,
                    chart = series.chart;
                redraw = pick(redraw, true);

                if (!series.isRemoving) {  /* prevent triggering native event in jQuery
				(calling the remove function from the remove event) */
                    series.isRemoving = true;

                    // fire the event with a default handler of removing the point
                    fireEvent(series, 'remove', null, function () {


                        // destroy elements
                        series.destroy();


                        // redraw
                        chart.isDirtyLegend = chart.isDirtyBox = true;
                        chart.linkSeries();

                        if (redraw) {
                            chart.redraw(animation);
                        }
                    });

                }
                series.isRemoving = false;
            },

            /**
             * Update the series with a new set of options
             */
            update: function (newOptions, redraw) {
                var series = this,
                    chart = this.chart,
                    // must use user options when changing type because this.options is merged
                    // in with type specific plotOptions
                    oldOptions = this.userOptions,
                    oldType = this.type,
                    proto = seriesTypes[oldType].prototype,
                    preserve = ['group', 'markerGroup', 'dataLabelsGroup'],
                    n;

                // If we're changing type or zIndex, create new groups (#3380, #3404)
                if ((newOptions.type && newOptions.type !== oldType) || newOptions.zIndex !== undefined) {
                    preserve.length = 0;
                }

                // Make sure groups are not destroyed (#3094)
                each(preserve, function (prop) {
                    preserve[prop] = series[prop];
                    delete series[prop];
                });

                // Do the merge, with some forced options
                newOptions = merge(oldOptions, {
                    animation: false,
                    index: this.index,
                    pointStart: this.xData[0] // when updating after addPoint
                }, { data: this.options.data }, newOptions);

                // Destroy the series and delete all properties. Reinsert all methods 
                // and properties from the new type prototype (#2270, #3719)
                this.remove(false);
                for (n in proto) {
                    this[n] = UNDEFINED;
                }
                extend(this, seriesTypes[newOptions.type || oldType].prototype);

                // Re-register groups (#3094)
                each(preserve, function (prop) {
                    series[prop] = preserve[prop];
                });

                this.init(chart, newOptions);
                chart.linkSeries(); // Links are lost in this.remove (#3028)
                if (pick(redraw, true)) {
                    chart.redraw(false);
                }
            }
        });

        // Extend the Axis.prototype for dynamic methods
        extend(Axis.prototype, {

            /**
             * Update the axis with a new options structure
             */
            update: function (newOptions, redraw) {
                var chart = this.chart;

                newOptions = chart.options[this.coll][this.options.index] = merge(this.userOptions, newOptions);

                this.destroy(true);
                this._addedPlotLB = this.chart._labelPanes = UNDEFINED; // #1611, #2887, #4314

                this.init(chart, extend(newOptions, { events: UNDEFINED }));

                chart.isDirtyBox = true;
                if (pick(redraw, true)) {
                    chart.redraw();
                }
            },

            /**
             * Remove the axis from the chart
             */
            remove: function (redraw) {
                var chart = this.chart,
                    key = this.coll, // xAxis or yAxis
                    axisSeries = this.series,
                    i = axisSeries.length;

                // Remove associated series (#2687)
                while (i--) {
                    if (axisSeries[i]) {
                        axisSeries[i].remove(false);
                    }
                }

                // Remove the axis
                erase(chart.axes, this);
                erase(chart[key], this);
                chart.options[key].splice(this.options.index, 1);
                each(chart[key], function (axis, i) { // Re-index, #1706
                    axis.options.index = i;
                });
                this.destroy();
                chart.isDirtyBox = true;

                if (pick(redraw, true)) {
                    chart.redraw();
                }
            },

            /**
             * Update the axis title by options
             */
            setTitle: function (newTitleOptions, redraw) {
                this.update({ title: newTitleOptions }, redraw);
            },

            /**
             * Set new axis categories and optionally redraw
             * @param {Array} categories
             * @param {Boolean} redraw
             */
            setCategories: function (categories, redraw) {
                this.update({ categories: categories }, redraw);
            }

        });


        /**
         * LineSeries object
         */
        var LineSeries = extendClass(Series);
        seriesTypes.line = LineSeries;

        /**
         * Set the default options for area
         */
        defaultPlotOptions.area = merge(defaultSeriesOptions, {
            threshold: 0
            // trackByArea: false,
            // lineColor: null, // overrides color, but lets fillColor be unaltered
            // fillOpacity: 0.75,
            // fillColor: null
        });

        /**
         * AreaSeries object
         */
        var AreaSeries = extendClass(Series, {
            type: 'area',
            /**
             * For stacks, don't split segments on null values. Instead, draw null values with 
             * no marker. Also insert dummy points for any X position that exists in other series
             * in the stack.
             */
            getSegments: function () {
                var series = this,
                    segments = [],
                    segment = [],
                    keys = [],
                    xAxis = this.xAxis,
                    yAxis = this.yAxis,
                    stack = yAxis.stacks[this.stackKey],
                    pointMap = {},
                    plotX,
                    plotY,
                    points = this.points,
                    connectNulls = this.options.connectNulls,
                    i,
                    x;

                if (this.options.stacking && !this.cropped) { // cropped causes artefacts in Stock, and perf issue
                    // Create a map where we can quickly look up the points by their X value.
                    for (i = 0; i < points.length; i++) {
                        pointMap[points[i].x] = points[i];
                    }

                    // Sort the keys (#1651)
                    for (x in stack) {
                        if (stack[x].total !== null) { // nulled after switching between grouping and not (#1651, #2336)
                            keys.push(+x);
                        }
                    }
                    keys.sort(function (a, b) {
                        return a - b;
                    });

                    each(keys, function (x) {
                        var y = 0,
                            stackPoint;

                        if (connectNulls && (!pointMap[x] || pointMap[x].y === null)) { // #1836
                            return;

                            // The point exists, push it to the segment
                        } else if (pointMap[x]) {
                            segment.push(pointMap[x]);

                            // There is no point for this X value in this series, so we 
                            // insert a dummy point in order for the areas to be drawn
                            // correctly.
                        } else {

                            // Loop down the stack to find the series below this one that has
                            // a value (#1991)
                            for (i = series.index; i <= yAxis.series.length; i++) {
                                stackPoint = stack[x].points[i + ',' + x];
                                if (stackPoint) {
                                    y = stackPoint[1];
                                    break;
                                }
                            }

                            plotX = xAxis.translate(x);
                            plotY = yAxis.toPixels(y, true);
                            segment.push({
                                y: null,
                                plotX: plotX,
                                clientX: plotX,
                                plotY: plotY,
                                yBottom: plotY,
                                onMouseOver: noop
                            });
                        }
                    });

                    if (segment.length) {
                        segments.push(segment);
                    }

                } else {
                    Series.prototype.getSegments.call(this);
                    segments = this.segments;
                }

                this.segments = segments;
            },

            /**
             * Extend the base Series getSegmentPath method by adding the path for the area.
             * This path is pushed to the series.areaPath property.
             */
            getSegmentPath: function (segment) {

                var segmentPath = Series.prototype.getSegmentPath.call(this, segment), // call base method
                    areaSegmentPath = [].concat(segmentPath), // work on a copy for the area path
                    i,
                    options = this.options,
                    segLength = segmentPath.length,
                    translatedThreshold = this.yAxis.getThreshold(options.threshold), // #2181
                    yBottom;

                if (segLength === 3) { // for animation from 1 to two points
                    areaSegmentPath.push(L, segmentPath[1], segmentPath[2]);
                }
                if (options.stacking && !this.closedStacks) {

                    // Follow stack back. Todo: implement areaspline. A general solution could be to 
                    // reverse the entire graphPath of the previous series, though may be hard with
                    // splines and with series with different extremes
                    for (i = segment.length - 1; i >= 0; i--) {

                        yBottom = pick(segment[i].yBottom, translatedThreshold);

                        // step line?
                        if (i < segment.length - 1 && options.step) {
                            areaSegmentPath.push(segment[i + 1].plotX, yBottom);
                        }

                        areaSegmentPath.push(segment[i].plotX, yBottom);
                    }

                } else { // follow zero line back
                    this.closeSegment(areaSegmentPath, segment, translatedThreshold);
                }
                this.areaPath = this.areaPath.concat(areaSegmentPath);
                return segmentPath;
            },

            /**
             * Extendable method to close the segment path of an area. This is overridden in polar 
             * charts.
             */
            closeSegment: function (path, segment, translatedThreshold) {
                path.push(
                    L,
                    segment[segment.length - 1].plotX,
                    translatedThreshold,
                    L,
                    segment[0].plotX,
                    translatedThreshold
                );
            },

            /**
             * Draw the graph and the underlying area. This method calls the Series base
             * function and adds the area. The areaPath is calculated in the getSegmentPath
             * method called from Series.prototype.drawGraph.
             */
            drawGraph: function () {

                // Define or reset areaPath
                this.areaPath = [];

                // Call the base method
                Series.prototype.drawGraph.apply(this);

                // Define local variables
                var series = this,
                    areaPath = this.areaPath,
                    options = this.options,
                    zones = this.zones,
                    props = [['area', this.color, options.fillColor]]; // area name, main color, fill color

                each(zones, function (threshold, i) {
                    props.push(['zoneArea' + i, threshold.color || series.color, threshold.fillColor || options.fillColor]);
                });
                each(props, function (prop) {
                    var areaKey = prop[0],
                        area = series[areaKey];

                    // Create or update the area
                    if (area) { // update
                        area.animate({ d: areaPath });

                    } else { // create
                        series[areaKey] = series.chart.renderer.path(areaPath)
                            .attr({
                                fill: pick(
                                    prop[2],
                                    Color(prop[1]).setOpacity(pick(options.fillOpacity, 0.75)).get()
                                ),
                                zIndex: 0 // #1069
                            }).add(series.group);
                    }
                });
            },

            drawLegendSymbol: LegendSymbolMixin.drawRectangle
        });

        seriesTypes.area = AreaSeries;
        /**
         * Set the default options for spline
         */
        defaultPlotOptions.spline = merge(defaultSeriesOptions);

        /**
         * SplineSeries object
         */
        var SplineSeries = extendClass(Series, {
            type: 'spline',

            /**
             * Get the spline segment from a given point's previous neighbour to the given point
             */
            getPointSpline: function (segment, point, i) {
                var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc
                    denom = smoothing + 1,
                    plotX = point.plotX,
                    plotY = point.plotY,
                    lastPoint = segment[i - 1],
                    nextPoint = segment[i + 1],
                    leftContX,
                    leftContY,
                    rightContX,
                    rightContY,
                    ret;

                // find control points
                if (lastPoint && nextPoint) {

                    var lastX = lastPoint.plotX,
                        lastY = lastPoint.plotY,
                        nextX = nextPoint.plotX,
                        nextY = nextPoint.plotY,
                        correction;

                    leftContX = (smoothing * plotX + lastX) / denom;
                    leftContY = (smoothing * plotY + lastY) / denom;
                    rightContX = (smoothing * plotX + nextX) / denom;
                    rightContY = (smoothing * plotY + nextY) / denom;

                    // have the two control points make a straight line through main point
                    correction = ((rightContY - leftContY) * (rightContX - plotX)) /
                        (rightContX - leftContX) + plotY - rightContY;

                    leftContY += correction;
                    rightContY += correction;

                    // to prevent false extremes, check that control points are between
                    // neighbouring points' y values
                    if (leftContY > lastY && leftContY > plotY) {
                        leftContY = mathMax(lastY, plotY);
                        rightContY = 2 * plotY - leftContY; // mirror of left control point
                    } else if (leftContY < lastY && leftContY < plotY) {
                        leftContY = mathMin(lastY, plotY);
                        rightContY = 2 * plotY - leftContY;
                    }
                    if (rightContY > nextY && rightContY > plotY) {
                        rightContY = mathMax(nextY, plotY);
                        leftContY = 2 * plotY - rightContY;
                    } else if (rightContY < nextY && rightContY < plotY) {
                        rightContY = mathMin(nextY, plotY);
                        leftContY = 2 * plotY - rightContY;
                    }

                    // record for drawing in next point
                    point.rightContX = rightContX;
                    point.rightContY = rightContY;

                }

                // Visualize control points for debugging
                /*
                if (leftContX) {
                    this.chart.renderer.circle(leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop, 2)
                        .attr({
                            stroke: 'red',
                            'stroke-width': 1,
                            fill: 'none'
                        })
                        .add();
                    this.chart.renderer.path(['M', leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop,
                        'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
                        .attr({
                            stroke: 'red',
                            'stroke-width': 1
                        })
                        .add();
                    this.chart.renderer.circle(rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop, 2)
                        .attr({
                            stroke: 'green',
                            'stroke-width': 1,
                            fill: 'none'
                        })
                        .add();
                    this.chart.renderer.path(['M', rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop,
                        'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
                        .attr({
                            stroke: 'green',
                            'stroke-width': 1
                        })
                        .add();
                }
                */

                // moveTo or lineTo
                if (!i) {
                    ret = [M, plotX, plotY];
                } else { // curve from last point to this
                    ret = [
                        'C',
                        lastPoint.rightContX || lastPoint.plotX,
                        lastPoint.rightContY || lastPoint.plotY,
                        leftContX || plotX,
                        leftContY || plotY,
                        plotX,
                        plotY
                    ];
                    lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later
                }
                return ret;
            }
        });
        seriesTypes.spline = SplineSeries;

        /**
         * Set the default options for areaspline
         */
        defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);

        /**
         * AreaSplineSeries object
         */
        var areaProto = AreaSeries.prototype,
            AreaSplineSeries = extendClass(SplineSeries, {
                type: 'areaspline',
                closedStacks: true, // instead of following the previous graph back, follow the threshold back

                // Mix in methods from the area series
                getSegmentPath: areaProto.getSegmentPath,
                closeSegment: areaProto.closeSegment,
                drawGraph: areaProto.drawGraph,
                drawLegendSymbol: LegendSymbolMixin.drawRectangle
            });

        seriesTypes.areaspline = AreaSplineSeries;

        /**
         * Set the default options for column
         */
        defaultPlotOptions.column = merge(defaultSeriesOptions, {
            borderColor: '#FFFFFF',
            //borderWidth: 1,
            borderRadius: 0,
            //colorByPoint: undefined,
            groupPadding: 0.2,
            //grouping: true,
            marker: null, // point options are specified in the base options
            pointPadding: 0.1,
            //pointWidth: null,
            minPointLength: 0,
            cropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes
            pointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories
            states: {
                hover: {
                    brightness: 0.1,
                    shadow: false,
                    halo: false
                },
                select: {
                    color: '#C0C0C0',
                    borderColor: '#000000',
                    shadow: false
                }
            },
            dataLabels: {
                align: null, // auto
                verticalAlign: null, // auto
                y: null
            },
            startFromThreshold: true, // docs: http://jsfiddle.net/highcharts/hz8fopan/14/
            stickyTracking: false,
            tooltip: {
                distance: 6
            },
            threshold: 0
        });

        /**
         * ColumnSeries object
         */
        var ColumnSeries = extendClass(Series, {
            type: 'column',
            pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
                stroke: 'borderColor',
                fill: 'color',
                r: 'borderRadius'
            },
            cropShoulder: 0,
            directTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.
            trackerGroups: ['group', 'dataLabelsGroup'],
            negStacks: true, // use separate negative stacks, unlike area stacks where a negative 
            // point is substracted from previous (#1910)

            /**
             * Initialize the series
             */
            init: function () {
                Series.prototype.init.apply(this, arguments);

                var series = this,
                    chart = series.chart;

                // if the series is added dynamically, force redraw of other
                // series affected by a new column
                if (chart.hasRendered) {
                    each(chart.series, function (otherSeries) {
                        if (otherSeries.type === series.type) {
                            otherSeries.isDirty = true;
                        }
                    });
                }
            },

            /**
             * Return the width and x offset of the columns adjusted for grouping, groupPadding, pointPadding,
             * pointWidth etc. 
             */
            getColumnMetrics: function () {

                var series = this,
                    options = series.options,
                    xAxis = series.xAxis,
                    yAxis = series.yAxis,
                    reversedXAxis = xAxis.reversed,
                    stackKey,
                    stackGroups = {},
                    columnIndex,
                    columnCount = 0;

                // Get the total number of column type series.
                // This is called on every series. Consider moving this logic to a
                // chart.orderStacks() function and call it on init, addSeries and removeSeries
                if (options.grouping === false) {
                    columnCount = 1;
                } else {
                    each(series.chart.series, function (otherSeries) {
                        var otherOptions = otherSeries.options,
                            otherYAxis = otherSeries.yAxis;
                        if (otherSeries.type === series.type && otherSeries.visible &&
                                yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {  // #642, #2086
                            if (otherOptions.stacking) {
                                stackKey = otherSeries.stackKey;
                                if (stackGroups[stackKey] === UNDEFINED) {
                                    stackGroups[stackKey] = columnCount++;
                                }
                                columnIndex = stackGroups[stackKey];
                            } else if (otherOptions.grouping !== false) { // #1162
                                columnIndex = columnCount++;
                            }
                            otherSeries.columnIndex = columnIndex;
                        }
                    });
                }

                var categoryWidth = mathMin(
                        mathAbs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610
                        xAxis.len // #1535
                    ),
                    groupPadding = categoryWidth * options.groupPadding,
                    groupWidth = categoryWidth - 2 * groupPadding,
                    pointOffsetWidth = groupWidth / columnCount,
                    optionPointWidth = options.pointWidth,
                    pointPadding = defined(optionPointWidth) ? (pointOffsetWidth - optionPointWidth) / 2 :
                        pointOffsetWidth * options.pointPadding,
                    pointWidth = pick(optionPointWidth, pointOffsetWidth - 2 * pointPadding), // exact point width, used in polar charts
                    colIndex = (reversedXAxis ?
                        columnCount - (series.columnIndex || 0) : // #1251
                        series.columnIndex) || 0,
                    pointXOffset = pointPadding + (groupPadding + colIndex *
                        pointOffsetWidth - (categoryWidth / 2)) *
                        (reversedXAxis ? -1 : 1);

                // Save it for reading in linked series (Error bars particularly)
                return (series.columnMetrics = {
                    width: pointWidth,
                    offset: pointXOffset
                });

            },

            /**
             * Translate each point to the plot area coordinate system and find shape positions
             */
            translate: function () {
                var series = this,
                    chart = series.chart,
                    options = series.options,
                    borderWidth = series.borderWidth = pick(
                        options.borderWidth,
                        series.closestPointRange * series.xAxis.transA < 2 ? 0 : 1 // #3635
                    ),
                    yAxis = series.yAxis,
                    threshold = options.threshold,
                    translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),
                    minPointLength = pick(options.minPointLength, 5),
                    metrics = series.getColumnMetrics(),
                    pointWidth = metrics.width,
                    seriesBarW = series.barW = mathMax(pointWidth, 1 + 2 * borderWidth), // postprocessed for border width
                    pointXOffset = series.pointXOffset = metrics.offset,
                    xCrisp = -(borderWidth % 2 ? 0.5 : 0),
                    yCrisp = borderWidth % 2 ? 0.5 : 1;

                if (chart.inverted) {
                    translatedThreshold -= 0.5; // #3355
                    if (chart.renderer.isVML) {
                        yCrisp += 1;
                    }
                }

                // When the pointPadding is 0, we want the columns to be packed tightly, so we allow individual
                // columns to have individual sizes. When pointPadding is greater, we strive for equal-width
                // columns (#2694).
                if (options.pointPadding) {
                    seriesBarW = mathCeil(seriesBarW);
                }

                Series.prototype.translate.apply(series);

                // Record the new values
                each(series.points, function (point) {
                    var yBottom = pick(point.yBottom, translatedThreshold),
                        safeDistance = 999 + mathAbs(yBottom),
                        plotY = mathMin(mathMax(-safeDistance, point.plotY), yAxis.len + safeDistance), // Don't draw too far outside plot area (#1303, #2241, #4264)
                        barX = point.plotX + pointXOffset,
                        barW = seriesBarW,
                        barY = mathMin(plotY, yBottom),
                        right,
                        bottom,
                        fromTop,
                        up,
                        barH = mathMax(plotY, yBottom) - barY;

                    // Handle options.minPointLength
                    if (mathAbs(barH) < minPointLength) {
                        if (minPointLength) {
                            barH = minPointLength;
                            up = (!yAxis.reversed && !point.negative) || (yAxis.reversed && point.negative);
                            barY =
                                mathRound(mathAbs(barY - translatedThreshold) > minPointLength ? // stacked
                                    yBottom - minPointLength : // keep position
                                    translatedThreshold - (up ? minPointLength : 0)); // #1485, #4051
                        }
                    }

                    // Cache for access in polar
                    point.barX = barX;
                    point.pointWidth = pointWidth;

                    // Round off to obtain crisp edges and avoid overlapping with neighbours (#2694)
                    right = mathRound(barX + barW) + xCrisp;
                    barX = mathRound(barX) + xCrisp;
                    barW = right - barX;

                    fromTop = mathAbs(barY) < 0.5;
                    bottom = mathMin(mathRound(barY + barH) + yCrisp, 9e4); // #3575
                    barY = mathRound(barY) + yCrisp;
                    barH = bottom - barY;

                    // Top edges are exceptions
                    if (fromTop) {
                        barY -= 1;
                        barH += 1;
                    }

                    // Fix the tooltip on center of grouped columns (#1216, #424, #3648)
                    point.tooltipPos = chart.inverted ?
                        [yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2, barH] :
                        [barX + barW / 2, plotY + yAxis.pos - chart.plotTop, barH];

                    // Register shape type and arguments to be used in drawPoints
                    point.shapeType = 'rect';
                    point.shapeArgs = {
                        x: barX,
                        y: barY,
                        width: barW,
                        height: barH
                    };
                });

            },

            getSymbol: noop,

            /**
             * Use a solid rectangle like the area series types
             */
            drawLegendSymbol: LegendSymbolMixin.drawRectangle,


            /**
             * Columns have no graph
             */
            drawGraph: noop,

            /**
             * Draw the columns. For bars, the series.group is rotated, so the same coordinates
             * apply for columns and bars. This method is inherited by scatter series.
             *
             */
            drawPoints: function () {
                var series = this,
                    chart = this.chart,
                    options = series.options,
                    renderer = chart.renderer,
                    animationLimit = options.animationLimit || 250,
                    shapeArgs,
                    pointAttr;

                // draw the columns
                each(series.points, function (point) {
                    var plotY = point.plotY,
                        graphic = point.graphic,
                        borderAttr;

                    if (plotY !== UNDEFINED && !isNaN(plotY) && point.y !== null) {
                        shapeArgs = point.shapeArgs;

                        borderAttr = defined(series.borderWidth) ? {
                            'stroke-width': series.borderWidth
                        } : {};

                        pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || series.pointAttr[NORMAL_STATE];

                        if (graphic) { // update
                            stop(graphic);
                            graphic.attr(borderAttr)[chart.pointCount < animationLimit ? 'animate' : 'attr'](merge(shapeArgs));

                        } else {
                            point.graphic = graphic = renderer[point.shapeType](shapeArgs)
                                .attr(borderAttr)
                                .attr(pointAttr)
                                .add(series.group)
                                .shadow(options.shadow, null, options.stacking && !options.borderRadius);
                        }

                    } else if (graphic) {
                        point.graphic = graphic.destroy(); // #1269
                    }
                });
            },

            /**
             * Animate the column heights one by one from zero
             * @param {Boolean} init Whether to initialize the animation or run it
             */
            animate: function (init) {
                var series = this,
                    yAxis = this.yAxis,
                    options = series.options,
                    inverted = this.chart.inverted,
                    attr = {},
                    translatedThreshold;

                if (hasSVG) { // VML is too slow anyway
                    if (init) {
                        attr.scaleY = 0.001;
                        translatedThreshold = mathMin(yAxis.pos + yAxis.len, mathMax(yAxis.pos, yAxis.toPixels(options.threshold)));
                        if (inverted) {
                            attr.translateX = translatedThreshold - yAxis.len;
                        } else {
                            attr.translateY = translatedThreshold;
                        }
                        series.group.attr(attr);

                    } else { // run the animation

                        attr.scaleY = 1;
                        attr[inverted ? 'translateX' : 'translateY'] = yAxis.pos;
                        series.group.animate(attr, series.options.animation);

                        // delete this function to allow it only once
                        series.animate = null;
                    }
                }
            },

            /**
             * Remove this series from the chart
             */
            remove: function () {
                var series = this,
                    chart = series.chart;

                // column and bar series affects other series of the same type
                // as they are either stacked or grouped
                if (chart.hasRendered) {
                    each(chart.series, function (otherSeries) {
                        if (otherSeries.type === series.type) {
                            otherSeries.isDirty = true;
                        }
                    });
                }

                Series.prototype.remove.apply(series, arguments);
            }
        });
        seriesTypes.column = ColumnSeries;
        /**
         * Set the default options for bar
         */
        defaultPlotOptions.bar = merge(defaultPlotOptions.column);
        /**
         * The Bar series class
         */
        var BarSeries = extendClass(ColumnSeries, {
            type: 'bar',
            inverted: true
        });
        seriesTypes.bar = BarSeries;

        /**
         * Set the default options for scatter
         */
        defaultPlotOptions.scatter = merge(defaultSeriesOptions, {
            lineWidth: 0,
            marker: {
                enabled: true // Overrides auto-enabling in line series (#3647)
            },
            tooltip: {
                headerFormat: '<span style="color:{series.color}">\u25CF</span> <span style="font-size: 10px;"> {series.name}</span><br/>',
                pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'
            }
        });

        /**
         * The scatter series class
         */
        var ScatterSeries = extendClass(Series, {
            type: 'scatter',
            sorted: false,
            requireSorting: false,
            noSharedTooltip: true,
            trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],
            takeOrdinalPosition: false, // #2342
            kdDimensions: 2,
            drawGraph: function () {
                if (this.options.lineWidth) {
                    Series.prototype.drawGraph.call(this);
                }
            }
        });

        seriesTypes.scatter = ScatterSeries;

        /**
         * Set the default options for pie
         */
        defaultPlotOptions.pie = merge(defaultSeriesOptions, {
            borderColor: '#FFFFFF',
            borderWidth: 1,
            center: [null, null],
            clip: false,
            colorByPoint: true, // always true for pies
            dataLabels: {
                // align: null,
                // connectorWidth: 1,
                // connectorColor: point.color,
                // connectorPadding: 5,
                distance: 30,
                enabled: true,
                formatter: function () { // #2945
                    return this.point.name;
                },
                // softConnector: true,
                x: 0
                // y: 0
            },
            ignoreHiddenPoint: true,
            //innerSize: 0,
            legendType: 'point',
            marker: null, // point options are specified in the base options
            size: null,
            showInLegend: false,
            slicedOffset: 10,
            states: {
                hover: {
                    brightness: 0.1,
                    shadow: false
                }
            },
            stickyTracking: false,
            tooltip: {
                followPointer: true
            }
        });

        /**
         * Extended point object for pies
         */
        var PiePoint = extendClass(Point, {
            /**
             * Initiate the pie slice
             */
            init: function () {

                Point.prototype.init.apply(this, arguments);

                var point = this,
                    toggleSlice;

                extend(point, {
                    visible: point.visible !== false,
                    name: pick(point.name, 'Slice')
                });

                // add event listener for select
                toggleSlice = function (e) {
                    point.slice(e.type === 'select');
                };
                addEvent(point, 'select', toggleSlice);
                addEvent(point, 'unselect', toggleSlice);

                return point;
            },

            /**
             * Toggle the visibility of the pie slice
             * @param {Boolean} vis Whether to show the slice or not. If undefined, the
             *    visibility is toggled
             */
            setVisible: function (vis, redraw) {
                var point = this,
                    series = point.series,
                    chart = series.chart,
                    ignoreHiddenPoint = series.options.ignoreHiddenPoint;

                redraw = pick(redraw, ignoreHiddenPoint);

                if (vis !== point.visible) {

                    // If called without an argument, toggle visibility
                    point.visible = point.options.visible = vis = vis === UNDEFINED ? !point.visible : vis;
                    series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

                    // Show and hide associated elements. This is performed regardless of redraw or not,
                    // because chart.redraw only handles full series.
                    each(['graphic', 'dataLabel', 'connector', 'shadowGroup'], function (key) {
                        if (point[key]) {
                            point[key][vis ? 'show' : 'hide'](true);
                        }
                    });

                    if (point.legendItem) {
                        chart.legend.colorizeItem(point, vis);
                    }

                    // #4170, hide halo after hiding point
                    if (!vis && point.state === 'hover') {
                        point.setState('');
                    }

                    // Handle ignore hidden slices
                    if (ignoreHiddenPoint) {
                        series.isDirty = true;
                    }

                    if (redraw) {
                        chart.redraw();
                    }
                }
            },

            /**
             * Set or toggle whether the slice is cut out from the pie
             * @param {Boolean} sliced When undefined, the slice state is toggled
             * @param {Boolean} redraw Whether to redraw the chart. True by default.
             */
            slice: function (sliced, redraw, animation) {
                var point = this,
                    series = point.series,
                    chart = series.chart,
                    translation;

                setAnimation(animation, chart);

                // redraw is true by default
                redraw = pick(redraw, true);

                // if called without an argument, toggle
                point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;
                series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

                translation = sliced ? point.slicedTranslation : {
                    translateX: 0,
                    translateY: 0
                };

                point.graphic.animate(translation);

                if (point.shadowGroup) {
                    point.shadowGroup.animate(translation);
                }

            },

            haloPath: function (size) {
                var shapeArgs = this.shapeArgs,
                    chart = this.series.chart;

                return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(chart.plotLeft + shapeArgs.x, chart.plotTop + shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {
                    innerR: this.shapeArgs.r,
                    start: shapeArgs.start,
                    end: shapeArgs.end
                });
            }
        });

        /**
         * The Pie series class
         */
        var PieSeries = {
            type: 'pie',
            isCartesian: false,
            pointClass: PiePoint,
            requireSorting: false,
            directTouch: true,
            noSharedTooltip: true,
            trackerGroups: ['group', 'dataLabelsGroup'],
            axisTypes: [],
            pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
                stroke: 'borderColor',
                'stroke-width': 'borderWidth',
                fill: 'color'
            },

            /**
             * Pies have one color each point
             */
            getColor: noop,

            /**
             * Animate the pies in
             */
            animate: function (init) {
                var series = this,
                    points = series.points,
                    startAngleRad = series.startAngleRad;

                if (!init) {
                    each(points, function (point) {
                        var graphic = point.graphic,
                            args = point.shapeArgs;

                        if (graphic) {
                            // start values
                            graphic.attr({
                                r: point.startR || (series.center[3] / 2), // animate from inner radius (#779)
                                start: startAngleRad,
                                end: startAngleRad
                            });

                            // animate
                            graphic.animate({
                                r: args.r,
                                start: args.start,
                                end: args.end
                            }, series.options.animation);
                        }
                    });

                    // delete this function to allow it only once
                    series.animate = null;
                }
            },

            /**
             * Extend the basic setData method by running processData and generatePoints immediately,
             * in order to access the points from the legend.
             */
            setData: function (data, redraw, animation, updatePoints) {
                Series.prototype.setData.call(this, data, false, animation, updatePoints);
                this.processData();
                this.generatePoints();
                if (pick(redraw, true)) {
                    this.chart.redraw(animation);
                }
            },

            /**
             * Recompute total chart sum and update percentages of points.
             */
            updateTotals: function () {
                var i,
                    total = 0,
                    points = this.points,
                    len = points.length,
                    point,
                    ignoreHiddenPoint = this.options.ignoreHiddenPoint;

                // Get the total sum
                for (i = 0; i < len; i++) {
                    point = points[i];
                    total += (ignoreHiddenPoint && !point.visible) ? 0 : point.y;
                }
                this.total = total;

                // Set each point's properties
                for (i = 0; i < len; i++) {
                    point = points[i];
                    point.percentage = (total > 0 && (point.visible || !ignoreHiddenPoint)) ? point.y / total * 100 : 0;
                    point.total = total;
                }
            },

            /**
             * Extend the generatePoints method by adding total and percentage properties to each point
             */
            generatePoints: function () {
                Series.prototype.generatePoints.call(this);
                this.updateTotals();
            },

            /**
             * Do translation for pie slices
             */
            translate: function (positions) {
                this.generatePoints();

                var series = this,
                    cumulative = 0,
                    precision = 1000, // issue #172
                    options = series.options,
                    slicedOffset = options.slicedOffset,
                    connectorOffset = slicedOffset + options.borderWidth,
                    start,
                    end,
                    angle,
                    startAngle = options.startAngle || 0,
                    startAngleRad = series.startAngleRad = mathPI / 180 * (startAngle - 90),
                    endAngleRad = series.endAngleRad = mathPI / 180 * ((pick(options.endAngle, startAngle + 360)) - 90),
                    circ = endAngleRad - startAngleRad, //2 * mathPI,
                    points = series.points,
                    radiusX, // the x component of the radius vector for a given point
                    radiusY,
                    labelDistance = options.dataLabels.distance,
                    ignoreHiddenPoint = options.ignoreHiddenPoint,
                    i,
                    len = points.length,
                    point;

                // Get positions - either an integer or a percentage string must be given.
                // If positions are passed as a parameter, we're in a recursive loop for adjusting
                // space for data labels.
                if (!positions) {
                    series.center = positions = series.getCenter();
                }

                // utility for getting the x value from a given y, used for anticollision logic in data labels
                series.getX = function (y, left) {

                    angle = math.asin(mathMin((y - positions[1]) / (positions[2] / 2 + labelDistance), 1));

                    return positions[0] +
                        (left ? -1 : 1) *
                        (mathCos(angle) * (positions[2] / 2 + labelDistance));
                };

                // Calculate the geometry for each point
                for (i = 0; i < len; i++) {

                    point = points[i];

                    // set start and end angle
                    start = startAngleRad + (cumulative * circ);
                    if (!ignoreHiddenPoint || point.visible) {
                        cumulative += point.percentage / 100;
                    }
                    end = startAngleRad + (cumulative * circ);

                    // set the shape
                    point.shapeType = 'arc';
                    point.shapeArgs = {
                        x: positions[0],
                        y: positions[1],
                        r: positions[2] / 2,
                        innerR: positions[3] / 2,
                        start: mathRound(start * precision) / precision,
                        end: mathRound(end * precision) / precision
                    };

                    // The angle must stay within -90 and 270 (#2645)
                    angle = (end + start) / 2;
                    if (angle > 1.5 * mathPI) {
                        angle -= 2 * mathPI;
                    } else if (angle < -mathPI / 2) {
                        angle += 2 * mathPI;
                    }

                    // Center for the sliced out slice
                    point.slicedTranslation = {
                        translateX: mathRound(mathCos(angle) * slicedOffset),
                        translateY: mathRound(mathSin(angle) * slicedOffset)
                    };

                    // set the anchor point for tooltips
                    radiusX = mathCos(angle) * positions[2] / 2;
                    radiusY = mathSin(angle) * positions[2] / 2;
                    point.tooltipPos = [
                        positions[0] + radiusX * 0.7,
                        positions[1] + radiusY * 0.7
                    ];

                    point.half = angle < -mathPI / 2 || angle > mathPI / 2 ? 1 : 0;
                    point.angle = angle;

                    // set the anchor point for data labels
                    connectorOffset = mathMin(connectorOffset, labelDistance / 2); // #1678
                    point.labelPos = [
                        positions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector
                        positions[1] + radiusY + mathSin(angle) * labelDistance, // a/a
                        positions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie
                        positions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a
                        positions[0] + radiusX, // landing point for connector
                        positions[1] + radiusY, // a/a
                        labelDistance < 0 ? // alignment
                            'center' :
                            point.half ? 'right' : 'left', // alignment
                        angle // center angle
                    ];

                }
            },

            drawGraph: null,

            /**
             * Draw the data points
             */
            drawPoints: function () {
                var series = this,
                    chart = series.chart,
                    renderer = chart.renderer,
                    groupTranslation,
                    //center,
                    graphic,
                    //group,
                    shadow = series.options.shadow,
                    shadowGroup,
                    shapeArgs,
                    attr;

                if (shadow && !series.shadowGroup) {
                    series.shadowGroup = renderer.g('shadow')
                        .add(series.group);
                }

                // draw the slices
                each(series.points, function (point) {
                    graphic = point.graphic;
                    shapeArgs = point.shapeArgs;
                    shadowGroup = point.shadowGroup;

                    // put the shadow behind all points
                    if (shadow && !shadowGroup) {
                        shadowGroup = point.shadowGroup = renderer.g('shadow')
                            .add(series.shadowGroup);
                    }

                    // if the point is sliced, use special translation, else use plot area traslation
                    groupTranslation = point.sliced ? point.slicedTranslation : {
                        translateX: 0,
                        translateY: 0
                    };

                    //group.translate(groupTranslation[0], groupTranslation[1]);
                    if (shadowGroup) {
                        shadowGroup.attr(groupTranslation);
                    }

                    // draw the slice
                    if (graphic) {
                        graphic.animate(extend(shapeArgs, groupTranslation));
                    } else {
                        attr = { 'stroke-linejoin': 'round' };
                        if (!point.visible) {
                            attr.visibility = 'hidden';
                        }

                        point.graphic = graphic = renderer[point.shapeType](shapeArgs)
                            .setRadialReference(series.center)
                            .attr(
                                point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE]
                            )
                            .attr(attr)
                            .attr(groupTranslation)
                            .add(series.group)
                            .shadow(shadow, shadowGroup);
                    }

                });

            },


            searchPoint: noop,

            /**
             * Utility for sorting data labels
             */
            sortByAngle: function (points, sign) {
                points.sort(function (a, b) {
                    return a.angle !== undefined && (b.angle - a.angle) * sign;
                });
            },

            /**
             * Use a simple symbol from LegendSymbolMixin
             */
            drawLegendSymbol: LegendSymbolMixin.drawRectangle,

            /**
             * Use the getCenter method from drawLegendSymbol
             */
            getCenter: CenteredSeriesMixin.getCenter,

            /**
             * Pies don't have point marker symbols
             */
            getSymbol: noop

        };
        PieSeries = extendClass(Series, PieSeries);
        seriesTypes.pie = PieSeries;

        /**
         * Draw the data labels
         */
        Series.prototype.drawDataLabels = function () {

            var series = this,
                seriesOptions = series.options,
                cursor = seriesOptions.cursor,
                options = seriesOptions.dataLabels,
                points = series.points,
                pointOptions,
                generalOptions,
                hasRendered = series.hasRendered || 0,
                str,
                dataLabelsGroup,
                renderer = series.chart.renderer;

            if (options.enabled || series._hasPointLabels) {

                // Process default alignment of data labels for columns
                if (series.dlProcessOptions) {
                    series.dlProcessOptions(options);
                }

                // Create a separate group for the data labels to avoid rotation
                dataLabelsGroup = series.plotGroup(
                    'dataLabelsGroup',
                    'data-labels',
                    options.defer ? HIDDEN : VISIBLE,
                    options.zIndex || 6
                );

                if (pick(options.defer, true)) {
                    dataLabelsGroup.attr({ opacity: +hasRendered }); // #3300
                    if (!hasRendered) {
                        addEvent(series, 'afterAnimate', function () {
                            if (series.visible) { // #3023, #3024
                                dataLabelsGroup.show();
                            }
                            dataLabelsGroup[seriesOptions.animation ? 'animate' : 'attr']({ opacity: 1 }, { duration: 200 });
                        });
                    }
                }

                // Make the labels for each point
                generalOptions = options;
                each(points, function (point) {

                    var enabled,
                        dataLabel = point.dataLabel,
                        labelConfig,
                        attr,
                        name,
                        rotation,
                        connector = point.connector,
                        isNew = true,
                        style,
                        moreStyle = {};

                    // Determine if each data label is enabled
                    pointOptions = point.dlOptions || (point.options && point.options.dataLabels); // dlOptions is used in treemaps
                    enabled = pick(pointOptions && pointOptions.enabled, generalOptions.enabled); // #2282


                    // If the point is outside the plot area, destroy it. #678, #820
                    if (dataLabel && !enabled) {
                        point.dataLabel = dataLabel.destroy();

                        // Individual labels are disabled if the are explicitly disabled
                        // in the point options, or if they fall outside the plot area.
                    } else if (enabled) {

                        // Create individual options structure that can be extended without
                        // affecting others
                        options = merge(generalOptions, pointOptions);
                        style = options.style;

                        rotation = options.rotation;

                        // Get the string
                        labelConfig = point.getLabelConfig();
                        str = options.format ?
                            format(options.format, labelConfig) :
                            options.formatter.call(labelConfig, options);

                        // Determine the color
                        style.color = pick(options.color, style.color, series.color, 'black');


                        // update existing label
                        if (dataLabel) {

                            if (defined(str)) {
                                dataLabel
                                    .attr({
                                        text: str
                                    });
                                isNew = false;

                            } else { // #1437 - the label is shown conditionally
                                point.dataLabel = dataLabel = dataLabel.destroy();
                                if (connector) {
                                    point.connector = connector.destroy();
                                }
                            }

                            // create new label
                        } else if (defined(str)) {
                            attr = {
                                //align: align,
                                fill: options.backgroundColor,
                                stroke: options.borderColor,
                                'stroke-width': options.borderWidth,
                                r: options.borderRadius || 0,
                                rotation: rotation,
                                padding: options.padding,
                                zIndex: 1
                            };

                            // Get automated contrast color
                            if (style.color === 'contrast') {
                                moreStyle.color = options.inside || options.distance < 0 || !!seriesOptions.stacking ?
                                    renderer.getContrast(point.color || series.color) :
                                    '#000000';
                            }
                            if (cursor) {
                                moreStyle.cursor = cursor;
                            }


                            // Remove unused attributes (#947)
                            for (name in attr) {
                                if (attr[name] === UNDEFINED) {
                                    delete attr[name];
                                }
                            }

                            dataLabel = point.dataLabel = renderer[rotation ? 'text' : 'label']( // labels don't support rotation
                                str,
                                0,
                                -999,
                                options.shape,
                                null,
                                null,
                                options.useHTML
                            )
                            .attr(attr)
                            .css(extend(style, moreStyle))
                            .add(dataLabelsGroup)
                            .shadow(options.shadow);

                        }

                        if (dataLabel) {
                            // Now the data label is created and placed at 0,0, so we need to align it
                            series.alignDataLabel(point, dataLabel, options, null, isNew);
                        }
                    }
                });
            }
        };

        /**
         * Align each individual data label
         */
        Series.prototype.alignDataLabel = function (point, dataLabel, options, alignTo, isNew) {
            var chart = this.chart,
                inverted = chart.inverted,
                plotX = pick(point.plotX, -999),
                plotY = pick(point.plotY, -999),
                bBox = dataLabel.getBBox(),
                baseline = chart.renderer.fontMetrics(options.style.fontSize).b,
                rotCorr, // rotation correction
                // Math.round for rounding errors (#2683), alignTo to allow column labels (#2700)
                visible = this.visible && (point.series.forceDL || chart.isInsidePlot(plotX, mathRound(plotY), inverted) ||
                    (alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, inverted))),
                alignAttr; // the final position;

            if (visible) {

                // The alignment box is a singular point
                alignTo = extend({
                    x: inverted ? chart.plotWidth - plotY : plotX,
                    y: mathRound(inverted ? chart.plotHeight - plotX : plotY),
                    width: 0,
                    height: 0
                }, alignTo);

                // Add the text size for alignment calculation
                extend(options, {
                    width: bBox.width,
                    height: bBox.height
                });

                // Allow a hook for changing alignment in the last moment, then do the alignment
                if (options.rotation) { // Fancy box alignment isn't supported for rotated text
                    rotCorr = chart.renderer.rotCorr(baseline, options.rotation); // #3723
                    dataLabel[isNew ? 'attr' : 'animate']({
                        x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,
                        y: alignTo.y + options.y + alignTo.height / 2
                    })
                        .attr({ // #3003
                            align: options.align
                        });
                } else {
                    dataLabel.align(options, null, alignTo);
                    alignAttr = dataLabel.alignAttr;

                    // Handle justify or crop
                    if (pick(options.overflow, 'justify') === 'justify') {
                        this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);

                    } else if (pick(options.crop, true)) {
                        // Now check that the data label is within the plot area
                        visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);

                    }

                    // When we're using a shape, make it possible with a connector or an arrow pointing to thie point
                    if (options.shape) {
                        dataLabel.attr({
                            anchorX: point.plotX,
                            anchorY: point.plotY
                        });
                    }

                }
            }

            // Show or hide based on the final aligned position
            if (!visible) {
                dataLabel.attr({ y: -999 });
                dataLabel.placed = false; // don't animate back in
            }

        };

        /**
         * If data labels fall partly outside the plot area, align them back in, in a way that
         * doesn't hide the point.
         */
        Series.prototype.justifyDataLabel = function (dataLabel, options, alignAttr, bBox, alignTo, isNew) {
            var chart = this.chart,
                align = options.align,
                verticalAlign = options.verticalAlign,
                off,
                justified,
                padding = dataLabel.box ? 0 : (dataLabel.padding || 0);

            // Off left
            off = alignAttr.x + padding;
            if (off < 0) {
                if (align === 'right') {
                    options.align = 'left';
                } else {
                    options.x = -off;
                }
                justified = true;
            }

            // Off right
            off = alignAttr.x + bBox.width - padding;
            if (off > chart.plotWidth) {
                if (align === 'left') {
                    options.align = 'right';
                } else {
                    options.x = chart.plotWidth - off;
                }
                justified = true;
            }

            // Off top
            off = alignAttr.y + padding;
            if (off < 0) {
                if (verticalAlign === 'bottom') {
                    options.verticalAlign = 'top';
                } else {
                    options.y = -off;
                }
                justified = true;
            }

            // Off bottom
            off = alignAttr.y + bBox.height - padding;
            if (off > chart.plotHeight) {
                if (verticalAlign === 'top') {
                    options.verticalAlign = 'bottom';
                } else {
                    options.y = chart.plotHeight - off;
                }
                justified = true;
            }

            if (justified) {
                dataLabel.placed = !isNew;
                dataLabel.align(options, null, alignTo);
            }
        };

        /**
         * Override the base drawDataLabels method by pie specific functionality
         */
        if (seriesTypes.pie) {
            seriesTypes.pie.prototype.drawDataLabels = function () {
                var series = this,
                    data = series.data,
                    point,
                    chart = series.chart,
                    options = series.options.dataLabels,
                    connectorPadding = pick(options.connectorPadding, 10),
                    connectorWidth = pick(options.connectorWidth, 1),
                    plotWidth = chart.plotWidth,
                    plotHeight = chart.plotHeight,
                    connector,
                    connectorPath,
                    softConnector = pick(options.softConnector, true),
                    distanceOption = options.distance,
                    seriesCenter = series.center,
                    radius = seriesCenter[2] / 2,
                    centerY = seriesCenter[1],
                    outside = distanceOption > 0,
                    dataLabel,
                    dataLabelWidth,
                    labelPos,
                    labelHeight,
                    halves = [// divide the points into right and left halves for anti collision
                        [], // right
                        []  // left
                    ],
                    x,
                    y,
                    visibility,
                    rankArr,
                    i,
                    j,
                    overflow = [0, 0, 0, 0], // top, right, bottom, left
                    sort = function (a, b) {
                        return b.y - a.y;
                    };

                // get out if not enabled
                if (!series.visible || (!options.enabled && !series._hasPointLabels)) {
                    return;
                }

                // run parent method
                Series.prototype.drawDataLabels.apply(series);

                // arrange points for detection collision
                each(data, function (point) {
                    if (point.dataLabel && point.visible) { // #407, #2510
                        halves[point.half].push(point);
                    }
                });

                /* Loop over the points in each half, starting from the top and bottom
                 * of the pie to detect overlapping labels.
                 */
                i = 2;
                while (i--) {

                    var slots = [],
                        slotsLength,
                        usedSlots = [],
                        points = halves[i],
                        pos,
                        bottom,
                        length = points.length,
                        slotIndex;

                    if (!length) {
                        continue;
                    }

                    // Sort by angle
                    series.sortByAngle(points, i - 0.5);

                    // Assume equal label heights on either hemisphere (#2630)
                    j = labelHeight = 0;
                    while (!labelHeight && points[j]) { // #1569
                        labelHeight = points[j] && points[j].dataLabel && (points[j].dataLabel.getBBox().height || 21); // 21 is for #968
                        j++;
                    }

                    // Only do anti-collision when we are outside the pie and have connectors (#856)
                    if (distanceOption > 0) {

                        // Build the slots
                        bottom = mathMin(centerY + radius + distanceOption, chart.plotHeight);
                        for (pos = mathMax(0, centerY - radius - distanceOption) ; pos <= bottom; pos += labelHeight) {
                            slots.push(pos);
                        }
                        slotsLength = slots.length;


                        /* Visualize the slots
                        if (!series.slotElements) {
                            series.slotElements = [];
                        }
                        if (i === 1) {
                            series.slotElements.forEach(function (elem) {
                                elem.destroy();
                            });
                            series.slotElements.length = 0;
                        }
                            
                        slots.forEach(function (pos, no) {
                            var slotX = series.getX(pos, i) + chart.plotLeft - (i ? 100 : 0),
                                slotY = pos + chart.plotTop;
                            
                            if (!isNaN(slotX)) {
                                series.slotElements.push(chart.renderer.rect(slotX, slotY - 7, 100, labelHeight, 1)
                                    .attr({
                                        'stroke-width': 1,
                                        stroke: 'silver',
                                        fill: 'rgba(0,0,255,0.1)'
                                    })
                                    .add());
                                series.slotElements.push(chart.renderer.text('Slot '+ no, slotX, slotY + 4)
                                    .attr({
                                        fill: 'silver'
                                    }).add());
                            }
                        });
                        // */

                        // if there are more values than available slots, remove lowest values
                        if (length > slotsLength) {
                            // create an array for sorting and ranking the points within each quarter
                            rankArr = [].concat(points);
                            rankArr.sort(sort);
                            j = length;
                            while (j--) {
                                rankArr[j].rank = j;
                            }
                            j = length;
                            while (j--) {
                                if (points[j].rank >= slotsLength) {
                                    points.splice(j, 1);
                                }
                            }
                            length = points.length;
                        }

                        // The label goes to the nearest open slot, but not closer to the edge than
                        // the label's index.
                        for (j = 0; j < length; j++) {

                            point = points[j];
                            labelPos = point.labelPos;

                            var closest = 9999,
                                distance,
                                slotI;

                            // find the closest slot index
                            for (slotI = 0; slotI < slotsLength; slotI++) {
                                distance = mathAbs(slots[slotI] - labelPos[1]);
                                if (distance < closest) {
                                    closest = distance;
                                    slotIndex = slotI;
                                }
                            }

                            // if that slot index is closer to the edges of the slots, move it
                            // to the closest appropriate slot
                            if (slotIndex < j && slots[j] !== null) { // cluster at the top
                                slotIndex = j;
                            } else if (slotsLength < length - j + slotIndex && slots[j] !== null) { // cluster at the bottom
                                slotIndex = slotsLength - length + j;
                                while (slots[slotIndex] === null) { // make sure it is not taken
                                    slotIndex++;
                                }
                            } else {
                                // Slot is taken, find next free slot below. In the next run, the next slice will find the
                                // slot above these, because it is the closest one
                                while (slots[slotIndex] === null) { // make sure it is not taken
                                    slotIndex++;
                                }
                            }

                            usedSlots.push({ i: slotIndex, y: slots[slotIndex] });
                            slots[slotIndex] = null; // mark as taken
                        }
                        // sort them in order to fill in from the top
                        usedSlots.sort(sort);
                    }

                    // now the used slots are sorted, fill them up sequentially
                    for (j = 0; j < length; j++) {

                        var slot, naturalY;

                        point = points[j];
                        labelPos = point.labelPos;
                        dataLabel = point.dataLabel;
                        visibility = point.visible === false ? HIDDEN : 'inherit';
                        naturalY = labelPos[1];

                        if (distanceOption > 0) {
                            slot = usedSlots.pop();
                            slotIndex = slot.i;

                            // if the slot next to currrent slot is free, the y value is allowed
                            // to fall back to the natural position
                            y = slot.y;
                            if ((naturalY > y && slots[slotIndex + 1] !== null) ||
                                    (naturalY < y && slots[slotIndex - 1] !== null)) {
                                y = mathMin(mathMax(0, naturalY), chart.plotHeight);
                            }

                        } else {
                            y = naturalY;
                        }

                        // get the x - use the natural x position for first and last slot, to prevent the top
                        // and botton slice connectors from touching each other on either side
                        x = options.justify ?
                            seriesCenter[0] + (i ? -1 : 1) * (radius + distanceOption) :
                            series.getX(y === centerY - radius - distanceOption || y === centerY + radius + distanceOption ? naturalY : y, i);


                        // Record the placement and visibility
                        dataLabel._attr = {
                            visibility: visibility,
                            align: labelPos[6]
                        };
                        dataLabel._pos = {
                            x: x + options.x +
                                ({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),
                            y: y + options.y - 10 // 10 is for the baseline (label vs text)
                        };
                        dataLabel.connX = x;
                        dataLabel.connY = y;


                        // Detect overflowing data labels
                        if (this.options.size === null) {
                            dataLabelWidth = dataLabel.width;
                            // Overflow left
                            if (x - dataLabelWidth < connectorPadding) {
                                overflow[3] = mathMax(mathRound(dataLabelWidth - x + connectorPadding), overflow[3]);

                                // Overflow right
                            } else if (x + dataLabelWidth > plotWidth - connectorPadding) {
                                overflow[1] = mathMax(mathRound(x + dataLabelWidth - plotWidth + connectorPadding), overflow[1]);
                            }

                            // Overflow top
                            if (y - labelHeight / 2 < 0) {
                                overflow[0] = mathMax(mathRound(-y + labelHeight / 2), overflow[0]);

                                // Overflow left
                            } else if (y + labelHeight / 2 > plotHeight) {
                                overflow[2] = mathMax(mathRound(y + labelHeight / 2 - plotHeight), overflow[2]);
                            }
                        }
                    } // for each point
                } // for each half

                // Do not apply the final placement and draw the connectors until we have verified
                // that labels are not spilling over.
                if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {

                    // Place the labels in the final position
                    this.placeDataLabels();

                    // Draw the connectors
                    if (outside && connectorWidth) {
                        each(this.points, function (point) {
                            connector = point.connector;
                            labelPos = point.labelPos;
                            dataLabel = point.dataLabel;

                            if (dataLabel && dataLabel._pos && point.visible) {
                                visibility = dataLabel._attr.visibility;
                                x = dataLabel.connX;
                                y = dataLabel.connY;
                                connectorPath = softConnector ? [
                                    M,
                                    x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
                                    'C',
                                    x, y, // first break, next to the label
                                    2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],
                                    labelPos[2], labelPos[3], // second break
                                    L,
                                    labelPos[4], labelPos[5] // base
                                ] : [
                                    M,
                                    x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
                                    L,
                                    labelPos[2], labelPos[3], // second break
                                    L,
                                    labelPos[4], labelPos[5] // base
                                ];

                                if (connector) {
                                    connector.animate({ d: connectorPath });
                                    connector.attr('visibility', visibility);

                                } else {
                                    point.connector = connector = series.chart.renderer.path(connectorPath).attr({
                                        'stroke-width': connectorWidth,
                                        stroke: options.connectorColor || point.color || '#606060',
                                        visibility: visibility
                                        //zIndex: 0 // #2722 (reversed)
                                    })
                                    .add(series.dataLabelsGroup);
                                }
                            } else if (connector) {
                                point.connector = connector.destroy();
                            }
                        });
                    }
                }
            };
            /**
             * Perform the final placement of the data labels after we have verified that they
             * fall within the plot area.
             */
            seriesTypes.pie.prototype.placeDataLabels = function () {
                each(this.points, function (point) {
                    var dataLabel = point.dataLabel,
                        _pos;

                    if (dataLabel && point.visible) {
                        _pos = dataLabel._pos;
                        if (_pos) {
                            dataLabel.attr(dataLabel._attr);
                            dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);
                            dataLabel.moved = true;
                        } else if (dataLabel) {
                            dataLabel.attr({ y: -999 });
                        }
                    }
                });
            };

            seriesTypes.pie.prototype.alignDataLabel = noop;

            /**
             * Verify whether the data labels are allowed to draw, or we should run more translation and data
             * label positioning to keep them inside the plot area. Returns true when data labels are ready
             * to draw.
             */
            seriesTypes.pie.prototype.verifyDataLabelOverflow = function (overflow) {

                var center = this.center,
                    options = this.options,
                    centerOption = options.center,
                    minSize = options.minSize || 80,
                    newSize = minSize,
                    ret;

                // Handle horizontal size and center
                if (centerOption[0] !== null) { // Fixed center
                    newSize = mathMax(center[2] - mathMax(overflow[1], overflow[3]), minSize);

                } else { // Auto center
                    newSize = mathMax(
                        center[2] - overflow[1] - overflow[3], // horizontal overflow
                        minSize
                    );
                    center[0] += (overflow[3] - overflow[1]) / 2; // horizontal center
                }

                // Handle vertical size and center
                if (centerOption[1] !== null) { // Fixed center
                    newSize = mathMax(mathMin(newSize, center[2] - mathMax(overflow[0], overflow[2])), minSize);

                } else { // Auto center
                    newSize = mathMax(
                        mathMin(
                            newSize,
                            center[2] - overflow[0] - overflow[2] // vertical overflow
                        ),
                        minSize
                    );
                    center[1] += (overflow[0] - overflow[2]) / 2; // vertical center
                }

                // If the size must be decreased, we need to run translate and drawDataLabels again
                if (newSize < center[2]) {
                    center[2] = newSize;
                    center[3] = relativeLength(options.innerSize || 0, newSize);
                    this.translate(center);
                    each(this.points, function (point) {
                        if (point.dataLabel) {
                            point.dataLabel._pos = null; // reset
                        }
                    });

                    if (this.drawDataLabels) {
                        this.drawDataLabels();
                    }
                    // Else, return true to indicate that the pie and its labels is within the plot area
                } else {
                    ret = true;
                }
                return ret;
            };
        }

        if (seriesTypes.column) {

            /**
             * Override the basic data label alignment by adjusting for the position of the column
             */
            seriesTypes.column.prototype.alignDataLabel = function (point, dataLabel, options, alignTo, isNew) {
                var inverted = this.chart.inverted,
                    series = point.series,
                    dlBox = point.dlBox || point.shapeArgs, // data label box for alignment
                    below = pick(point.below, point.plotY > pick(this.translatedThreshold, series.yAxis.len)), // point.below is used in range series
                    inside = pick(options.inside, !!this.options.stacking); // draw it inside the box?

                // Align to the column itself, or the top of it
                if (dlBox) { // Area range uses this method but not alignTo
                    alignTo = merge(dlBox);

                    if (inverted) {
                        alignTo = {
                            x: series.yAxis.len - alignTo.y - alignTo.height,
                            y: series.xAxis.len - alignTo.x - alignTo.width,
                            width: alignTo.height,
                            height: alignTo.width
                        };
                    }

                    // Compute the alignment box
                    if (!inside) {
                        if (inverted) {
                            alignTo.x += below ? 0 : alignTo.width;
                            alignTo.width = 0;
                        } else {
                            alignTo.y += below ? alignTo.height : 0;
                            alignTo.height = 0;
                        }
                    }
                }


                // When alignment is undefined (typically columns and bars), display the individual
                // point below or above the point depending on the threshold
                options.align = pick(
                    options.align,
                    !inverted || inside ? 'center' : below ? 'right' : 'left'
                );
                options.verticalAlign = pick(
                    options.verticalAlign,
                    inverted || inside ? 'middle' : below ? 'top' : 'bottom'
                );

                // Call the parent method
                Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
            };
        }



        /**
         * Highcharts JS v4.1.7 (2015-06-26)
         * Highcharts module to hide overlapping data labels. This module is included by default in Highmaps.
         *
         * (c) 2010-2014 Torstein Honsi
         *
         * License: www.highcharts.com/license
         */

        /*global Highcharts, HighchartsAdapter */
        (function (H) {
            var Chart = H.Chart,
                each = H.each,
                pick = H.pick,
                addEvent = HighchartsAdapter.addEvent;

            // Collect potensial overlapping data labels. Stack labels probably don't need to be 
            // considered because they are usually accompanied by data labels that lie inside the columns.
            Chart.prototype.callbacks.push(function (chart) {
                function collectAndHide() {
                    var labels = [];

                    each(chart.series, function (series) {
                        var dlOptions = series.options.dataLabels;
                        if ((dlOptions.enabled || series._hasPointLabels) && !dlOptions.allowOverlap && series.visible) { // #3866
                            each(series.points, function (point) {
                                if (point.dataLabel) {
                                    point.dataLabel.labelrank = pick(point.labelrank, point.shapeArgs && point.shapeArgs.height); // #4118
                                    labels.push(point.dataLabel);
                                }
                            });
                        }
                    });
                    chart.hideOverlappingLabels(labels);
                }

                // Do it now ...
                collectAndHide();

                // ... and after each chart redraw
                addEvent(chart, 'redraw', collectAndHide);

            });

            /**
             * Hide overlapping labels. Labels are moved and faded in and out on zoom to provide a smooth 
             * visual imression.
             */
            Chart.prototype.hideOverlappingLabels = function (labels) {

                var len = labels.length,
                    label,
                    i,
                    j,
                    label1,
                    label2,
                    intersectRect = function (pos1, pos2, size1, size2) {
                        return !(
                            pos2.x > pos1.x + size1.width ||
                            pos2.x + size2.width < pos1.x ||
                            pos2.y > pos1.y + size1.height ||
                            pos2.y + size2.height < pos1.y
                        );
                    };

                // Mark with initial opacity
                for (i = 0; i < len; i++) {
                    label = labels[i];
                    if (label) {
                        label.oldOpacity = label.opacity;
                        label.newOpacity = 1;
                    }
                }

                // Prevent a situation in a gradually rising slope, that each label
                // will hide the previous one because the previous one always has
                // lower rank.
                labels.sort(function (a, b) {
                    return b.labelrank - a.labelrank;
                });

                // Detect overlapping labels
                for (i = 0; i < len; i++) {
                    label1 = labels[i];

                    for (j = i + 1; j < len; ++j) {
                        label2 = labels[j];
                        if (label1 && label2 && label1.placed && label2.placed && label1.newOpacity !== 0 && label2.newOpacity !== 0 &&
                                intersectRect(label1.alignAttr, label2.alignAttr, label1, label2)) {
                            (label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;
                        }
                    }
                }

                // Hide or show
                for (i = 0; i < len; i++) {
                    label = labels[i];
                    if (label) {
                        if (label.oldOpacity !== label.newOpacity && label.placed) {
                            label.alignAttr.opacity = label.newOpacity;
                            label[label.isOld && label.newOpacity ? 'animate' : 'attr'](label.alignAttr);
                        }
                        label.isOld = true;
                    }
                }
            };

        }(Highcharts));/**
 * TrackerMixin for points and graphs
 */

        var TrackerMixin = Highcharts.TrackerMixin = {

            drawTrackerPoint: function () {
                var series = this,
                    chart = series.chart,
                    pointer = chart.pointer,
                    cursor = series.options.cursor,
                    css = cursor && { cursor: cursor },
                    onMouseOver = function (e) {
                        var target = e.target,
                        point;

                        while (target && !point) {
                            point = target.point;
                            target = target.parentNode;
                        }

                        if (point !== UNDEFINED && point !== chart.hoverPoint) { // undefined on graph in scatterchart
                            point.onMouseOver(e);
                        }
                    };

                // Add reference to the point
                each(series.points, function (point) {
                    if (point.graphic) {
                        point.graphic.element.point = point;
                    }
                    if (point.dataLabel) {
                        point.dataLabel.element.point = point;
                    }
                });

                // Add the event listeners, we need to do this only once
                if (!series._hasTracking) {
                    each(series.trackerGroups, function (key) {
                        if (series[key]) { // we don't always have dataLabelsGroup
                            series[key]
                                .addClass(PREFIX + 'tracker')
                                .on('mouseover', onMouseOver)
                                .on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })
                                .css(css);
                            if (hasTouch) {
                                series[key].on('touchstart', onMouseOver);
                            }
                        }
                    });
                    series._hasTracking = true;
                }
            },

            /**
             * Draw the tracker object that sits above all data labels and markers to
             * track mouse events on the graph or points. For the line type charts
             * the tracker uses the same graphPath, but with a greater stroke width
             * for better control.
             */
            drawTrackerGraph: function () {
                var series = this,
                    options = series.options,
                    trackByArea = options.trackByArea,
                    trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),
                    trackerPathLength = trackerPath.length,
                    chart = series.chart,
                    pointer = chart.pointer,
                    renderer = chart.renderer,
                    snap = chart.options.tooltip.snap,
                    tracker = series.tracker,
                    cursor = options.cursor,
                    css = cursor && { cursor: cursor },
                    singlePoints = series.singlePoints,
                    singlePoint,
                    i,
                    onMouseOver = function () {
                        if (chart.hoverSeries !== series) {
                            series.onMouseOver();
                        }
                    },
                    /*
                     * Empirical lowest possible opacities for TRACKER_FILL for an element to stay invisible but clickable
                     * IE6: 0.002
                     * IE7: 0.002
                     * IE8: 0.002
                     * IE9: 0.00000000001 (unlimited)
                     * IE10: 0.0001 (exporting only)
                     * FF: 0.00000000001 (unlimited)
                     * Chrome: 0.000001
                     * Safari: 0.000001
                     * Opera: 0.00000000001 (unlimited)
                     */
                    TRACKER_FILL = 'rgba(192,192,192,' + (hasSVG ? 0.0001 : 0.002) + ')';

                // Extend end points. A better way would be to use round linecaps,
                // but those are not clickable in VML.
                if (trackerPathLength && !trackByArea) {
                    i = trackerPathLength + 1;
                    while (i--) {
                        if (trackerPath[i] === M) { // extend left side
                            trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);
                        }
                        if ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side
                            trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);
                        }
                    }
                }

                // handle single points
                for (i = 0; i < singlePoints.length; i++) {
                    singlePoint = singlePoints[i];
                    trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,
                    L, singlePoint.plotX + snap, singlePoint.plotY);
                }

                // draw the tracker
                if (tracker) {
                    tracker.attr({ d: trackerPath });
                } else { // create

                    series.tracker = renderer.path(trackerPath)
                    .attr({
                        'stroke-linejoin': 'round', // #1225
                        visibility: series.visible ? VISIBLE : HIDDEN,
                        stroke: TRACKER_FILL,
                        fill: trackByArea ? TRACKER_FILL : NONE,
                        'stroke-width': options.lineWidth + (trackByArea ? 0 : 2 * snap),
                        zIndex: 2
                    })
                    .add(series.group);

                    // The tracker is added to the series group, which is clipped, but is covered
                    // by the marker group. So the marker group also needs to capture events.
                    each([series.tracker, series.markerGroup], function (tracker) {
                        tracker.addClass(PREFIX + 'tracker')
                            .on('mouseover', onMouseOver)
                            .on('mouseout', function (e) { pointer.onTrackerMouseOut(e); })
                            .css(css);

                        if (hasTouch) {
                            tracker.on('touchstart', onMouseOver);
                        }
                    });
                }
            }
        };
        /* End TrackerMixin */


        /**
         * Add tracking event listener to the series group, so the point graphics
         * themselves act as trackers
         */

        if (seriesTypes.column) {
            ColumnSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
        }

        if (seriesTypes.pie) {
            seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
        }

        if (seriesTypes.scatter) {
            ScatterSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
        }

        /* 
         * Extend Legend for item events 
         */
        extend(Legend.prototype, {

            setItemEvents: function (item, legendItem, useHTML, itemStyle, itemHiddenStyle) {
                var legend = this;
                // Set the events on the item group, or in case of useHTML, the item itself (#1249)
                (useHTML ? legendItem : item.legendGroup).on('mouseover', function () {
                    item.setState(HOVER_STATE);
                    legendItem.css(legend.options.itemHoverStyle);
                })
                    .on('mouseout', function () {
                        legendItem.css(item.visible ? itemStyle : itemHiddenStyle);
                        item.setState();
                    })
                    .on('click', function (event) {
                        var strLegendItemClick = 'legendItemClick',
                            fnLegendItemClick = function () {
                                item.setVisible();
                            };

                        // Pass over the click/touch event. #4.
                        event = {
                            browserEvent: event
                        };

                        // click the name or symbol
                        if (item.firePointEvent) { // point
                            item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
                        } else {
                            fireEvent(item, strLegendItemClick, event, fnLegendItemClick);
                        }
                    });
            },

            createCheckboxForItem: function (item) {
                var legend = this;

                item.checkbox = createElement('input', {
                    type: 'checkbox',
                    checked: item.selected,
                    defaultChecked: item.selected // required by IE7
                }, legend.options.itemCheckboxStyle, legend.chart.container);

                addEvent(item.checkbox, 'click', function (event) {
                    var target = event.target;
                    fireEvent(item.series || item, 'checkboxClick', { // #3712
                        checked: target.checked,
                        item: item
                    },
                        function () {
                            item.select();
                        }
                    );
                });
            }
        });

        /* 
         * Add pointer cursor to legend itemstyle in defaultOptions
         */
        defaultOptions.legend.itemStyle.cursor = 'pointer';


        /* 
         * Extend the Chart object with interaction
         */

        extend(Chart.prototype, {
            /**
             * Display the zoom button
             */
            showResetZoom: function () {
                var chart = this,
                    lang = defaultOptions.lang,
                    btnOptions = chart.options.chart.resetZoomButton,
                    theme = btnOptions.theme,
                    states = theme.states,
                    alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';

                this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, function () { chart.zoomOut(); }, theme, states && states.hover)
                    .attr({
                        align: btnOptions.position.align,
                        title: lang.resetZoomTitle
                    })
                    .add()
                    .align(btnOptions.position, false, alignTo);

            },

            /**
             * Zoom out to 1:1
             */
            zoomOut: function () {
                var chart = this;
                fireEvent(chart, 'selection', { resetSelection: true }, function () {
                    chart.zoom();
                });
            },

            /**
             * Zoom into a given portion of the chart given by axis coordinates
             * @param {Object} event
             */
            zoom: function (event) {
                var chart = this,
                    hasZoomed,
                    pointer = chart.pointer,
                    displayButton = false,
                    resetZoomButton;

                // If zoom is called with no arguments, reset the axes
                if (!event || event.resetSelection) {
                    each(chart.axes, function (axis) {
                        hasZoomed = axis.zoom();
                    });
                } else { // else, zoom in on all axes
                    each(event.xAxis.concat(event.yAxis), function (axisData) {
                        var axis = axisData.axis,
                            isXAxis = axis.isXAxis;

                        // don't zoom more than minRange
                        if (pointer[isXAxis ? 'zoomX' : 'zoomY'] || pointer[isXAxis ? 'pinchX' : 'pinchY']) {
                            hasZoomed = axis.zoom(axisData.min, axisData.max);
                            if (axis.displayBtn) {
                                displayButton = true;
                            }
                        }
                    });
                }

                // Show or hide the Reset zoom button
                resetZoomButton = chart.resetZoomButton;
                if (displayButton && !resetZoomButton) {
                    chart.showResetZoom();
                } else if (!displayButton && isObject(resetZoomButton)) {
                    chart.resetZoomButton = resetZoomButton.destroy();
                }


                // Redraw
                if (hasZoomed) {
                    chart.redraw(
                        pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100) // animation
                    );
                }
            },

            /**
             * Pan the chart by dragging the mouse across the pane. This function is called
             * on mouse move, and the distance to pan is computed from chartX compared to
             * the first chartX position in the dragging operation.
             */
            pan: function (e, panning) {

                var chart = this,
                    hoverPoints = chart.hoverPoints,
                    doRedraw;

                // remove active points for shared tooltip
                if (hoverPoints) {
                    each(hoverPoints, function (point) {
                        point.setState();
                    });
                }

                each(panning === 'xy' ? [1, 0] : [1], function (isX) { // xy is used in maps
                    var mousePos = e[isX ? 'chartX' : 'chartY'],
                        axis = chart[isX ? 'xAxis' : 'yAxis'][0],
                        startPos = chart[isX ? 'mouseDownX' : 'mouseDownY'],
                        halfPointRange = (axis.pointRange || 0) / 2,
                        extremes = axis.getExtremes(),
                        newMin = axis.toValue(startPos - mousePos, true) + halfPointRange,
                        newMax = axis.toValue(startPos + chart[isX ? 'plotWidth' : 'plotHeight'] - mousePos, true) - halfPointRange,
                        goingLeft = startPos > mousePos; // #3613

                    if (axis.series.length &&
                            (goingLeft || newMin > mathMin(extremes.dataMin, extremes.min)) &&
                            (!goingLeft || newMax < mathMax(extremes.dataMax, extremes.max))) {
                        axis.setExtremes(newMin, newMax, false, false, { trigger: 'pan' });
                        doRedraw = true;
                    }

                    chart[isX ? 'mouseDownX' : 'mouseDownY'] = mousePos; // set new reference for next run
                });

                if (doRedraw) {
                    chart.redraw(false);
                }
                css(chart.container, { cursor: 'move' });
            }
        });

        /*
         * Extend the Point object with interaction
         */
        extend(Point.prototype, {
            /**
             * Toggle the selection status of a point
             * @param {Boolean} selected Whether to select or unselect the point.
             * @param {Boolean} accumulate Whether to add to the previous selection. By default,
             *		 this happens if the control key (Cmd on Mac) was pressed during clicking.
             */
            select: function (selected, accumulate) {
                var point = this,
                    series = point.series,
                    chart = series.chart;

                selected = pick(selected, !point.selected);

                // fire the event with the defalut handler
                point.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {
                    point.selected = point.options.selected = selected;
                    series.options.data[inArray(point, series.data)] = point.options;

                    point.setState(selected && SELECT_STATE);

                    // unselect all other points unless Ctrl or Cmd + click
                    if (!accumulate) {
                        each(chart.getSelectedPoints(), function (loopPoint) {
                            if (loopPoint.selected && loopPoint !== point) {
                                loopPoint.selected = loopPoint.options.selected = false;
                                series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;
                                loopPoint.setState(NORMAL_STATE);
                                loopPoint.firePointEvent('unselect');
                            }
                        });
                    }
                });
            },

            /**
             * Runs on mouse over the point
             */
            onMouseOver: function (e) {
                var point = this,
                    series = point.series,
                    chart = series.chart,
                    tooltip = chart.tooltip,
                    hoverPoint = chart.hoverPoint;

                if (chart.hoverSeries !== series) {
                    series.onMouseOver();
                }

                // set normal state to previous series
                if (hoverPoint && hoverPoint !== point) {
                    hoverPoint.onMouseOut();
                }

                if (point.series) { // It may have been destroyed, #4130

                    // trigger the event
                    point.firePointEvent('mouseOver');

                    // update the tooltip
                    if (tooltip && (!tooltip.shared || series.noSharedTooltip)) {
                        tooltip.refresh(point, e);
                    }

                    // hover this
                    point.setState(HOVER_STATE);
                    chart.hoverPoint = point;
                }
            },

            /**
             * Runs on mouse out from the point
             */
            onMouseOut: function () {
                var chart = this.series.chart,
                    hoverPoints = chart.hoverPoints;

                this.firePointEvent('mouseOut');

                if (!hoverPoints || inArray(this, hoverPoints) === -1) { // #887, #2240
                    this.setState();
                    chart.hoverPoint = null;
                }
            },

            /**
             * Import events from the series' and point's options. Only do it on
             * demand, to save processing time on hovering.
             */
            importEvents: function () {
                if (!this.hasImportedEvents) {
                    var point = this,
                        options = merge(point.series.options.point, point.options),
                        events = options.events,
                        eventType;

                    point.events = events;

                    for (eventType in events) {
                        addEvent(point, eventType, events[eventType]);
                    }
                    this.hasImportedEvents = true;

                }
            },

            /**
             * Set the point's state
             * @param {String} state
             */
            setState: function (state, move) {
                var point = this,
                    plotX = point.plotX,
                    plotY = point.plotY,
                    series = point.series,
                    stateOptions = series.options.states,
                    markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,
                    normalDisabled = markerOptions && !markerOptions.enabled,
                    markerStateOptions = markerOptions && markerOptions.states[state],
                    stateDisabled = markerStateOptions && markerStateOptions.enabled === false,
                    stateMarkerGraphic = series.stateMarkerGraphic,
                    pointMarker = point.marker || {},
                    chart = series.chart,
                    radius,
                    halo = series.halo,
                    haloOptions,
                    newSymbol,
                    pointAttr;

                state = state || NORMAL_STATE; // empty string
                pointAttr = point.pointAttr[state] || series.pointAttr[state];

                if (
                    // already has this state
                        (state === point.state && !move) ||
                    // selected points don't respond to hover
                        (point.selected && state !== SELECT_STATE) ||
                    // series' state options is disabled
                        (stateOptions[state] && stateOptions[state].enabled === false) ||
                    // general point marker's state options is disabled
                        (state && (stateDisabled || (normalDisabled && markerStateOptions.enabled === false))) ||
                    // individual point marker's state options is disabled
                        (state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false) // #1610

                    ) {
                    return;
                }

                // apply hover styles to the existing point
                if (point.graphic) {
                    radius = markerOptions && point.graphic.symbolName && pointAttr.r;
                    point.graphic.attr(merge(
                        pointAttr,
                        radius ? { // new symbol attributes (#507, #612)
                            x: plotX - radius,
                            y: plotY - radius,
                            width: 2 * radius,
                            height: 2 * radius
                        } : {}
                    ));

                    // Zooming in from a range with no markers to a range with markers
                    if (stateMarkerGraphic) {
                        stateMarkerGraphic.hide();
                    }
                } else {
                    // if a graphic is not applied to each point in the normal state, create a shared
                    // graphic for the hover state
                    if (state && markerStateOptions) {
                        radius = markerStateOptions.radius;
                        newSymbol = pointMarker.symbol || series.symbol;

                        // If the point has another symbol than the previous one, throw away the
                        // state marker graphic and force a new one (#1459)
                        if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
                            stateMarkerGraphic = stateMarkerGraphic.destroy();
                        }

                        // Add a new state marker graphic
                        if (!stateMarkerGraphic) {
                            if (newSymbol) {
                                series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(
                                    newSymbol,
                                    plotX - radius,
                                    plotY - radius,
                                    2 * radius,
                                    2 * radius
                                )
                                .attr(pointAttr)
                                .add(series.markerGroup);
                                stateMarkerGraphic.currentSymbol = newSymbol;
                            }

                            // Move the existing graphic
                        } else {
                            stateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054
                                x: plotX - radius,
                                y: plotY - radius
                            });
                        }
                    }

                    if (stateMarkerGraphic) {
                        stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450
                        stateMarkerGraphic.element.point = point; // #4310
                    }
                }

                // Show me your halo
                haloOptions = stateOptions[state] && stateOptions[state].halo;
                if (haloOptions && haloOptions.size) {
                    if (!halo) {
                        series.halo = halo = chart.renderer.path()
                            .add(chart.seriesGroup);
                    }
                    halo.attr(extend({
                        fill: Color(point.color || series.color).setOpacity(haloOptions.opacity).get()
                    }, haloOptions.attributes))[move ? 'animate' : 'attr']({
                        d: point.haloPath(haloOptions.size)
                    });
                } else if (halo) {
                    halo.attr({ d: [] });
                }

                point.state = state;
            },

            haloPath: function (size) {
                var series = this.series,
                    chart = series.chart,
                    plotBox = series.getPlotBox(),
                    inverted = chart.inverted;

                return chart.renderer.symbols.circle(
                    plotBox.translateX + (inverted ? series.yAxis.len - this.plotY : this.plotX) - size,
                    plotBox.translateY + (inverted ? series.xAxis.len - this.plotX : this.plotY) - size,
                    size * 2,
                    size * 2
                );
            }
        });

        /*
         * Extend the Series object with interaction
         */

        extend(Series.prototype, {
            /**
             * Series mouse over handler
             */
            onMouseOver: function () {
                var series = this,
                    chart = series.chart,
                    hoverSeries = chart.hoverSeries;

                // set normal state to previous series
                if (hoverSeries && hoverSeries !== series) {
                    hoverSeries.onMouseOut();
                }

                // trigger the event, but to save processing time,
                // only if defined
                if (series.options.events.mouseOver) {
                    fireEvent(series, 'mouseOver');
                }

                // hover this
                series.setState(HOVER_STATE);
                chart.hoverSeries = series;
            },

            /**
             * Series mouse out handler
             */
            onMouseOut: function () {
                // trigger the event only if listeners exist
                var series = this,
                    options = series.options,
                    chart = series.chart,
                    tooltip = chart.tooltip,
                    hoverPoint = chart.hoverPoint;

                chart.hoverSeries = null; // #182, set to null before the mouseOut event fires

                // trigger mouse out on the point, which must be in this series
                if (hoverPoint) {
                    hoverPoint.onMouseOut();
                }

                // fire the mouse out event
                if (series && options.events.mouseOut) {
                    fireEvent(series, 'mouseOut');
                }


                // hide the tooltip
                if (tooltip && !options.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
                    tooltip.hide();
                }

                // set normal state
                series.setState();
            },

            /**
             * Set the state of the graph
             */
            setState: function (state) {
                var series = this,
                    options = series.options,
                    graph = series.graph,
                    stateOptions = options.states,
                    lineWidth = options.lineWidth,
                    attribs,
                    i = 0;

                state = state || NORMAL_STATE;

                if (series.state !== state) {
                    series.state = state;

                    if (stateOptions[state] && stateOptions[state].enabled === false) {
                        return;
                    }

                    if (state) {
                        lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0); // #4035
                    }

                    if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML
                        attribs = {
                            'stroke-width': lineWidth
                        };
                        // use attr because animate will cause any other animation on the graph to stop
                        graph.attr(attribs);
                        while (series['zoneGraph' + i]) {
                            series['zoneGraph' + i].attr(attribs);
                            i = i + 1;
                        }
                    }
                }
            },

            /**
             * Set the visibility of the graph
             *
             * @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,
             *				the visibility is toggled.
             */
            setVisible: function (vis, redraw) {
                var series = this,
                    chart = series.chart,
                    legendItem = series.legendItem,
                    showOrHide,
                    ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
                    oldVisibility = series.visible;

                // if called without an argument, toggle visibility
                series.visible = vis = series.userOptions.visible = vis === UNDEFINED ? !oldVisibility : vis;
                showOrHide = vis ? 'show' : 'hide';

                // show or hide elements
                each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker'], function (key) {
                    if (series[key]) {
                        series[key][showOrHide]();
                    }
                });


                // hide tooltip (#1361)
                if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {
                    series.onMouseOut();
                }


                if (legendItem) {
                    chart.legend.colorizeItem(series, vis);
                }


                // rescale or adapt to resized chart
                series.isDirty = true;
                // in a stack, all other series are affected
                if (series.options.stacking) {
                    each(chart.series, function (otherSeries) {
                        if (otherSeries.options.stacking && otherSeries.visible) {
                            otherSeries.isDirty = true;
                        }
                    });
                }

                // show or hide linked series
                each(series.linkedSeries, function (otherSeries) {
                    otherSeries.setVisible(vis, false);
                });

                if (ignoreHiddenSeries) {
                    chart.isDirtyBox = true;
                }
                if (redraw !== false) {
                    chart.redraw();
                }

                fireEvent(series, showOrHide);
            },

            /**
             * Show the graph
             */
            show: function () {
                this.setVisible(true);
            },

            /**
             * Hide the graph
             */
            hide: function () {
                this.setVisible(false);
            },


            /**
             * Set the selected state of the graph
             *
             * @param selected {Boolean} True to select the series, false to unselect. If
             *				UNDEFINED, the selection state is toggled.
             */
            select: function (selected) {
                var series = this;
                // if called without an argument, toggle
                series.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;

                if (series.checkbox) {
                    series.checkbox.checked = selected;
                }

                fireEvent(series, selected ? 'select' : 'unselect');
            },

            drawTracker: TrackerMixin.drawTrackerGraph
        });
        // global variables
        extend(Highcharts, {

            // Constructors
            Color: Color,
            Point: Point,
            Tick: Tick,
            Renderer: Renderer,
            SVGElement: SVGElement,
            SVGRenderer: SVGRenderer,

            // Various
            arrayMin: arrayMin,
            arrayMax: arrayMax,
            charts: charts,
            dateFormat: dateFormat,
            error: error,
            format: format,
            pathAnim: pathAnim,
            getOptions: getOptions,
            hasBidiBug: hasBidiBug,
            isTouchDevice: isTouchDevice,
            setOptions: setOptions,
            addEvent: addEvent,
            removeEvent: removeEvent,
            createElement: createElement,
            discardElement: discardElement,
            css: css,
            each: each,
            map: map,
            merge: merge,
            splat: splat,
            extendClass: extendClass,
            pInt: pInt,
            svg: hasSVG,
            canvas: useCanVG,
            vml: !hasSVG && !useCanVG,
            product: PRODUCT,
            version: VERSION
        });

    }());
    module.exports=Highcharts;
});

/*!
 * jQuery JavaScript Library v1.10.2
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2013-07-03T13:48Z
 */
 define('jquery-1.10.2', function(require) {
(function( window, undefined ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//"use strict";
var
	// The deferred used on DOM ready
	readyList,

	// A central reference to the root jQuery(document)
	rootjQuery,

	// Support: IE<10
	// For `typeof xmlNode.method` instead of `xmlNode.method !== undefined`
	core_strundefined = typeof undefined,

	// Use the correct document accordingly with window argument (sandbox)
	location = window.location,
	document = window.document,
	docElem = document.documentElement,

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// [[Class]] -> type pairs
	class2type = {},

	// List of deleted data cache ids, so we can reuse them
	core_deletedIds = [],

	core_version = "1.10.2",

	// Save a reference to some core methods
	core_concat = core_deletedIds.concat,
	core_push = core_deletedIds.push,
	core_slice = core_deletedIds.slice,
	core_indexOf = core_deletedIds.indexOf,
	core_toString = class2type.toString,
	core_hasOwn = class2type.hasOwnProperty,
	core_trim = core_version.trim,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Used for matching numbers
	core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,

	// Used for splitting on whitespace
	core_rnotwhite = /\S+/g,

	// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	},

	// The ready event handler
	completed = function( event ) {

		// readyState === "complete" is good enough for us to call the dom ready in oldIE
		if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {
			detach();
			jQuery.ready();
		}
	},
	// Clean-up method for dom ready events
	detach = function() {
		if ( document.addEventListener ) {
			document.removeEventListener( "DOMContentLoaded", completed, false );
			window.removeEventListener( "load", completed, false );

		} else {
			document.detachEvent( "onreadystatechange", completed );
			window.detachEvent( "onload", completed );
		}
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: core_version,

	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// scripts is true for back-compat
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return core_slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Add the callback
		jQuery.ready.promise().done( fn );

		return this;
	},

	slice: function() {
		return this.pushStack( core_slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: core_push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var src, copyIsArray, copy, name, options, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( core_version + Math.random() ).replace( /\D/g, "" ),

	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( !document.body ) {
			return setTimeout( jQuery.ready );
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.trigger ) {
			jQuery( document ).trigger("ready").off("ready");
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		/* jshint eqeqeq: false */
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		if ( obj == null ) {
			return String( obj );
		}
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ core_toString.call(obj) ] || "object" :
			typeof obj;
	},

	isPlainObject: function( obj ) {
		var key;

		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!core_hasOwn.call(obj, "constructor") &&
				!core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Support: IE<9
		// Handle iteration over inherited properties before own properties.
		if ( jQuery.support.ownLast ) {
			for ( key in obj ) {
				return core_hasOwn.call( obj, key );
			}
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		for ( key in obj ) {}

		return key === undefined || core_hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	// data: string of html
	// context (optional): If specified, the fragment will be created in this context, defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	parseHTML: function( data, context, keepScripts ) {
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
		context = context || document;

		var parsed = rsingleTag.exec( data ),
			scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[1] ) ];
		}

		parsed = jQuery.buildFragment( [ data ], context, scripts );
		if ( scripts ) {
			jQuery( scripts ).remove();
		}
		return jQuery.merge( [], parsed.childNodes );
	},

	parseJSON: function( data ) {
		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		if ( data === null ) {
			return data;
		}

		if ( typeof data === "string" ) {

			// Make sure leading/trailing whitespace is removed (IE can't handle it)
			data = jQuery.trim( data );

			if ( data ) {
				// Make sure the incoming data is actual JSON
				// Logic borrowed from http://json.org/json2.js
				if ( rvalidchars.test( data.replace( rvalidescape, "@" )
					.replace( rvalidtokens, "]" )
					.replace( rvalidbraces, "")) ) {

					return ( new Function( "return " + data ) )();
				}
			}
		}

		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		var xml, tmp;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && jQuery.trim( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Use native String.trim function wherever possible
	trim: core_trim && !core_trim.call("\uFEFF\xA0") ?
		function( text ) {
			return text == null ?
				"" :
				core_trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				core_push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		var len;

		if ( arr ) {
			if ( core_indexOf ) {
				return core_indexOf.call( arr, elem, i );
			}

			len = arr.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in arr && arr[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var l = second.length,
			i = first.length,
			j = 0;

		if ( typeof l === "number" ) {
			for ( ; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}
		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var retVal,
			ret = [],
			i = 0,
			length = elems.length;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return core_concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var args, proxy, tmp;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = core_slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			length = elems.length,
			bulk = key == null;

		// Sets many values
		if ( jQuery.type( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !jQuery.isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < length; i++ ) {
					fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
				}
			}
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				length ? fn( elems[0], key ) : emptyGet;
	},

	now: function() {
		return ( new Date() ).getTime();
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations.
	// Note: this method belongs to the css module but it's needed here for the support module.
	// If support gets modularized, this method should be moved back to the css module.
	swap: function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	}
});

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		// Standards-based browsers support DOMContentLoaded
		} else if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );

		// If IE event model is used
		} else {
			// Ensure firing before onload, maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", completed );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", completed );

			// If IE and not a frame
			// continually check to see if the document is ready
			var top = false;

			try {
				top = window.frameElement == null && document.documentElement;
			} catch(e) {}

			if ( top && top.doScroll ) {
				(function doScrollCheck() {
					if ( !jQuery.isReady ) {

						try {
							// Use the trick by Diego Perini
							// http://javascript.nwbox.com/IEContentLoaded/
							top.doScroll("left");
						} catch(e) {
							return setTimeout( doScrollCheck, 50 );
						}

						// detach all dom ready events
						detach();

						// and execute any waiting functions
						jQuery.ready();
					}
				})();
			}
		}
	}
	return readyList.promise( obj );
};

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || type !== "function" &&
		( length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj );
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);
/*!
 * Sizzle CSS Selector Engine v1.10.2
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2013-07-03
 */
(function( window, undefined ) {

var i,
	support,
	cachedruns,
	Expr,
	getText,
	isXML,
	compile,
	outermostContext,
	sortInput,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + -(new Date()),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	hasDuplicate = false,
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}
		return 0;
	},

	// General-purpose constants
	strundefined = typeof undefined,
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf if we can't use a native one
	indexOf = arr.indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i < len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
		"*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

	// Prefer arguments quoted,
	//   then not containing pseudos/brackets,
	//   then attribute selectors/non-parenthetical expressions,
	//   then anything else
	// These preferences are here to reduce the number of selectors
	//   needing tokenize in the PSEUDO preFilter
	pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace( 3, 8 ) + ")*)|.*)\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rsibling = new RegExp( whitespace + "*[+~]" ),
	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			// BMP codepoint
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
		return [];
	}

	if ( documentIsHTML && !seed ) {

		// Shortcuts
		if ( (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType === 9 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && context.parentNode || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key += " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Detect xml
 * @param {Element|Object} elem An element or a document
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var doc = node ? node.ownerDocument || node : preferredDoc,
		parent = doc.defaultView;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;

	// Support tests
	documentIsHTML = !isXML( doc );

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent.attachEvent && parent !== parent.top ) {
		parent.attachEvent( "onbeforeunload", function() {
			setDocument();
		});
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Check if getElementsByClassName can be trusted
	support.getElementsByClassName = assert(function( div ) {
		div.innerHTML = "<div class='a'></div><div class='a i'></div>";

		// Support: Safari<4
		// Catch class over-caching
		div.firstChild.className = "i";
		// Support: Opera<10
		// Catch gEBCN failure to find non-leading classes
		return div.getElementsByClassName("i").length === 2;
	});

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== strundefined ) {
				return context.getElementsByTagName( tag );
			}
		} :
		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			div.innerHTML = "<select><option selected=''></option></select>";

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}
		});

		assert(function( div ) {

			// Support: Opera 10-12/IE8
			// ^= $= *= and empty values
			// Should not select anything
			// Support: Windows 8 Native Apps
			// The type attribute is restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "t", "" );

			if ( div.querySelectorAll("[t^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = rnative.test( docElem.contains ) || docElem.compareDocumentPosition ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = docElem.compareDocumentPosition ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition( b );

		if ( compare ) {
			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === doc || contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === doc || contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		}

		// Not directly comparable, sort on existence of method
		return a.compareDocumentPosition ? -1 : 1;
	} :
	function( a, b ) {
		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Parentless nodes are either documents or disconnected
		} else if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch(e) {}
	}

	return Sizzle( expr, document, null, [elem] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val === undefined ?
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null :
		val;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		for ( ; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (see #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[5] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] && match[4] !== undefined ) {
				match[2] = match[4];

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
			//   not comment, processing instructions, or others
			// Thanks to Diego Perini for the nodeName shortcut
			//   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeName > "@" || elem.nodeType === 3 || elem.nodeType === 4 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === elem.type );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( tokens = [] );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var data, cache, outerCache,
				dirkey = dirruns + " " + doneName;

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (cache = outerCache[ dir ]) && cache[0] === dirkey ) {
							if ( (data = cache[1]) === true || data === cachedruns ) {
								return data === true;
							}
						} else {
							cache = outerCache[ dir ] = [ dirkey ];
							cache[1] = matcher( elem, context, xml ) || cachedruns;
							if ( cache[1] === true ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	// A counter to specify which element is currently being matched
	var matcherCachedRuns = 0,
		bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, expandContext ) {
			var elem, j, matcher,
				setMatched = [],
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				outermost = expandContext != null,
				contextBackup = outermostContext,
				// We must always have either seed elements or context
				elems = seed || byElement && Expr.find["TAG"]( "*", expandContext && context.parentNode || context ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);

			if ( outermost ) {
				outermostContext = context !== document && context;
				cachedruns = matcherCachedRuns;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			for ( ; (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
						cachedruns = ++matcherCachedRuns;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !group ) {
			group = tokenize( selector );
		}
		i = group.length;
		while ( i-- ) {
			cached = matcherFromTokens( group[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	}
	return cached;
};

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function select( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		match = tokenize( selector );

	if ( !seed ) {
		// Try to minimize operations if there is only one group
		if ( match.length === 1 ) {

			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					support.getById && context.nodeType === 9 && documentIsHTML &&
					Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;
				}
				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && context.parentNode || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}
	}

	// Compile and execute a filtering function
	// Provide `match` to avoid retokenization if we modified the selector above
	compile( selector, match )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector )
	);
	return results;
}

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome<14
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return (val = elem.getAttributeNode( name )) && val.specified ?
				val.value :
				elem[ name ] === true ? name.toLowerCase() : null;
		}
	});
}

jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})( window );
// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( core_rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};
jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var action = tuple[ 0 ],
								fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ action + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = core_slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;
					if( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});
jQuery.support = (function( support ) {

	var all, a, input, select, fragment, opt, eventName, isSupported, i,
		div = document.createElement("div");

	// Setup
	div.setAttribute( "className", "t" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

	// Finish early in limited (non-browser) environments
	all = div.getElementsByTagName("*") || [];
	a = div.getElementsByTagName("a")[ 0 ];
	if ( !a || !a.style || !all.length ) {
		return support;
	}

	// First batch of tests
	select = document.createElement("select");
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName("input")[ 0 ];

	a.style.cssText = "top:1px;float:left;opacity:.5";

	// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
	support.getSetAttribute = div.className !== "t";

	// IE strips leading whitespace when .innerHTML is used
	support.leadingWhitespace = div.firstChild.nodeType === 3;

	// Make sure that tbody elements aren't automatically inserted
	// IE will insert them into empty tables
	support.tbody = !div.getElementsByTagName("tbody").length;

	// Make sure that link elements get serialized correctly by innerHTML
	// This requires a wrapper element in IE
	support.htmlSerialize = !!div.getElementsByTagName("link").length;

	// Get the style information from getAttribute
	// (IE uses .cssText instead)
	support.style = /top/.test( a.getAttribute("style") );

	// Make sure that URLs aren't manipulated
	// (IE normalizes it by default)
	support.hrefNormalized = a.getAttribute("href") === "/a";

	// Make sure that element opacity exists
	// (IE uses filter instead)
	// Use a regex to work around a WebKit issue. See #5145
	support.opacity = /^0.5/.test( a.style.opacity );

	// Verify style float existence
	// (IE uses styleFloat instead of cssFloat)
	support.cssFloat = !!a.style.cssFloat;

	// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
	support.checkOn = !!input.value;

	// Make sure that a selected-by-default option has a working selected property.
	// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
	support.optSelected = opt.selected;

	// Tests for enctype support on a form (#6743)
	support.enctype = !!document.createElement("form").enctype;

	// Makes sure cloning an html5 element does not cause problems
	// Where outerHTML is undefined, this still works
	support.html5Clone = document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>";

	// Will be defined later
	support.inlineBlockNeedsLayout = false;
	support.shrinkWrapBlocks = false;
	support.pixelPosition = false;
	support.deleteExpando = true;
	support.noCloneEvent = true;
	support.reliableMarginRight = true;
	support.boxSizingReliable = true;

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<9
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	// Check if we can trust getAttribute("value")
	input = document.createElement("input");
	input.setAttribute( "value", "" );
	support.input = input.getAttribute( "value" ) === "";

	// Check if an input maintains its value after becoming a radio
	input.value = "t";
	input.setAttribute( "type", "radio" );
	support.radioValue = input.value === "t";

	// #11217 - WebKit loses check when the name is after the checked attribute
	input.setAttribute( "checked", "t" );
	input.setAttribute( "name", "t" );

	fragment = document.createDocumentFragment();
	fragment.appendChild( input );

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<9
	// Opera does not clone events (and typeof div.attachEvent === undefined).
	// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
	if ( div.attachEvent ) {
		div.attachEvent( "onclick", function() {
			support.noCloneEvent = false;
		});

		div.cloneNode( true ).click();
	}

	// Support: IE<9 (lack submit/change bubble), Firefox 17+ (lack focusin event)
	// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
	for ( i in { submit: true, change: true, focusin: true }) {
		div.setAttribute( eventName = "on" + i, "t" );

		support[ i + "Bubbles" ] = eventName in window || div.attributes[ eventName ].expando === false;
	}

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	// Support: IE<9
	// Iteration over object's inherited properties before its own.
	for ( i in jQuery( support ) ) {
		break;
	}
	support.ownLast = i !== "0";

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, marginDiv, tds,
			divReset = "padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			// Return for frameset docs that don't have a body
			return;
		}

		container = document.createElement("div");
		container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px";

		body.appendChild( container ).appendChild( div );

		// Support: IE8
		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName("td");
		tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		// Support: IE8
		// Check if empty table cells still have offsetWidth/Height
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		// Check box-sizing and margin behavior.
		div.innerHTML = "";
		div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";

		// Workaround failing boxSizing test due to offsetWidth returning wrong value
		// with some non-1 values of body zoom, ticket #13543
		jQuery.swap( body, body.style.zoom != null ? { zoom: 1 } : {}, function() {
			support.boxSizing = div.offsetWidth === 4;
		});

		// Use window.getComputedStyle because jsdom on node.js will break without it.
		if ( window.getComputedStyle ) {
			support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
			support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

			// Check if div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container. (#3333)
			// Fails in WebKit before Feb 2011 nightlies
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			marginDiv = div.appendChild( document.createElement("div") );
			marginDiv.style.cssText = div.style.cssText = divReset;
			marginDiv.style.marginRight = marginDiv.style.width = "0";
			div.style.width = "1px";

			support.reliableMarginRight =
				!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );
		}

		if ( typeof div.style.zoom !== core_strundefined ) {
			// Support: IE<8
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			div.innerHTML = "";
			div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

			// Support: IE6
			// Check if elements with layout shrink-wrap their children
			div.style.display = "block";
			div.innerHTML = "<div></div>";
			div.firstChild.style.width = "5px";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );

			if ( support.inlineBlockNeedsLayout ) {
				// Prevent IE 6 from affecting layout for positioned elements #11048
				// Prevent IE from shrinking the body in IE 7 mode #12869
				// Support: IE<8
				body.style.zoom = 1;
			}
		}

		body.removeChild( container );

		// Null elements to avoid leaks in IE
		container = div = tds = marginDiv = null;
	});

	// Null elements to avoid leaks in IE
	all = select = fragment = opt = a = input = null;

	return support;
})({});

var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
	rmultiDash = /([A-Z])/g;

function internalData( elem, name, data, pvt /* Internal Use Only */ ){
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var ret, thisCache,
		internalKey = jQuery.expando,

		// We have to handle DOM nodes and JS objects differently because IE6-7
		// can't GC object references properly across the DOM-JS boundary
		isNode = elem.nodeType,

		// Only DOM nodes need the global jQuery cache; JS object data is
		// attached directly to the object so GC can occur automatically
		cache = isNode ? jQuery.cache : elem,

		// Only defining an ID for JS objects if its cache already exists allows
		// the code to shortcut on the same path as a DOM node with no cache
		id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

	// Avoid doing any more work than we need to when trying to get data on an
	// object that has no data at all
	if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === "string" ) {
		return;
	}

	if ( !id ) {
		// Only DOM nodes need a new unique ID for each element since their data
		// ends up in the global cache
		if ( isNode ) {
			id = elem[ internalKey ] = core_deletedIds.pop() || jQuery.guid++;
		} else {
			id = internalKey;
		}
	}

	if ( !cache[ id ] ) {
		// Avoid exposing jQuery metadata on plain JS objects when the object
		// is serialized using JSON.stringify
		cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
	}

	// An object can be passed to jQuery.data instead of a key/value pair; this gets
	// shallow copied over onto the existing cache
	if ( typeof name === "object" || typeof name === "function" ) {
		if ( pvt ) {
			cache[ id ] = jQuery.extend( cache[ id ], name );
		} else {
			cache[ id ].data = jQuery.extend( cache[ id ].data, name );
		}
	}

	thisCache = cache[ id ];

	// jQuery data() is stored in a separate object inside the object's internal data
	// cache in order to avoid key collisions between internal data and user-defined
	// data.
	if ( !pvt ) {
		if ( !thisCache.data ) {
			thisCache.data = {};
		}

		thisCache = thisCache.data;
	}

	if ( data !== undefined ) {
		thisCache[ jQuery.camelCase( name ) ] = data;
	}

	// Check for both converted-to-camel and non-converted data property names
	// If a data property was specified
	if ( typeof name === "string" ) {

		// First Try to find as-is property data
		ret = thisCache[ name ];

		// Test for null|undefined property data
		if ( ret == null ) {

			// Try to find the camelCased property
			ret = thisCache[ jQuery.camelCase( name ) ];
		}
	} else {
		ret = thisCache;
	}

	return ret;
}

function internalRemoveData( elem, name, pvt ) {
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var thisCache, i,
		isNode = elem.nodeType,

		// See jQuery.data for more information
		cache = isNode ? jQuery.cache : elem,
		id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

	// If there is already no cache entry for this object, there is no
	// purpose in continuing
	if ( !cache[ id ] ) {
		return;
	}

	if ( name ) {

		thisCache = pvt ? cache[ id ] : cache[ id ].data;

		if ( thisCache ) {

			// Support array or space separated string names for data keys
			if ( !jQuery.isArray( name ) ) {

				// try the string as a key before any manipulation
				if ( name in thisCache ) {
					name = [ name ];
				} else {

					// split the camel cased version by spaces unless a key with the spaces exists
					name = jQuery.camelCase( name );
					if ( name in thisCache ) {
						name = [ name ];
					} else {
						name = name.split(" ");
					}
				}
			} else {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = name.concat( jQuery.map( name, jQuery.camelCase ) );
			}

			i = name.length;
			while ( i-- ) {
				delete thisCache[ name[i] ];
			}

			// If there is no data left in the cache, we want to continue
			// and let the cache object itself get destroyed
			if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {
				return;
			}
		}
	}

	// See jQuery.data for more information
	if ( !pvt ) {
		delete cache[ id ].data;

		// Don't destroy the parent cache unless the internal data object
		// had been the only thing left in it
		if ( !isEmptyDataObject( cache[ id ] ) ) {
			return;
		}
	}

	// Destroy the cache
	if ( isNode ) {
		jQuery.cleanData( [ elem ], true );

	// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
	/* jshint eqeqeq: false */
	} else if ( jQuery.support.deleteExpando || cache != cache.window ) {
		/* jshint eqeqeq: true */
		delete cache[ id ];

	// When all else fails, null
	} else {
		cache[ id ] = null;
	}
}

jQuery.extend({
	cache: {},

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"applet": true,
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data ) {
		return internalData( elem, name, data );
	},

	removeData: function( elem, name ) {
		return internalRemoveData( elem, name );
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return internalData( elem, name, data, true );
	},

	_removeData: function( elem, name ) {
		return internalRemoveData( elem, name, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		// Do not set data on non-element because it will not be cleared (#8335).
		if ( elem.nodeType && elem.nodeType !== 1 && elem.nodeType !== 9 ) {
			return false;
		}

		var noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];

		// nodes accept data unless otherwise specified; rejection can be conditional
		return !noData || noData !== true && elem.getAttribute("classid") === noData;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var attrs, name,
			data = null,
			i = 0,
			elem = this[0];

		// Special expections of .data basically thwart jQuery.access,
		// so implement the relevant behavior ourselves

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					attrs = elem.attributes;
					for ( ; i < attrs.length; i++ ) {
						name = attrs[i].name;

						if ( name.indexOf("data-") === 0 ) {
							name = jQuery.camelCase( name.slice(5) );

							dataAttr( elem, name, data[ name ] );
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		return arguments.length > 1 ?

			// Sets one value
			this.each(function() {
				jQuery.data( this, key, value );
			}) :

			// Gets one value
			// Try to fetch any internally stored data first
			elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : null;
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
						data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	var name;
	for ( name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}
jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray(data) ) {
					queue = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return jQuery._data( elem, key ) || jQuery._data( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				jQuery._removeData( elem, type + "queue" );
				jQuery._removeData( elem, key );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while( i-- ) {
			tmp = jQuery._data( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var nodeHook, boolHook,
	rclass = /[\t\r\n\f]/g,
	rreturn = /\r/g,
	rfocusable = /^(?:input|select|textarea|button|object)$/i,
	rclickable = /^(?:a|area)$/i,
	ruseDefault = /^(?:checked|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute,
	getSetInput = jQuery.support.input;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classes, elem, cur, clazz, j,
			i = 0,
			len = this.length,
			proceed = typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( core_rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}
					elem.className = jQuery.trim( cur );

				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j,
			i = 0,
			len = this.length,
			proceed = arguments.length === 0 || typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( core_rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}
					elem.className = value ? jQuery.trim( cur ) : "";
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( core_rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === core_strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed "false",
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var ret, hooks, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// Use proper attribute retrieval(#6932, #12072)
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// oldIE doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( jQuery(option).val(), values ) >= 0) ) {
						optionSet = true;
					}
				}

				// force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === core_strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( core_rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
						elem[ propName ] = false;
					// Support: IE<9
					// Also clear defaultChecked/defaultSelected (if appropriate)
					} else {
						elem[ jQuery.camelCase( "default-" + name ) ] =
							elem[ propName ] = false;
					}

				// See #9699 for explanation of this approach (setting first, then removal)
				} else {
					jQuery.attr( elem, name, "" );
				}

				elem.removeAttribute( getSetAttribute ? name : propName );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to default in case type is set after value during creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				return tabindex ?
					parseInt( tabindex, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						-1;
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
			// IE<8 needs the *property* name
			elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );

		// Use defaultChecked and defaultSelected for oldIE
		} else {
			elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
		}

		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = jQuery.expr.attrHandle[ name ] || jQuery.find.attr;

	jQuery.expr.attrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?
		function( elem, name, isXML ) {
			var fn = jQuery.expr.attrHandle[ name ],
				ret = isXML ?
					undefined :
					/* jshint eqeqeq: false */
					(jQuery.expr.attrHandle[ name ] = undefined) !=
						getter( elem, name, isXML ) ?

						name.toLowerCase() :
						null;
			jQuery.expr.attrHandle[ name ] = fn;
			return ret;
		} :
		function( elem, name, isXML ) {
			return isXML ?
				undefined :
				elem[ jQuery.camelCase( "default-" + name ) ] ?
					name.toLowerCase() :
					null;
		};
});

// fix oldIE attroperties
if ( !getSetInput || !getSetAttribute ) {
	jQuery.attrHooks.value = {
		set: function( elem, value, name ) {
			if ( jQuery.nodeName( elem, "input" ) ) {
				// Does not return so that setAttribute is also used
				elem.defaultValue = value;
			} else {
				// Use nodeHook if defined (#1954); otherwise setAttribute is fine
				return nodeHook && nodeHook.set( elem, value, name );
			}
		}
	};
}

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = {
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				elem.setAttributeNode(
					(ret = elem.ownerDocument.createAttribute( name ))
				);
			}

			ret.value = value += "";

			// Break association with cloned elements by also using setAttribute (#9646)
			return name === "value" || value === elem.getAttribute( name ) ?
				value :
				undefined;
		}
	};
	jQuery.expr.attrHandle.id = jQuery.expr.attrHandle.name = jQuery.expr.attrHandle.coords =
		// Some attributes are constructed with empty-string values when not defined
		function( elem, name, isXML ) {
			var ret;
			return isXML ?
				undefined :
				(ret = elem.getAttributeNode( name )) && ret.value !== "" ?
					ret.value :
					null;
		};
	jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret = elem.getAttributeNode( name );
			return ret && ret.specified ?
				ret.value :
				undefined;
		},
		set: nodeHook.set
	};

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		set: function( elem, value, name ) {
			nodeHook.set( elem, value === "" ? false : value, name );
		}
	};

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		};
	});
}


// Some attributes require a special call on IE
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !jQuery.support.hrefNormalized ) {
	// href/src property should get the full normalized URL (#10299/#12915)
	jQuery.each([ "href", "src" ], function( i, name ) {
		jQuery.propHooks[ name ] = {
			get: function( elem ) {
				return elem.getAttribute( name, 4 );
			}
		};
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Note: IE uppercases css property names, but if we were to .toLowerCase()
			// .cssText, that would destroy case senstitivity in URL's, like in "background"
			return elem.style.cssText || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = value + "" );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !jQuery.support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			// Support: Webkit
			// "" is returned instead of "on" if a value isn't specified
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});
var rformElems = /^(?:input|select|textarea)$/i,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {
		var tmp, events, t, handleObjIn,
			special, eventHandle, handleObj,
			handlers, type, namespaces, origType,
			elemData = jQuery._data( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( core_rnotwhite ) || [""];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {
		var j, handleObj, tmp,
			origCount, t, events,
			special, handlers, type,
			namespaces, origType,
			elemData = jQuery.hasData( elem ) && jQuery._data( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( core_rnotwhite ) || [""];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery._removeData( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		var handle, ontype, cur,
			bubbleType, special, tmp, i,
			eventPath = [ elem || document ],
			type = core_hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = core_hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					try {
						elem[ type ]();
					} catch ( e ) {
						// IE<9 dies on focus/blur to hidden element (#1486,#12518)
						// only reproducible on winXP IE8 native, not IE9 in IE8 mode
					}
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, ret, handleObj, matched, j,
			handlerQueue = [],
			args = core_slice.call( arguments ),
			handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var sel, handleObj, matches, i,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			/* jshint eqeqeq: false */
			for ( ; cur != this; cur = cur.parentNode || this ) {
				/* jshint eqeqeq: true */

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: IE<9
		// Fix target property (#1925)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Support: Chrome 23+, Safari?
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// Support: IE<9
		// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
		event.metaKey = !!event.metaKey;

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var body, eventDoc, doc,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					try {
						this.focus();
						return false;
					} catch ( e ) {
						// Support: IE<9
						// If we error on focus to hidden element (#1486, #12518),
						// let .trigger() run the handlers
					}
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Even when returnValue equals to undefined Firefox will still show alert
				if ( event.result !== undefined ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		var name = "on" + type;

		if ( elem.detachEvent ) {

			// #8545, #7054, preventing memory leaks for custom events in IE6-8
			// detachEvent needed property on element, by name of that event, to properly expose it to GC
			if ( typeof elem[ name ] === core_strundefined ) {
				elem[ name ] = null;
			}

			elem.detachEvent( name, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;
		if ( !e ) {
			return;
		}

		// If preventDefault exists, run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// Support: IE
		// Otherwise set the returnValue property of the original event to false
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;
		if ( !e ) {
			return;
		}
		// If stopPropagation exists, run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}

		// Support: IE
		// Set the cancelBubble property of the original event to true
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !jQuery._data( form, "submitBubbles" ) ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					jQuery._data( form, "submitBubbles", true );
				}
			});
			// return undefined since we don't need an event listener
		},

		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
						}
						// Allow triggered, simulated change events (#11500)
						jQuery.event.simulate( "change", this, event, true );
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					jQuery._data( elem, "changeBubbles", true );
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return !rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var type, origFn;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});
var isSimple = /^.[^:#\[\.,]*$/,
	rparentsprev = /^(?:parents|prev(?:Until|All))/,
	rneedsContext = jQuery.expr.match.needsContext,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			ret = [],
			self = this,
			len = self.length;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},

	has: function( target ) {
		var i,
			targets = jQuery( target, this ),
			len = targets.length;

		return this.filter(function() {
			for ( i = 0; i < len; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},

	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			ret = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					cur = ret.push( cur );
					break;
				}
			}
		}

		return this.pushStack( ret.length > 1 ? jQuery.unique( ret ) : ret );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( jQuery.unique(all) );
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	do {
		cur = cur[ dir ];
	} while ( cur && cur.nodeType !== 1 );

	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				ret = jQuery.unique( ret );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				ret = ret.reverse();
			}
		}

		return this.pushStack( ret );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 && elem.nodeType === 1 ?
			jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
			jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
				return elem.nodeType === 1;
			}));
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;
	});
}
function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
		safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	manipulation_rcheckableType = /^(?:checkbox|radio)$/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		area: [ 1, "<map>", "</map>" ],
		param: [ 1, "<object>", "</object>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
		// unless wrapped in a div with non-breaking characters in front of it.
		_default: jQuery.support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
	},
	safeFragment = createSafeFragment( document ),
	fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

jQuery.fn.extend({
	text: function( value ) {
		return jQuery.access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem, false ) );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}

			// If this is a select, ensure that it displays empty (#12336)
			// Support: IE<9
			if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
				elem.options.length = 0;
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return jQuery.access( this, function( value ) {
			var elem = this[0] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					undefined;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&
				( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {
						// Remove element nodes and prevent memory leaks
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var
			// Snapshot the DOM in case .domManip sweeps something relevant into its fragment
			args = jQuery.map( this, function( elem ) {
				return [ elem.nextSibling, elem.parentNode ];
			}),
			i = 0;

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			var next = args[ i++ ],
				parent = args[ i++ ];

			if ( parent ) {
				// Don't use the snapshot next if it has moved (#13810)
				if ( next && next.parentNode !== parent ) {
					next = this.nextSibling;
				}
				jQuery( this ).remove();
				parent.insertBefore( elem, next );
			}
		// Allow new content to include elements from the context set
		}, true );

		// Force removal if there was no new content (e.g., from empty arguments)
		return i ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback, allowIntersection ) {

		// Flatten any nested arrays
		args = core_concat.apply( [], args );

		var first, node, hasScripts,
			scripts, doc, fragment,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[0],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction || !( l <= 1 || typeof value !== "string" || jQuery.support.checkClone || !rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[0] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback, allowIntersection );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, !allowIntersection && this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[i], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Hope ajax is available...
								jQuery._evalUrl( node.src );
							} else {
								jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
							}
						}
					}
				}

				// Fix #11809: Avoid leaking memory
				fragment = first = null;
			}
		}

		return this;
	}
});

// Support: IE<8
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType === 1 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (jQuery.find.attr( elem, "type" ) !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );
	if ( match ) {
		elem.type = match[1];
	} else {
		elem.removeAttribute("type");
	}
	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var elem,
		i = 0;
	for ( ; (elem = elems[i]) != null; i++ ) {
		jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
	}
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function fixCloneNodeIssues( src, dest ) {
	var nodeName, e, data;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 copies events bound via attachEvent when using cloneNode.
	if ( !jQuery.support.noCloneEvent && dest[ jQuery.expando ] ) {
		data = jQuery._data( dest );

		for ( e in data.events ) {
			jQuery.removeEvent( dest, e, data.handle );
		}

		// Event data gets referenced instead of copied if the expando gets copied too
		dest.removeAttribute( jQuery.expando );
	}

	// IE blanks contents when cloning scripts, and tries to evaluate newly-set text
	if ( nodeName === "script" && dest.text !== src.text ) {
		disableScript( dest ).text = src.text;
		restoreScript( dest );

	// IE6-10 improperly clones children of object elements using classid.
	// IE10 throws NoModificationAllowedError if parent is null, #12132.
	} else if ( nodeName === "object" ) {
		if ( dest.parentNode ) {
			dest.outerHTML = src.outerHTML;
		}

		// This path appears unavoidable for IE9. When cloning an object
		// element in IE9, the outerHTML strategy above is not sufficient.
		// If the src has innerHTML and the destination does not,
		// copy the src.innerHTML into the dest.innerHTML. #10324
		if ( jQuery.support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
			dest.innerHTML = src.innerHTML;
		}

	} else if ( nodeName === "input" && manipulation_rcheckableType.test( src.type ) ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set

		dest.defaultChecked = dest.checked = src.checked;

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.defaultSelected = dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			i = 0,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone(true);
			jQuery( insert[i] )[ original ]( elems );

			// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
			core_push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});

function getAll( context, tag ) {
	var elems, elem,
		i = 0,
		found = typeof context.getElementsByTagName !== core_strundefined ? context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== core_strundefined ? context.querySelectorAll( tag || "*" ) :
			undefined;

	if ( !found ) {
		for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
			if ( !tag || jQuery.nodeName( elem, tag ) ) {
				found.push( elem );
			} else {
				jQuery.merge( found, getAll( elem, tag ) );
			}
		}
	}

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], found ) :
		found;
}

// Used in buildFragment, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( manipulation_rcheckableType.test( elem.type ) ) {
		elem.defaultChecked = elem.checked;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var destElements, node, clone, i, srcElements,
			inPage = jQuery.contains( elem.ownerDocument, elem );

		if ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
			clone = elem.cloneNode( true );

		// IE<=8 does not properly clone detached, unknown element nodes
		} else {
			fragmentDiv.innerHTML = elem.outerHTML;
			fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
		}

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			// Fix all IE cloning issues
			for ( i = 0; (node = srcElements[i]) != null; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					fixCloneNodeIssues( node, destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0; (node = srcElements[i]) != null; i++ ) {
					cloneCopyEvent( node, destElements[i] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		destElements = srcElements = node = null;

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var j, elem, contains,
			tmp, tag, tbody, wrap,
			l = elems.length,

			// Ensure a safe fragment
			safe = createSafeFragment( context ),

			nodes = [],
			i = 0;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || safe.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;

					tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];

					// Descend through wrappers to the right content
					j = wrap[0];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Manually add leading whitespace removed by IE
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						elem = tag === "table" && !rtbody.test( elem ) ?
							tmp.firstChild :

							// String was a bare <thead> or <tfoot>
							wrap[1] === "<table>" && !rtbody.test( elem ) ?
								tmp :
								0;

						j = elem && elem.childNodes.length;
						while ( j-- ) {
							if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
								elem.removeChild( tbody );
							}
						}
					}

					jQuery.merge( nodes, tmp.childNodes );

					// Fix #12392 for WebKit and IE > 9
					tmp.textContent = "";

					// Fix #12392 for oldIE
					while ( tmp.firstChild ) {
						tmp.removeChild( tmp.firstChild );
					}

					// Remember the top-level container for proper cleanup
					tmp = safe.lastChild;
				}
			}
		}

		// Fix #11356: Clear elements from fragment
		if ( tmp ) {
			safe.removeChild( tmp );
		}

		// Reset defaultChecked for any radios and checkboxes
		// about to be appended to the DOM in IE 6/7 (#8060)
		if ( !jQuery.support.appendChecked ) {
			jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
		}

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( safe.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		tmp = null;

		return safe;
	},

	cleanData: function( elems, /* internal */ acceptData ) {
		var elem, type, id, data,
			i = 0,
			internalKey = jQuery.expando,
			cache = jQuery.cache,
			deleteExpando = jQuery.support.deleteExpando,
			special = jQuery.event.special;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( acceptData || jQuery.acceptData( elem ) ) {

				id = elem[ internalKey ];
				data = id && cache[ id ];

				if ( data ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Remove cache only if it was not already removed by jQuery.event.remove
					if ( cache[ id ] ) {

						delete cache[ id ];

						// IE does not allow us to delete expando properties from nodes,
						// nor does it have a removeAttribute function on Document nodes;
						// we must handle all of these cases
						if ( deleteExpando ) {
							delete elem[ internalKey ];

						} else if ( typeof elem.removeAttribute !== core_strundefined ) {
							elem.removeAttribute( internalKey );

						} else {
							elem[ internalKey ] = null;
						}

						core_deletedIds.push( id );
					}
				}
			}
		}
	},

	_evalUrl: function( url ) {
		return jQuery.ajax({
			url: url,
			type: "GET",
			dataType: "script",
			async: false,
			global: false,
			"throws": true
		});
	}
});
jQuery.fn.extend({
	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});
var iframe, getStyles, curCSS,
	ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity\s*=\s*([^)]*)/,
	rposition = /^(top|right|bottom|left)$/,
	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rmargin = /^margin/,
	rnumsplit = new RegExp( "^(" + core_pnum + ")(.*)$", "i" ),
	rnumnonpx = new RegExp( "^(" + core_pnum + ")(?!px)[a-z%]+$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + core_pnum + ")", "i" ),
	elemdisplay = { BODY: "block" },

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: 0,
		fontWeight: 400
	},

	cssExpand = [ "Top", "Right", "Bottom", "Left" ],
	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name.charAt(0).toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function isHidden( elem, el ) {
	// isHidden might be called from jQuery#filter function;
	// in that case, element will be second argument
	elem = el || elem;
	return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = jQuery._data( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = jQuery._data( elem, "olddisplay", css_defaultDisplay(elem.nodeName) );
			}
		} else {

			if ( !values[ index ] ) {
				hidden = isHidden( elem );

				if ( display && display !== "none" || !hidden ) {
					jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
				}
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.fn.extend({
	css: function( name, value ) {
		return jQuery.access( this, function( elem, name, value ) {
			var len, styles,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
			// but it would mean to define eight (for every problematic property) identical functions
			if ( !jQuery.support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {

				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var num, val, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

// NOTE: we've included the "window" in window.getComputedStyle
// because jsdom on node.js will break without it.
if ( window.getComputedStyle ) {
	getStyles = function( elem ) {
		return window.getComputedStyle( elem, null );
	};

	curCSS = function( elem, name, _computed ) {
		var width, minWidth, maxWidth,
			computed = _computed || getStyles( elem ),

			// getPropertyValue is only needed for .css('filter') in IE9, see #12537
			ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,
			style = elem.style;

		if ( computed ) {

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
			// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret;
	};
} else if ( document.documentElement.currentStyle ) {
	getStyles = function( elem ) {
		return elem.currentStyle;
	};

	curCSS = function( elem, name, _computed ) {
		var left, rs, rsLeft,
			computed = _computed || getStyles( elem ),
			ret = computed ? computed[ name ] : undefined,
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret == null && style && style[ name ] ) {
			ret = style[ name ];
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		// but not position css attributes, as those are proportional to the parent element instead
		// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
		if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

			// Remember the original values
			left = style.left;
			rs = elem.runtimeStyle;
			rsLeft = rs && rs.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				rs.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				rs.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

// Try to determine the default display value of an element
function css_defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {
			// Use the already-created iframe if possible
			iframe = ( iframe ||
				jQuery("<iframe frameborder='0' width='0' height='0'/>")
				.css( "cssText", "display:block !important" )
			).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = ( iframe[0].contentWindow || iframe[0].contentDocument ).document;
			doc.write("<!doctype html><html><body>");
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}

// Called ONLY from within css_defaultDisplay
function actualDisplay( name, doc ) {
	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
		display = jQuery.css( elem[0], "display" );
	elem.remove();
	return display;
}

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				return elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, "display" ) ) ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			// if value === "", then remove inline opacity #12685
			if ( ( value >= 1 || value === "" ) &&
					jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
					style.removeAttribute ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there is no filter style applied in a css rule or unset inline opacity, we are done
				if ( value === "" || currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

// These hooks cannot be added until DOM ready because the support test
// for it is not run until after DOM ready
jQuery(function() {
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				if ( computed ) {
					// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
					// Work around by temporarily setting element display to inline-block
					return jQuery.swap( elem, { "display": "inline-block" },
						curCSS, [ elem, "marginRight" ] );
				}
			}
		};
	}

	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// getComputedStyle returns percent when specified for top/left/bottom/right
	// rather than make the css module depend on the offset module, we just check for it here
	if ( !jQuery.support.pixelPosition && jQuery.fn.position ) {
		jQuery.each( [ "top", "left" ], function( i, prop ) {
			jQuery.cssHooks[ prop ] = {
				get: function( elem, computed ) {
					if ( computed ) {
						computed = curCSS( elem, prop );
						// if curCSS returns percentage, fallback to offset
						return rnumnonpx.test( computed ) ?
							jQuery( elem ).position()[ prop ] + "px" :
							computed;
					}
				}
			};
		});
	}

});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		// Support: Opera <= 12.12
		// Opera reports offsetWidths and offsetHeights less than zero on some elements
		return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
			(!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});
var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function(){
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function(){
			var type = this.type;
			// Use .is(":disabled") so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !manipulation_rcheckableType.test( type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

//Serialize an array of form elements or a set of
//key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}
jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});
var
	// Document location
	ajaxLocParts,
	ajaxLocation,
	ajax_nonce = jQuery.now(),

	ajax_rquery = /\?/,
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( core_rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var deep, key,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, response, type,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = url.slice( off, url.length );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};

// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ){
	jQuery.fn[ type ] = function( fn ){
		return this.on( type, fn );
	};
});

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Cross-domain detection vars
			parts,
			// Loop variable
			i,
			// URL without anti-cache param
			cacheURL,
			// Response headers as string
			responseHeadersString,
			// timeout handle
			timeoutTimer,

			// To know if global events are to be dispatched
			fireGlobals,

			transport,
			// Response headers
			responseHeaders,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( core_rnotwhite ) || [""];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + ajax_nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( ajax_rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ajax_nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {
	var firstDataType, ct, finalDataType, type,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}
// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || jQuery("head")[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement("script");

				script.async = true;

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( script.parentNode ) {
							script.parentNode.removeChild( script );
						}

						// Dereference the script
						script = null;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};

				// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
				// Use native DOM manipulation to avoid our domManip AJAX trickery
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( undefined, true );
				}
			}
		};
	}
});
var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( ajax_nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( ajax_rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});
var xhrCallbacks, xhrSupported,
	xhrId = 0,
	// #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject && function() {
		// Abort all pending requests
		var key;
		for ( key in xhrCallbacks ) {
			xhrCallbacks[ key ]( undefined, true );
		}
	};

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject("Microsoft.XMLHTTP");
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
xhrSupported = jQuery.ajaxSettings.xhr();
jQuery.support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
xhrSupported = jQuery.support.ajax = !!xhrSupported;

// Create transport if the browser can provide an xhr
if ( xhrSupported ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var handle, i,
						xhr = s.xhr();

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( err ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {
						var status, responseHeaders, statusText, responses;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occurred
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									responses = {};
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();

									// When requesting binary data, IE6-9 will throw an exception
									// on any attempt to access responseText (#11426)
									if ( typeof xhr.responseText === "string" ) {
										responses.text = xhr.responseText;
									}

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					if ( !s.async ) {
						// if we're in sync mode we fire the callback
						callback();
					} else if ( xhr.readyState === 4 ) {
						// (IE6 & IE7) if it's in cache and has been
						// retrieved directly we need to fire the callback
						setTimeout( callback );
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback( undefined, true );
					}
				}
			};
		}
	});
}
var fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + core_pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*
					// Use a string for doubling factor so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur()
				// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		}]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// we're done with this property
			return tween;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = jQuery._data( elem, "fxshow" );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE does not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		if ( jQuery.css( elem, "display" ) === "inline" &&
				jQuery.css( elem, "float" ) === "none" ) {

			// inline-level elements accept inline-block;
			// block-level elements need to be inline with layout
			if ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === "inline" ) {
				style.display = "inline-block";

			} else {
				style.zoom = 1;
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		if ( !jQuery.support.shrinkWrapBlocks ) {
			anim.always(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}
	}


	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {
				continue;
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = jQuery._data( elem, "fxshow", {} );
		}

		// store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;
			jQuery._removeData( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}
	}
}

function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9
// Panic based approach to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || jQuery._data( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = jQuery._data( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = jQuery._data( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// enable finishing flag on private data
			data.finish = true;

			// empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// turn off finishing flag
			delete data.finish;
		});
	}
});

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		attrs = { height: type },
		i = 0;

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth? 1 : 0;
	for( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p*Math.PI ) / 2;
	}
};

jQuery.timers = [];
jQuery.fx = Tween.prototype.init;
jQuery.fx.tick = function() {
	var timer,
		timers = jQuery.timers,
		i = 0;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	if ( timer() && jQuery.timers.push( timer ) ) {
		jQuery.fx.start();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};

// Back Compat <1.8 extension point
jQuery.fx.step = {};

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}
jQuery.fn.offset = function( options ) {
	if ( arguments.length ) {
		return options === undefined ?
			this :
			this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
	}

	var docElem, win,
		box = { top: 0, left: 0 },
		elem = this[ 0 ],
		doc = elem && elem.ownerDocument;

	if ( !doc ) {
		return;
	}

	docElem = doc.documentElement;

	// Make sure it's not a disconnected DOM node
	if ( !jQuery.contains( docElem, elem ) ) {
		return box;
	}

	// If we don't have gBCR, just use 0,0 rather than error
	// BlackBerry 5, iOS 3 (original iPhone)
	if ( typeof elem.getBoundingClientRect !== core_strundefined ) {
		box = elem.getBoundingClientRect();
	}
	win = getWindow( doc );
	return {
		top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
		left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
	};
};

jQuery.offset = {

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			parentOffset = { top: 0, left: 0 },
			elem = this[ 0 ];

		// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// we assume that getBoundingClientRect is available when computed position is fixed
			offset = elem.getBoundingClientRect();
		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		return {
			top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;
			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position") === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent || docElem;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return jQuery.access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					win.document.documentElement[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}
// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return jQuery.access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
					// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});
// Limit scope pollution from any deprecated API
// (function() {

// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;

// })();
if ( typeof module === "object" && module && typeof module.exports === "object" ) {
	// Expose jQuery as module.exports in loaders that implement the Node
	// module pattern (including browserify). Do not create the global, since
	// the user will be storing it themselves locally, and globals are frowned
	// upon in the Node module world.
	module.exports = jQuery;
} else {
	// Otherwise expose jQuery to the global object as usual
	window.jQuery = window.$ = jQuery;

	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.
	if ( typeof define === "function" && define.amd ) {
		define( "jquery", [], function () { return jQuery; } );
	}
}

})( window );
	 return jQuery;
});
/**
 * newBee  build
 */

define('qccomponent', function(require, exports, module) {

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Bee = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
var Bee = _dereq_('beejs')
var Event = _dereq_('beejs/addons/event')
var beeEventBind = _dereq_('beejs/src/event-bind')

window.Bee = Bee;

// jquery  beejs  :<
Bee.directive('on', $.extend({}, Bee.directives.on, {
  update: function(events) {
    var selector, eventType;
    for(var name in events) {
      selector = name.split(/\s+/);
      eventType = selector.shift();
      selector = selector.join(' ');
      $(this.el).on(eventType, selector, events[name].bind(this.vm))
    }
  }
}))

var ComponentBase = Bee.extend({
/**
  * 
  * example:
  * ```
  * <my-tag>
  *   <script type="text/json" data>
  *    {
  *      "key": "data here"
  *    }
  *   </script>
  * </my-tag>
  * ```
  */
  $beforeInit: function() {
    var dataSelector = this.$data.dataSelector || 'script[data]'
    var dataEl

    if(this.$content) {
      dataEl = this.$content.querySelector(dataSelector)
      this.$set(JSON.parse(dataEl && dataEl.innerHTML.trim() || '{}'))
    }
  },
  $mixins: [Event]
});

beeEventBind.addEvent = function(el, type, callback) {
  $(el).on(type, callback)
}

beeEventBind.removeEvent = function(el, type, callback) {
  $(el).off(type, callback)
}

Bee.ComponentBase = ComponentBase;

module.exports = ComponentBase;

},{"beejs":27,"beejs/addons/event":26,"beejs/src/event-bind":47}],2:[function(_dereq_,module,exports){
/**
 * 
 */

'use strict';


var tpl = "<div data-role=\"device-selector\" class=\"tc-15-mod-selector\">\n    <div b-on=\"events\" class=\"tc-15-mod-selector-tb\">\n        <div class=\"tc-15-option-cell options-left\">\n            <div class=\"tc-15-option-hd\">\n                <h4>{{title}}</h4>\n            </div>\n            <div class=\"tc-15-option-bd\">\n              <div class=\"search-box {{multipleSearch ? 'multi-search-box' : ''}}\">\n                <div class=\"search-input-wrap\">\n                <input b-if=\"!multipleSearch\" style=\"padding-left: 10px;\" data-search type=\"text\" placeholder=\"{{searchPlaceHolder}}\" b-model=\"keyword\" class=\"tc-15-input-text search-input\">\n                <textarea b-if=\"multipleSearch\" data-search type=\"text\" placeholder=\"{{searchPlaceHolder}}\" b-model=\"keyword\" class=\"tc-15-input-text search-input\"></textarea>\n                <a title=\"\" b-on-click=\"searchReset()\" class=\"btn-rm-txt\" role=\"button\" href=\"javascript:;\"></a>\n                </div>\n                <input type=\"button\" data-search-btn value=\"\" class=\"search-btn\">\n              </div>\n              <div class=\"tc-15-option-box\">\n                <div class=\"info-row\" b-if=\"list.length && searchKey\">{{> searchTipTpl }}<a b-on-click=\"backList()\" href=\"javascript:;\"></a></div>\n                <ul data-list class=\"tc-15-option-list\">\n                    <li data-item b-repeat=\"item in list\" class=\"{{item.selected ? 'selected' : ''}} {{item.disabled ? 'disabled' : ''}}\" title?=\"item.$title\">\n                        {{> listTpl }}\n                    </li>\n                </ul>\n                <div class=\"info-row\" b-if=\"loading\"><b class=\"n-loading-icon\"></b>...</div>\n                <div class=\"info-row\" b-if=\"!list.length && !loading\">\n                  <b class=\"n-error-icon\"></b>{{emptyTips || (\"\" + deviceName)}} <a b-if=\"searchKey\" b-on-click=\"backList()\" href=\"javascript:;\"></a>\n                </div>\n              </div>\n            </div>\n        </div>\n        <div class=\"tc-15-option-cell separator-cell\">\n          <i class=\"icon-sep\"></i>\n        </div>\n        <div class=\"tc-15-option-cell options-right\">\n          <div class=\"tc-15-option-hd\">\n            <h4> ({{selected.length}})</h4>\n          </div>\n          <div class=\"tc-15-option-bd\">\n            <div class=\"tc-15-option-box\">\n              <ul data-selected class=\"tc-15-option-list\">\n                  <li b-repeat=\"item in selected\">\n                      {{> selectedTpl }}\n                  </li>\n              </ul>\n              <div class=\"info-row\" b-if=\"!selected.length\">\n                {{selectedEmptyTips || (\"\" + deviceName)}}\n              </div>\n            </div>\n          </div>\n        </div>\n    </div>\n    <p class=\"tc-15-mod-selector-tips\">Shift</p>\n</div>\n";
var Base = _dereq_('../componentBase');
var Bee = _dereq_('beejs');

//
var defaults = {
  title: '',
  searchPlaceHolder: 'IP',
  //
  alias: {
    'name': 'alias',
    'ip': 'deviceLanIp',
    'network': 'netName',
    'id': 'uuid'
  },
  emptyTips: '',
  selectedEmptyTips: '',
  deviceName: '',
  keyword: '',
  list: [],
  size: undefined, //. ,  list.length
  selected: [],

  scrollPager: false, //
  pageCoef: 1, //. x 
  loading: false,

  initGetData: false, // `getData`

  multipleSearch: false,

  page: 1, //
  count: 20, //
  showDesc: true
};

var DeviceSelector = Base.extend({
  $tpl: tpl,

  $afterInit: function $afterInit() {
    this.selected.forEach(function (item) {
      return item.selected = true;
    });
    this._updateList(this.selected);
    this.initGetData && this._getData({ page: 1, count: this.count });

    this.bindEvent();
  },

  listTpl: '\n    <input type="checkbox" disabled?="item.disabled" class="tc-15-checkbox" b-model="item.selected">\n    <span class="opt-txt">\n      <span class="opt-txt-inner">\n        {{> itemTpl}}\n      </span>\n    </span>',

  selectedTpl: '\n    <span class="opt-txt">\n      <span class="opt-txt-inner">\n        {{> itemTpl}}\n      </span>\n    </span>\n    <a role="button" class="opt-act" href="javascript:;">\n      <i b-on="{click: _delSelected}" class="icon-del"></i>\n    </a>',

  itemTpl: '\n      <span class="item-name">{{> nameTpl}}</span>\n      <span class="item-descr" b-if="showDesc">{{> descTpl}}</span>',

  nameTpl: '{{item[alias.name]}}',

  descTpl: '{{item[alias.network]}} | {{item[alias.ip]}}',

  searchTipTpl: ' {{size || list.length}} ',

  //
  //---

  search: function search(keyword) {
    var that = this;
    this._getData({
      page: 1,
      count: this.count,
      searchKey: keyword
    });
  },

  _getData: function _getData(opts) {
    var that = this;
    var def = $.Deferred();

    this.$set('loading', true);

    if (opts.page === 1) {
      that.$set('list', []);
    }
    this.getData(opts, function (err, data) {
      that.$set('loading', false);

      if (data) {
        //
        if (opts.searchKey !== that.searchKey || opts.page === 1) {
          that.$set($.extend({}, opts, data));
        } else {
          //
          that.$set({ 'size': data.size, 'list': that.list.concat(data.list) });
        }
        that._updateList(that.selected);
      }

      err ? def.reject(err) : def.resolve(data);
    });

    return def.promise();
  },

  //
  getData: function getData(opts, callback) {
    callback(null, {
      list: this.list,
      size: this.size
    });
  },

  backList: function backList() {
    this.searchReset();
  },

  searchReset: function searchReset() {
    this.$set('keyword', '');
    this.search('');
  },

  //
  _updateSelected: function _updateSelected(items) {
    var selected = this.selected;
    var idKey = this.alias.id;
    items.forEach((function (item) {
      for (var i = 0, l = selected.length; i < l; i++) {
        if (selected[i] === item || typeof item[idKey] !== 'undefined' && selected[i][idKey] === item[idKey]) {
          item.selected || selected.splice(i, 1);
          return;
        }
      }
      item.selected && selected.push(item);
    }).bind(this));
  },

  // checkbox
  //items: 
  _updateList: function _updateList(items) {
    var list = this.list;
    var idKey = this.alias.id;
    items.forEach(function (item) {
      for (var i = 0, l = list.length; i < l; i++) {
        if (list[i] === item || typeof item[idKey] !== 'undefined' && list[i][idKey] === item[idKey]) {
          //item.selected = true
          list.$set(i, item);
          return;
        }
      }
    });
  },

  //.  checkbox.  alias  id 
  replaceList: function replaceList(list) {
    this.$replace('list', list);
    this._updateList(this.selected);
  },

  replaceSelected: function replaceSelected(selected) {
    this.$set('selected', selected || []);
    this._updateList(this.selected.map(function (item) {
      item.selected = true;return item;
    }));
  },

  //
  nextPage: function nextPage() {
    var that = this;
    that._getData({
      page: that.page + 1,
      count: that.count,
      searchKey: that.searchKey
    }).done(function () {
      that.page++;
    });
  },

  //
  //---

  _delSelected: function _delSelected(e) {
    this.$data.selected = false;
    var items = [this.$data];
    this.$root._updateSelected(items);
    this.$root._updateList(items);
  },

  bindEvent: function bindEvent() {
    var _this = this;

    var that = this;

    var $list = this._$list = $(this.$el).find('[data-list]');

    this._scrollLoad({
      list: $list,
      checkFn: function checkFn() {
        return !that.loading && that.page * that.count < that.size;
      },
      callback: function callback() {
        return _this.nextPage();
      }
    });

    this._scrollLoad({
      list: $(this.$el).find('[data-selected]'),
      checkFn: function checkFn() {
        return !that.loading && that.selectedPage * that.count < that.selectedSize;
      },
      callback: function callback() {}
    });
  },

  _scrollLoad: function _scrollLoad() {
    var _this2 = this;

    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var $list = opts.list;
    var $listBox = $list.parent();
    var checkFn = opts.checkFn || function () {};
    var callback = opts.callback || function () {};

    $listBox.on('scroll', function () {
      if (_this2.scrollPager && checkFn()) {
        var listHeight = $list.height();
        var height = $listBox.height();

        if (listHeight - $listBox.scrollTop() <= height * (_this2.pageCoef + 1)) {
          callback();
        }
      }
    });
  },
  events: {
    "click [data-search-btn]": function clickDataSearchBtn(e) {
      this.search(this.keyword || '');
    },
    "keydown [data-search]": function keydownDataSearch(e) {
      if (e.keyCode == 13) {
        if (!this.multipleSearch || this.multipleSearch && e.ctrlKey) {
          this.search(this.keyword || '');
          e.stopPropagation();
        }
      }
    },
    "mousedown [data-list]>li:not(.disabled),[data-list] [data-item]:not(.disabled)": function mousedownDataListLiNotDisabledDataListDataItemNotDisabled(e) {
      //
      var $root = this.$root;
      var shiftIndex = $root._shiftIndex;
      var isSelected = $root.list[shiftIndex] && $root.list[shiftIndex].selected;
      if (e.shiftKey && typeof shiftIndex !== 'undefined' && isSelected) {
        this._$list.css({
          'user-select': 'none'
        });
      }
    },
    "click [data-list]>li:not(.disabled),[data-list] [data-item]:not(.disabled)": function clickDataListLiNotDisabledDataListDataItemNotDisabled(e) {
      var _this3 = this;

      setTimeout(function () {
        var bee;
        if (e.target.tagName !== 'INPUT') {
          bee = e.currentTarget.bee;
          bee.$set('item.selected', !bee.$get('item.selected'));
        }
        var $root = _this3.$root,
            start,
            end;
        var shiftIndex = $root._shiftIndex;
        var index = e.currentTarget.$index;
        var selects,
            unselects = [],
            unselectStart;
        var isSelected = $root.list[shiftIndex] && $root.list[shiftIndex].selected;

        //
        if (e.shiftKey && typeof shiftIndex !== 'undefined' && isSelected) {
          if (shiftIndex > index) {
            //
            start = index;
            end = shiftIndex;
            if (typeof $root.lastEnd !== 'undefined') {
              if ($root.lastEnd > shiftIndex) {
                unselectStart = shiftIndex;
                unselects = $root.list.slice(shiftIndex, $root.lastEnd);
              } else {
                unselectStart = $root.lastEnd - 1;
                unselects = $root.list.slice($root.lastEnd, start);
              }
            }
            $root.lastEnd = start;
          } else {
            //
            start = shiftIndex;
            end = index;
            if (typeof $root.lastEnd !== 'undefined') {
              if ($root.lastEnd < shiftIndex) {
                unselectStart = $root.lastEnd - 1;
                unselects = $root.list.slice($root.lastEnd, shiftIndex);
              } else {
                unselectStart = end;
                unselects = $root.list.slice(end, $root.lastEnd);
              }
            }
            $root.lastEnd = end;
          }
          selects = $root.list.slice(start, end + 1);
          selects.forEach(function (item, i) {
            if (!item.disabled) {
              item.selected = isSelected;
              $root.list.$set(start + i, {
                selected: isSelected
              });
            }
          });

          var _unselects = [];
          unselects.forEach(function (item, i) {
            // item 
            $root.list.$set(unselectStart + 1 + i, {
              selected: !isSelected
            });

            _unselects.push($root.list[unselectStart + 1 + i]);
          });

          _this3._updateSelected(_unselects);

          // shift , 
          //delete $root._shiftIndex;

          _this3._$list.css({
            'user-select': ''
          });
        } else {
          selects = [$root.list[index]];
          $root._shiftIndex = index; //
          delete $root.lastEnd;
          isSelected = $root.list[index].selected;
        }

        _this3._updateSelected(selects);
      }, 0);
    }
  }
}, { defaults: defaults });

module.exports = DeviceSelector;

},{"../componentBase":1,"beejs":27}],3:[function(_dereq_,module,exports){
//Beejs 

// `brfs`
'use strict';


var tpl = "<div data-role=\"grid-editor\" b-style=\"style\" b-on=\"events\">\n<div data-grid-panel class=\"tc-15-table-panel tc-15-table-panel-edit\" style=\"position:relative\" b-on=\"$events\">\n  <div data-grid-head class=\"tc-15-table-fixed-head\">\n    <table b-ref=\"head\" class=\"tc-15-table-box\">\n      <colgroup>\n        <col b-if=\"dragable\" style=\"width: 50px\">\n        <col b-repeat=\"col in shownColums\" class=\"{{col.colClassName}}\" b-style=\"{width: col.width || 'auto'}\">\n      </colgroup>\n      <thead>\n        <tr>\n          <th b-if=\"dragable\">\n            <div></div>\n          </th>\n          <th b-repeat=\"col in shownColums\">\n            <div>\n              {{> _getHeadContent(col) }}\n            </div>\n            <i class=\"resize-line-icon\" data-role=\"resizer\"\n              b-if=\"canResizeColum && $index < shownColums.length - 1\"></i>\n          </th>\n        </tr>\n      </thead>\n    </table>\n  </div>\n  <div data-grid-body class=\"tc-15-table-fixed-body\">\n    <table b-ref=\"body\" class=\"tc-15-table-box tc-15-table-rowhover\">\n      <colgroup>\n          <col b-if=\"dragable\" style=\"width: 40px;\">\n          <col b-repeat=\"col in shownColums\" class=\"{{col.colClassName}}\" b-style=\"{width: col.width || 'auto'}\">\n      </colgroup>\n      <tbody>\n      <tr data-tips b-if=\"_tips\">\n        <td class=\"text-center\" colspan=\"{{countCols(colums)}}\">\n            <div>{{> _tips }}</div>\n        </td>\n      </tr>\n      <tr data-index=\"{{$index}}\" track-by=\"{{trackKey}}\" b-ref=\"list\" b-repeat=\"item in list\"\n        b-attr=\"setTrAttr(trAttr, item)\"\n        b-style=\"{visibility: item._target ? 'hidden' : 'visible'}\"\n        class=\"{{selectedHighlight && item.$selected?'current':''}} {{item.$disable || item._remove ? 'disable': ''}}\">\n\n          <td b-if=\"dragable\" style=\"position:relative\">\n              <div data-drag-handler>\n                  <i class=\"ico-drag\"></i>\n              </div>\n              <span b-template b-if=\"insertBtn && !overMaxSize\">\n                <i style=\"top:-8px\" data-i=\"\" b-on-click=\"insert($index)\" class=\"ico-move-drag hover-icon\"></i>\n                <i style=\"bottom:-8px\" b-on-click=\"insert($index + 1)\" class=\"ico-move-drag hover-icon\"></i>\n              </span>\n          </td>\n          <td b-repeat=\"col in shownColums\" b-style=\"{position: $index ? '' : 'relative'}\">\n              <div>\n                {{> _getCellContent(item[col.key], item, col) }}\n              </div>\n              <span b-template b-if=\"insertBtn && !dragable && !$index && !overMaxSize\">\n                <i b-on-click=\"insert($parent.$index)\" style=\"top:-8px\" class=\"ico-move-drag hover-icon\"></i>\n                <i b-on-click=\"insert($parent.$index + 1)\" style=\"bottom:-8px\" class=\"ico-move-drag hover-icon\"></i>\n              </span>\n          </td>\n      </tr>\n      <tr b-if=\"bottomInsertBtn && !overMaxSize\">\n        <td colspan=\"{{countCols(colums)}}\">\n          <div>\n            <a href=\"javascript:;\" b-on=\"{click: _push}\">\n              <i class=\"blue-add-icon\"></i>{{ bottomInsertBtnTips }}\n            </a>\n          </div>\n        </td>\n      </tr>\n  </tbody>\n  </table>\n  <!-- <i data-disable-line class=\"disabled-line\"></i> -->\n  </div>\n</div>\n</div>\n";
var Bee = _dereq_('beejs');
var GridView = _dereq_('../grid-view');
var equal = _dereq_('deep-equal');

/**
 * 
 * @namespace
 * @memberof GridEditor
 * @property {Object} defaults 
 * @property {Boolean} defaults.dragable=true 
 * @property {Boolean} defaults.insertBtn=true 
 * @property {Boolean} defaults.bottomInsertBtn=false 
 * @property {Number} defaults.overlayRate=0.3 
 * @property {Object} defaults.newData 
 * @property {Number} defaults.maxSize=0 . 
 * @property {Number} defaults.minSize=0 . 
 */
var defaults = {
  dragable: true,
  insertBtn: true,
  bottomInsertBtn: false,
  bottomInsertBtnTips: '',

  newData: {
    //alias: 'new'
  },
  overlayRate: 0.3,

  maxSize: 0,
  minSize: 0,

  autoMaxHeight: false,
  emptyTips: ' <a b-on-click="insert(0)" href="javascript:;">+</a>'
};

/**
 * @class GridEditor
 */
var GridEditor = GridView.extend(
/**
 * @lends GridEditor.prototype
 */
{
  $tpl: tpl,

  overMaxSize: false,
  overMinSize: false,

  actionTpl: '<span class="text-overflow">\n    <a href="javascript:;" class="links"\n      b-on-click="(item._remove ? restore : preRemove)($parent.$index)">{{item._remove ? "" : ""}}\n    </a></span>',

  $afterInit: function $afterInit() {
    GridEditor.__super__.$afterInit.call(this);
    this.$refsBody = $(this.$refs.body);
    this._$removeLine = this._$el.find('[data-disable-line]');
    this.checkSize();
  },
  /**
   * . , 
   * @param {Number} index 
   * @returns {Boolean}  `true`,  `false`
   */
  preRemove: function preRemove(index) {
    if (this.overMinSize) {
      return false;
    } else {
      //
      if (equal(this.list[index], this.newData)) {
        this.remove(index);
      } else {
        this.updateItem(index, {
          _remove: true
        });
        this.checkSize();
      }
      return true;
    }
  },

  /**
   * 
   * @param {Number} index 
   */
  remove: function remove(index) {
    this.list.splice(index, 1);
    this.checkSize();
  },

  /**
   *  `preRemove` 
   */
  removePreRemove: function removePreRemove() {
    for (var i = this.list.length - 1; i >= 0; i--) {
      this.list[i]._remove && this.remove(i);
    }
  },

  /**
   * 
   * @param {Number} index 
   * @returns {Boolean}  `true`,  `false`
   */
  restore: function restore(index) {
    if (this.overMaxSize) {
      return false;
    } else {
      this.updateItem(index, {
        _remove: false
      });
      this.checkSize();
      return true;
    }
  },

  /**
   *  `preRemove` 
   */
  restoreAll: function restoreAll() {
    var _this = this;

    this.list.forEach(function (item, index) {
      item._remove && _this.restore(index);
    });
  },

  /**
   * 
   * @param {Number} index 
   * @param {Object} [data=detaults.newData] ,  `GridView.defaults.newData`
   * @returns {Boolean}  `true`,  `false`
   */
  insert: function insert(index, data) {
    if (this.overMaxSize) {
      data = false;
    } else {
      data = $.extend({}, data || this.newData);
      this.list.splice(index, 0, data);
      this.checkSize();
    }
    return data;
  },

  _push: function _push(e) {
    var len = this.list.length;
    var ret = this.insert(len);
    if (ret) {
      this.$refs.list[len].$el.scrollIntoViewIfNeeded ? e.target.scrollIntoViewIfNeeded() : this.$refs.list[len].$el.scrollIntoView();
    }
    return ret;
  },

  /**
   * ()
   * @return {Number} 
   */
  getSize: function getSize() {
    return this.list.filter(function (item) {
      return !item._remove;
    }).length;
  },

  /**
   * 
   * @fires GridEditor#sizeChange
   */
  checkSize: function checkSize() {
    var length = this.getSize();
    this.$set({
      overMaxSize: this.maxSize > 0 && length >= this.maxSize,
      overMinSize: this.minSize && length <= this.minSize
    });

    if (this._length !== length) {
      /**
       * 
       * @event GridEditor#sizeChange
       * @type {Object}
       * @property {Number} size , 
       * @property {Number} total 
       */
      this.$emit('sizeChange', {
        size: length,
        total: this.list.length
      });

      this.onSizeChange();
    }
    //
    this.$set('_length', length);
  },

  /**
   * . 
   */
  onSizeChange: function onSizeChange() {},

  /**
   * 
   */
  onReorder: function onReorder(index, targetIndex) {},

  // `gridView` 
  getColByIndex: function getColByIndex(index) {
    if (this.dragable) {
      index--;
    }
    return this.shownColums[index];
  },
  setData: function setData() {
    GridEditor.__super__.setData.apply(this, arguments);
    this.checkSize();
  },
  //
  countCols: function countCols(colums) {
    var colSize = colums.filter(function (col) {
      return !col.hide;
    }).length;

    return colSize + !!this.$root.dragable;
  },

  _cloneTr: function _cloneTr(tr) {
    //
    var $copy = this.$refsBody.clone();

    var $tr = $(tr).clone();

    $copy.width(this.$refsBody.width());
    $copy.find('tr').remove();
    $copy.append($tr);
    $copy.css($.extend({ 'position': 'absolute' }, this._getTrPos(tr)));

    this.$refsBody.after($copy);

    return $copy;
  },

  // tr 
  _getTrPos: function _getTrPos(tr) {
    var trOffset = $(tr).offset();
    var boxOffset = this.$refsBody.offsetParent().offset();
    return {
      left: trOffset.left - boxOffset.left,
      top: trOffset.top - boxOffset.top
    };
  },

  $events: $.extend({}, GridView.prototype.$events, {
    'mousedown [data-drag-handler]': function mousedownDataDragHandler(e) {
      // mousedown 
      if (this._draging) {
        return;
      }
      var $tr = $(e.target).closest('tr');
      var index = $tr.attr('data-index') * 1;

      //
      this._$dragingTr = $tr;

      //
      this._dragingIndex = index;

      this._$dragingItem = this._cloneTr($tr);

      this._$dragingItem.find('tr').addClass('current'); //

      //
      this._initPos = this._getTrPos($tr);
      this._initClientPos = {
        x: e.clientX,
        y: e.clientY
      };
      this._initRect = this.$el.getBoundingClientRect(); //

      this._lastY = e.clientY;

      this._setTarget(index);

      this._dragStart();
      e.preventDefault();
    }
  }),

  //
  _dragStart: function _dragStart() {
    var _this2 = this;

    this._draging = true;

    $(document).on('mousemove.grid_drag', function (e) {
      if (_this2._draging) {
        //
        _this2._dragintDir = e.clientY - _this2._lastY; //  0 ,  0 

        var rect = _this2.$el.getBoundingClientRect();

        _this2._$dragingItem.css({
          'z-index': 9999,
          top: _this2._initPos.top + e.clientY - _this2._initClientPos.y + _this2._initRect.top - rect.top,
          left: _this2._initPos.left + e.clientX - _this2._initClientPos.x + _this2._initRect.left - rect.left
        });

        _this2._checkOverlay(_this2._dragintDir);
      }
      _this2._lastY = e.clientY;
    }).on('mouseup.grid_drag', function (e) {
      //
      $(document).off('.grid_drag');

      _this2._dragDone();
      _this2._draging = false;
    });
  },

  //
  _setTarget: function _setTarget(index) {
    if (typeof this._targetIndex !== 'undefined') {

      this.updateItem(this._targetIndex, {
        _target: false
      });

      this._exchange(this._targetIndex, index);
    }

    this.$set('_targetIndex', index);

    this.updateItem(index, {
      _target: true
    });
  },

  //
  //index 
  //targetIndex 
  _exchange: function _exchange(index, targetIndex, animate) {
    var current = this.list.splice(index, 1)[0];
    var that = this;

    this.list.splice(targetIndex, 0, current);

    //splice  tr , 
    var $trs = this.$refsBody.find('tr[data-index]');
    this._$dragingTr = $trs.eq(targetIndex);

    //
    if (animate !== false) {
      var $lastTr = $trs.eq(index);
      var lastOffset = this._getTrPos(this._$dragingTr);
      var offset = this._getTrPos($lastTr);

      this._exchange_animate && this._exchange_animate.stop();

      var $animatr = this._cloneTr($lastTr).css(lastOffset);

      this._exchange_animate = $animatr.stop().animate({
        top: offset.top
      }, {
        duration: 100,
        always: function always() {
          that._exchange_animate = null;
          that.updateItem(index, {
            _target: false
          });
          $animatr.remove();
        }
      });

      if (animate == 2) {
        var $targetTr = $trs.eq(targetIndex);
        var $animatr2 = this._cloneTr($targetTr).css(offset);

        this._exchange_animate2 = $animatr2.stop().animate({
          top: this._getTrPos($targetTr).top
        }, {
          duration: 100,
          always: function always() {
            that._exchange_animate2 = null;
            that.updateItem(targetIndex, {
              _target: false
            });
            $animatr2.remove();
          }
        });

        this.updateItem(targetIndex, {
          _target: true
        });
      }

      this.updateItem(index, {
        _target: true
      });
    }
    //
  },

  //
  _dragDone: function _dragDone() {
    this.updateItem(this._targetIndex, {
      _target: false
    });

    this._$dragingItem.remove();

    if (this._dragingIndex != this._targetIndex) {
      this.onReorder(this._dragingIndex, this._targetIndex);
    }

    delete this._$dragingItem;
    delete this._targetIndex;
  },

  //
  _checkOverlay: function _checkOverlay(dir) {
    var _this3 = this;

    var trs;
    var offset = this._$dragingItem.offset();
    var height = this._$dragingItem.outerHeight();
    var checkLine;

    if (dir > 0) {
      trs = this._$dragingTr.nextAll('tr').andSelf();
      checkLine = offset.top + height; //
    } else if (dir < 0) {
        trs = this._$dragingTr.prevAll('tr').andSelf();
        checkLine = offset.top; //
      }

    if (trs) {
      trs.each(function (i, tr) {
        var rate = checkOverlay(checkLine, tr, dir);
        var index;
        if (rate >= _this3.overlayRate && rate <= 1) {
          index = $(tr).attr('data-index') * 1;
          if (index !== _this3._targetIndex) {
            _this3._setTarget(index);
          }
        }
      });
    }
  }
}, {
  defaults: defaults
});

//
function checkOverlay(y, el, dir) {
  var $el = $(el),
      h = $el.outerHeight(),
      offset = $el.offset();
  var rate;

  if (y < offset.top) {
    rate = -1;
  } else if (y > offset.top + h) {
    rate = 2;
  } else {
    rate = dir > 0 ? (y - offset.top) / h : (offset.top + h - y) / h;
  }
  return rate;
}

module.exports = GridEditor;

},{"../grid-view":5,"beejs":27,"deep-equal":54}],4:[function(_dereq_,module,exports){
'use strict';


var tpl = "<div>\r\n    <span class=\"tc-15-filtrate-btn{{ filterResult ? ' current' : ''}}\" b-on=\"{ click: _togglePopup }\" title=\"{{_getFilterTitle(filterResult)}}\">\r\n        <span>{{col.name}}</span>\r\n        <i class=\"filtrate-icon\"></i>\r\n    </span>\r\n\r\n  <div class=\"tc-15-filtrateu\" b-style=\"{\r\n    display: ui.popup ? 'block' : 'none',\r\n    width: enableClear ? '200px' : null,\r\n    right: col.pull == 'right' ? '10px' : null\r\n  }\" b-on=\"{ click: _stopPropagation }\">\r\n\r\n    <div class=\"tc-15-search\" b-if=\"search\" style=\"float: none; margin: 10px 10px 5px;\">\r\n      <input data-input class=\"tc-15-search-words\" placeholder=\"{{col.name}}\" b-model=\"keyword\" type=\"text\" style=\"width: 120px\" />\r\n      <button data-search class=\"tc-15-btn weak m search\"></button>\r\n    </div>\r\n\r\n\r\n    <ul class=\"tc-15-filtrate-menu\" role=\"menu\">\r\n      <li role=\"presentation\" class=\"tc-15-optgroup\" b-if=\"!singleMode\">\r\n        <label class=\"tc-15-checkbox-wrap\" title=\"/\" style=\"position: relative\">\r\n          <input type=\"checkbox\"\r\n                 class=\"tc-15-checkbox\"\r\n                 b-model=\"allChecked\"\r\n                 b-on-change=\"enabled && _checkAllChange(allChecked)\"\r\n                 disabled?=\"!enabled\">\r\n          ()\r\n          <span b-if=\"hasChecked && !allChecked\" style=\"background: rgb(38, 134, 214); width: 6px; height: 6px; position: absolute; left: 15px;top: 12px; border-radius: 2px;\"></span>\r\n        </label>\r\n      </li>\r\n      <li role=\"presentation\" class=\"tc-15-optgroup\" b-repeat=\"option in _searchOptions(filterOptions, keyword)\">\r\n        <label class=\"tc-15-checkbox-wrap\" title=\"{{option.label}}\">\r\n          <input type=\"checkbox\"\r\n                 class=\"tc-15-checkbox\"\r\n                 b-model=\"option.checked\"\r\n                 b-on-change=\"enabled && _filterOptionChange(option)\"\r\n                 disabled?=\"!enabled || option.disabled\">\r\n          {{option.label}}\r\n        </label>\r\n      </li>\r\n    </ul>\r\n\r\n    <div class=\"tc-15-filtrate-ft\" b-if=\"response == 'confirm'\">\r\n      <button class=\"tc-15-btn m{{enabled ? '' : ' disabled'}}\" b-on-click=\"enabled && _confirmFilter()\"></button>\r\n      <button class=\"tc-15-btn m weak{{enabled ? '' : ' disabled'}}\" b-if=\"enableClear\" b-on-click=\"enabled && _clearFilter()\"></button>\r\n      <button class=\"tc-15-btn m weak\" b-on-click=\"_cancelFilter()\"></button>\r\n    </div>\r\n  </div>\r\n\r\n</div>";
var Bee = _dereq_('beejs');
var ComponentBase = _dereq_('../componentBase');

var defaults = {
  filterOptions: [],

  filterResult: null,

  change: null,

  ready: null,

  enableClear: false,

  enabled: true,

  /**
   * 
   *     confirm - [] 
   *     immediate - 
   */
  response: 'confirm',

  search: false,

  singleMode: false,

  ui: {
    popup: false
  }
};

var GridViewHeaderFilter = ComponentBase.extend({
  $tpl: tpl,
  $valuekey: 'filterResult',

  $afterInit: function $afterInit() {
    var _this = this;

    if (this.change) {
      this.$watch('filterResult', function () {
        return _this.change(_this.filterResult);
      });
    }
    this.setFilterResult(this.filterResult || this._calcFilterResult());
    $(document).on('click', this._docClickHandler = function () {
      return _this.popupLocked || _this._popup(false);
    });

    if (this.ready) {
      this.ready(this);
    }
  },

  $afterDestroy: function $afterDestroy() {
    $(document).off('click', this._docClickHandler);
  },

  /**
   *  filterOptions 
   * */
  _calcFilterResult: function _calcFilterResult(changeTarget) {
    // 
    if (this.filterOptions) {
      var result = [];
      var singleMode = this.singleMode;
      this.filterOptions.forEach(function (option, index, options) {
        if (singleMode && changeTarget) {
          if (option.value == changeTarget.value && option.checked) {
            result.push(option.value);
          } else if (option.checked) {
            options.$set(index, { checked: false });
          }
        } else if (option.checked) {
          result.push(option.value);
        }
      });

      //  null
      if (result.length) {
        return result;
      }
    }
    return null;
  },

  /**
   *  - 
   * */
  _updateCheckAllState: function _updateCheckAllState() {
    var filterResult = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

    if (this.filterOptions) {
      // 
      var hasChecked = filterResult && filterResult.length > 0;
      var allChecked = filterResult && this.filterOptions.length == filterResult.length;
      this.$replace('hasChecked', hasChecked);
      this.$replace('allChecked', allChecked);
    }
  },

  /**
   * checkbox 
   * */
  _checkAllChange: function _checkAllChange(allChecked) {
    var options = this.filterOptions;

    if (options) {
      for (var i = 0; i < options.length; i++) {
        options.$set(i, {
          checked: allChecked
        });
      }
    }

    this._filterOptionChange();
  },

  _filterOptionChange: function _filterOptionChange(changeTarget) {
    var filterResult = this._calcFilterResult(changeTarget);
    if (this.response == 'immediate') {
      this.setFilterResult(filterResult);
    }
    this._updateCheckAllState(filterResult);
  },

  _confirmFilter: function _confirmFilter() {
    this.setFilterResult(this._calcFilterResult());
    this._popup(false);
  },

  _cancelFilter: function _cancelFilter() {
    this.setFilterResult(this.filterResult);
    this._updateCheckAllState(this.filterResult);
    this._popup(false);
  },

  _clearFilter: function _clearFilter() {
    this.setFilterResult(null);
    this._popup(false);
  },

  _popup: function _popup(value) {
    this.$set('ui.popup', value);
  },

  _stopPropagation: function _stopPropagation(e) {
    e.stopPropagation();
  },

  _togglePopup: function _togglePopup(e) {
    var _this2 = this;

    this._popup(!this.ui.popup);
    this.popupLocked = true;
    setTimeout(function () {
      return _this2.popupLocked = false;
    }, 1);
  },

  _getFilterTitle: function _getFilterTitle() {
    var selectedLabel = [];
    this.filterOptions.forEach(function (option) {
      if (option.checked) {
        selectedLabel.push(option.label);
      }
    });
    return selectedLabel.length ? this.col.name + '' + selectedLabel.join('') : this.col.name + '';
  },

  _isSameArray: function _isSameArray(a, b) {
    return JSON.stringify(a) == JSON.stringify(b);
  },

  _searchOptions: function _searchOptions(options, keyword) {
    keyword = keyword && keyword.toLowerCase();
    return this.search && keyword ? options.filter(function (option) {
      return option.label && option.label.toLowerCase().indexOf(keyword) > -1;
    }) : options;
  },

  setFilterResult: function setFilterResult(result) {
    var options = this.filterOptions;

    if (options) {

      for (var i = 0; i < options.length; i++) {
        var checked = result ? result.indexOf(options[i].value) > -1 : false;
        options.$set(i, {
          checked: checked
        });
      }
    }

    if (!this._isSameArray(this.filterResult, result)) {
      this.$replace('filterResult', result);
    }
  }
}, { defaults: defaults });

module.exports = GridViewHeaderFilter;

},{"../componentBase":1,"beejs":27}],5:[function(_dereq_,module,exports){
//

'use strict';


var tpl = "<div data-role=\"grid-view\" b-style=\"style\" b-on=\"events\">\r\n  <div data-grid-panel class=\"tc-15-table-panel\" b-on=\"$events\">\r\n    <div data-grid-head class=\"tc-15-table-fixed-head\" style=\"width:auto\"\r\n      b-style=\"{paddingRight: _hasYScroll ? scrollBarSize : 0, display: showHeader ? 'block' : 'none'}\">\r\n      <table b-ref=\"head\" class=\"tc-15-table-box\" style=\"min-width: 100%\">\r\n        <colgroup>\r\n          <col b-if=\"hasFirst\" b-style=\"{width: firstColWith}\">\r\n          <col b-repeat=\"col in shownColums\"\r\n            data-locked-col?=\"col.locked\"\r\n            class=\"{{col.colClassName}}\"\r\n            b-style=\"{width: col.width || 'auto', minWidth: col.minWidth}\">\r\n        </colgroup>\r\n        <thead>\r\n          <tr>\r\n            <th b-if=\"hasFirst\">\r\n              <div class=\"tc-15-first-checkbox\">\r\n                <input type=\"checkbox\" b-model=\"ischeckAll\" data-check-all class=\"tc-15-checkbox\">\r\n              </div>\r\n            </th>\r\n            <th b-repeat=\"col in shownColums\"\r\n                class=\"text-{{col.align || 'left'}}\"\r\n                data-locked-th?=\"col.locked\"\r\n                data-orderfield=\"{{col.orderField || col.key}}\">\r\n              <div>\r\n                <span b-content=\"_getHeadContent(col)\"></span>\r\n              </div>\r\n              <i class=\"resize-line-icon\" data-role=\"resizer\"\r\n                b-if=\"canResizeColum && col.resize !== false && $index < shownColums.length - lockedColums.length - 1\"></i>\r\n            </th>\r\n          </tr>\r\n        </thead>\r\n      </table>\r\n    </div>\r\n    <div b-on-scroll=\"_synScroll()\" data-grid-body class=\"tc-15-table-fixed-body\"\r\n      b-style=\"{minHeight: minHeight,height:height, maxHeight: maxHeight}\">\r\n      <table b-ref=\"body\" style=\"min-width:100%\" class=\"tc-15-table-box tc-15-table-rowhover\">\r\n        <colgroup>\r\n          <col b-if=\"hasFirst\" b-style=\"{width: firstColWith}\">\r\n          <col b-repeat=\"col in shownColums\" data-locked-col?=\"col.locked\" class=\"{{col.colClassName}}\" b-style=\"{width: col.width || 'auto'}\">\r\n        </colgroup>\r\n        <tbody>\r\n          <tr b-if=\"canSelectTotal\" style=\"display:none\" data-select-total>\r\n            <td class=\"tc-15-news-tips-box\" colspan=\"{{countCols(colums)}}\">\r\n                <div b-if=\"!isSelectTotal\" class=\"text-center\"><span class=\"text\">{{selectedNum}}, </span><a data-select-total-toggle href=\"javascript:;\">{{totalNum}}</a></div>\r\n                <div b-if=\"isSelectTotal\" class=\"text-center\"><span class=\"text\">{{totalNum}}, </span><a data-select-total-toggle href=\"javascript:;\">{{selectedNum}}</a></div>\r\n            </td>\r\n          </tr>\r\n          <tr data-tips b-if=\"_tips\">\r\n            <td class=\"text-center\" colspan=\"{{countCols(colums)}}\">\r\n                <div>{{> _tips }}</div>\r\n            </td>\r\n          </tr>\r\n          <tr data-search-tips b-if=\"searchKey\">\r\n            <td class=\"text-center\" colspan=\"{{countCols(colums)}}\">\r\n                <div b-if=\"totalNum\"><span class=\"text\">\"{{searchKey}}\"{{totalNum}}</span><a data-restore href=\"javascript:;\"></a></div>\r\n                <div b-if=\"!totalNum\"><span class=\"text\">{{ searchItemName }}</span><a data-restore href=\"javascript:;\"></a></div>\r\n            </td>\r\n          </tr>\r\n          <tr data-index=\"{{$index}}\" track-by=\"{{trackKey}}\" b-ref=\"list\" b-repeat=\"item in list\"\r\n            b-attr=\"setTrAttr(trAttr, item)\"\r\n            class=\"item-row {{selectedHighlight && item.$selected ? 'current' : ''}}\r\n              {{item.$disable ? 'disable': ''}} {{item.$class || ''}}\">\r\n            <td b-if=\"hasFirst\">\r\n              <div class=\"tc-15-first-checkbox\">\r\n                <i b-if=\"item.$loading\" class=\"n-loading-icon\"></i>\r\n                <input class=\"tc-15-checkbox\" disabled?=\"item.$disable || item.$disableCheckbox\"\r\n                  data-checkbox\r\n                  b-if=\"!item.$loading\" type=\"checkbox\" b-model=\"item.$selected\">\r\n              </div>\r\n            </td>\r\n            <td b-repeat=\"col in shownColums\"\r\n                class=\"text-{{col.align || 'left'}}\">\r\n              <div>\r\n                <span b-content=\"_getCellContent(item[col.key], item, col)\"></span>\r\n              </div>\r\n            </td>\r\n          </tr>\r\n          <tr data-tips b-if=\"bottomTips\">\r\n            <td class=\"text-center\" colspan=\"{{countCols(colums)}}\">\r\n                <div>{{> bottomTips }}</div>\r\n            </td>\r\n          </tr>\r\n        </tbody>\r\n      </table>\r\n    </div>\r\n\r\n    <!--  -->\r\n      <div data-locked b-if=\"lockedColums.length\" class=\"fixed-column\"\r\n        b-class=\"{'fixed-column-shadow': '_hasXScroll'}\"\r\n        style=\"opacity:1; right: 0px; top: 0px;\"\r\n        b-style=\"{width: _hasYScroll ? (lockedWidth + scrollBarSize) : lockedWidth}\">\r\n          <div data-grid-head class=\"tc-15-table-fixed-head\" style=\"width: auto\"\r\n            b-style=\"{paddingRight: _hasYScroll ? scrollBarSize : 0}\">\r\n              <table class=\"tc-15-table-box\">\r\n                <colgroup>\r\n                  <col b-repeat=\"col in lockedColums\" class=\"{{col.colClassName}}\" b-style=\"{width: col.width || 'auto'}\">\r\n                </colgroup><thead>\r\n                  <tr>\r\n                      <th b-repeat=\"col in lockedColums\"\r\n                          data-orderfield=\"{{col.orderField || col.key}}\">\r\n                        <div>\r\n                          <span b-content=\"_getHeadContent(col)\"></span>\r\n                        </div>\r\n                        <!-- <i class=\"resize-line-icon\" data-role=\"resizer\" b-if=\"canResizeColum && $index < lockedColums.length - 1\"></i> -->\r\n                      </th>\r\n                  </tr>\r\n                </thead></table>\r\n          </div>\r\n          <!-- ie 8  max-height  -->\r\n          <div data-grid-body  b-on-scroll=\"__synScroll()\" class=\"tc-15-table-fixed-body\"\r\n            style=\"border-bottom: none;overflow-x:hidden\"\r\n            b-style=\"{\r\n              minHeight: _hasXScroll && _ie != 8 ? minHeight - scrollBarSize : minHeight,\r\n              height: _hasXScroll && _ie != 8 ? height - scrollBarSize : height,\r\n              maxHeight: _hasXScroll && _ie != 8 ? maxHeight - scrollBarSize : maxHeight\r\n            }\">\r\n              <table class=\"tc-15-table-box tc-15-table-rowhover\">\r\n                <colgroup>\r\n                  <col b-repeat=\"col in lockedColums\" class=\"{{col.colClassName}}\" b-style=\"{width: col.width || 'auto'}\">\r\n                </colgroup>\r\n                <tbody>\r\n                  <tr data-select-total b-if=\"canSelectTotal\" style=\"display:none\">\r\n                    <td class=\"tc-15-news-tips-box\" colspan=\"{{lockedColums.length}}\"></td>\r\n                  </tr>\r\n                  <tr data-tips b-if=\"_tips\">\r\n                    <td class=\"text-center\" colspan=\"{{lockedColums.length}}\"></td>\r\n                  </tr>\r\n                  <tr data-search-tips b-if=\"searchKey\">\r\n                    <td class=\"text-center\" colspan=\"{{lockedColums.length}}\"></td>\r\n                  </tr>\r\n                  <tr data-index=\"{{$index}}\" track-by=\"{{trackKey}}\" b-ref=\"lockedList\" b-repeat=\"item in list\"\r\n                    b-attr=\"setTrAttr(trAttr, item)\"\r\n                    class=\"item-row {{selectedHighlight && item.$selected ? 'current' : ''}}\r\n                      {{item.$disable ? 'disable': ''}} {{item.$class || ''}}\">\r\n                    <td b-repeat=\"col in lockedColums\">\r\n                      <div>\r\n                        <span b-content=\"_getCellContent(item[col.key], item, col)\"></span>\r\n                      </div>\r\n                    </td>\r\n                  </tr>\r\n                  <tr data-tips b-if=\"bottomTips\">\r\n                    <td class=\"text-center\" colspan=\"{{lockedColums.length}}\">\r\n                    </td>\r\n                  </tr>\r\n              </tbody></table>\r\n          </div>\r\n      </div>\r\n  </div>\r\n\r\n  <div data-pager class=\"tc-15-page\" b-if=\"showState || showPagination\">\r\n    <div class=\"tc-15-page-state\" b-if=\"showState\">\r\n      <span class=\"tc-15-page-text\"><span b-template b-if=\"hasFirst\">&nbsp;<strong>{{selectedNum}}</strong>&nbsp;</span>&nbsp;<strong>{{totalNum}}</strong>&nbsp;</span>\r\n    </div>\r\n    <div b-tag=pagination b-ref=\"pager\" b-if=\"showPagination\" b-with='{listFn: listFn.bind(this), page: page, count: count, totalNum: totalNum, demo: demo, keyword: keyword,\r\n      pageInterval: pageInterval,\r\n      countInterval: countInterval,\r\n      minCount: minCount,\r\n      maxCount: maxCount,\r\n      loading: loading\r\n      }'></div>\r\n  </div>\r\n</div>\r\n";
var Bee = _dereq_('beejs');
var Base = _dereq_('../componentBase');
var Pagenation = _dereq_('../pagination');
var getScrollBarSize = _dereq_('./lib/scroll-bar-size').getScrollBarSize;
var getWidthWithoutScroll = _dereq_('./lib/scroll-bar-size').getWidthWithoutScroll;

/**
 * @namespace $data
 * @property {Boolean} hasFirst=true 
 */
var defaults = {
  //
  hasFirst: true, //
  firstColWith: '50px', //
  selectedHighlight: true, //

  //
  canSelectTotal: false, //
  isSelectTotal: false, //

  canResizeColum: true, //
  colMinWidth: 100, //

  maxHeight: 'auto', //,  `autoMaxHeight`  true 
  height: 'auto', //
  minHeight: 350, //

  autoMaxHeight: true, //
  maxHeightOffset: 1, //

  //
  orderField: '', //
  order: 1, //

  //
  showPagination: true, //
  count: 20, //. ,  `getData` 
  page: 1, //
  totalNum: 0, //

  showState: true, //("xxx")
  showHeader: true, //

  shownColums: [], //
  colums: [], ///

  list: [], //

  trackKey: '', //. .  id 

  trAttr: {}, //.

  emptyTips: '',
  searchKey: '', //
  searchItemName: '', //. 
  searchEmptyTips: '',
  bottomTips: '', //

  initGetData: true, //
  loading: false, //

  scrollBaseSize: 0,

  _ie: Bee.utils.ie
};

/**
 * GridView
 * @constructor GridView
 */
var GridView = Base.extend(
/**
* @lends GridView.prototype
*/
{
  $tpl: tpl,
  $afterInit: function $afterInit() {
    var _this = this;

    GridView.__super__.$afterInit.call(this);

    this._$el = $(this.$el);
    this.$gridHead = this._$el.find('[data-grid-head]');
    this.$gridBody = this._$el.find('[data-grid-body]');

    this.$set('scrollBarSize', getScrollBarSize('def-scoll'));
    this.bindEvent();
    this.autoMaxHeight && this.setMaxHeight();

    setTimeout(function () {
      return _this.initGetData && _this.listFn();
    }, 0);
  },

  /**
  * @property {String} actionKey='_action'  key
  */
  actionKey: '_action',
  /**
  * @property {String} actionTpl .  `getCellContent` 
  */
  actionTpl: '<span class="text-overflow"><a href="javascript:;" class="links"></a></span>',

  extraParam: {}, // `getData` 

  offsetHeight: 0, //

  //
  countCols: function countCols(colums) {
    var colSize = colums.filter(function (col) {
      return !col.hide;
    }).length;

    return colSize + !!this.$root.hasFirst;
  },
  // tr 
  setTrAttr: function setTrAttr(obj, item) {
    var attr = {};
    for (var key in obj) {
      attr[key] = item[obj[key]];
    }
    return attr;
  },
  //
  getData: function getData(opts, callback) {
    //console.log('')
  },

  refresh: function refresh(cb) {
    cb = cb || function () {};

    this.listFn(this.latestParam, cb);
  },

  //
  listFn: function listFn(opts, cb) {
    var param = $.extend({}, this.$data, opts);
    var that = this;
    cb = cb || function () {};

    if (this.loading) {
      return;
    }
    this.$set('loading', true);

    this.latestParam = $.extend({}, this.extraParam, {
      orderField: param.orderField,
      order: param.order,

      page: param.page,
      count: param.count,
      searchKey: param.searchKey
    });
    var res = this.getData(this.latestParam, function () {
      that.$dataCallback.apply(that, arguments);

      that.$set('loading', false);
      cb();
    });

    if (res && res.then) {
      return res.then(function (data) {
        that.$set('loading', false);
        return that.dataCallback(data);
      }, function (err) {
        that.$set('loading', false);
        return that.errorCallback(err);
      });
    } else {
      return res;
    }
  },

  dataCallback: function dataCallback(data) {},
  errorCallback: function errorCallback(data) {},

  // `extraParam`
  setExtraParam: function setExtraParam(extraParam) {
    this.extraParam = extraParam || {};
  },

  /**
  * 
  * @param {Array} data.list 
  * @param {Number} data.totalNum 
  * @param {String} [data.searchKey] 
  */
  setData: function setData(data) {
    this.$emit && this.$emit('gridUpdate');
    this.$checkAll(false);
    this.list.forEach(function (item, i, arr) {
      arr.$set(i, { $selected: false });
    });

    var opts = $.extend(true, { loading: false }, this.latestParam, data);

    this.hideTips();
    if (!opts.searchKey && !opts.list.length) {
      this.showTips(this.emptyTips);
    }

    //var t1 = Date.now()
    this.$set(opts);
    //console.log('setDataTime: ' + (Date.now() - t1))
    this.autoMaxHeight && this.setMaxHeight();
  },
  /**
  * 
  */
  setColums: function setColums(colums) {
    this.$replace('colums', colums);
  },

  /**
  * 
  */
  updateItem: function updateItem(index, item) {
    //this.list.$set(index, item)
    this.$refs.list[index].$set(item);
    this.$refs.lockedList && this.$refs.lockedList[index].$set(item);
  },

  /**
  * 
  */
  removeItem: function removeItem(index) {
    this.list.splice(index, 1);
  },

  //
  //: `getHeadContent` > `col.thTpl` > 
  _getHeadContent: function _getHeadContent(col) {
    var tpl;
    tpl = this.$root.getHeadContent(col) || col.thTpl;
    if (!tpl) {
      tpl = '<span b-if="col.order" data-order class="tc-15-th-sort-btn {{orderField === (col.orderField || col.key) ? \'current\': \'\'}}">\n          <span class="text-overflow" title="{{col.name}}">{{col.name}}</span>\n          <i class="{{orderField === (col.orderField || col.key) ? (order == 0 ? \'down-sort-icon\' : \'up-sort-icon\') : \'sort-icon\'}}"></i>\n        </span>\n        <span b-if="!col.order" class="text-overflow" title="{{col.name}}">{{col.name}}</span>';
    }
    return tpl;
  },
  /**
  * . 
  * @param {Object} col 
  * @returns {String}  html 
  */
  getHeadContent: function getHeadContent(col) {},
  //: `getCellContent` > `col.tdTpl` > 
  _getCellContent: function _getCellContent(val, item, col) {
    var tpl = this.$root.getCellContent(val, item, col) || col.tdTpl;
    if (!tpl) {
      if (col.key === this.actionKey) {
        tpl = typeof this.actionTpl === 'function' ? this.actionTpl(item, col) : this.actionTpl;
      } else {
        tpl = '<span class="text-overflow" title="{{col.name}}{{item[col.key]}}">\n         {{(typeof item[col.key] === "undefeind" || item[col.key] === "") ? "-" : item[col.key]}}</span>';
      }
    }
    return tpl;
  },
  /**
  * . , 
  * @param {*} val 
  * @param {Object} item 
  * @param {Object} col 
  * @returns {String}  html 
  */
  getCellContent: function getCellContent(val, item, col) {},
  showLoading: function showLoading(text, hideList) {
    text = text || '';
    this.showTips('<i class="n-loading-icon"></i> <span class="text">' + text + '</span>');
    if (hideList) {
      $(this.$el).find('tr.item-row').css({ opacity: 0.65, 'pointer-events': 'none' });
    }
  },
  hideLoading: function hideLoading() {
    $(this.$el).find('tr[data-tips] i.n-loading-icon').length && this.hideTips();
    $(this.$el).find('tr.item-row').css({ opacity: 1, 'pointer-events': 'all' });
  },
  //
  showTips: function showTips(content) {
    this.$set('_tips', content);
  },
  //
  hideTips: function hideTips() {
    this.$set('_tips', '');
  },

  //
  showSelectAllTips: function showSelectAllTips(tr) {
    $(tr).show();
  },
  hideSelectAllTips: function hideSelectAllTips(tr) {
    $(tr).hide();
  },
  //
  getSelected: function getSelected() {
    return this.list.filter(function (item) {
      return item.$selected;
    });
  },

  //
  setMaxHeight: function setMaxHeight() {
    var $gridFooter = this._$el.find('[data-pager]');

    var maxHeight = $(window).height() - (this.$gridHead.outerHeight() + $gridFooter.outerHeight() + 40) - this.$gridHead.offset().top - this.maxHeightOffset;

    // if(this.$gridBody.width() < $(this.$refs.body).width()) {
    //   maxHeight -= this.scrollBarSize;
    // }
    if (this._$el.filter(':visible').length) {
      this.$set({
        maxHeight: maxHeight
      });
      this._$el.find('[data-grid-panel]').css('height', this.$gridBody.outerHeight() + this.$gridHead.outerHeight());

      //
      //ie 8  max-height 
      this.$set({
        _hasYScroll: this.$gridBody[0].scrollHeight > this.$gridBody[0].clientHeight,
        _hasXScroll: this.$gridBody[0].scrollWidth > this.$gridBody[0].clientWidth
      });
    }
  },

  checkWidth: function checkWidth() {
    var hasAuto = false;
    this.$gridHead.find('col').each(function () {
      if (this.style.width == 'auto') {
        hasAuto = true;
      }
    });

    if (!hasAuto) {
      this.$lastCol.width('auto');
    }

    $(this.$refs.head).add($(this.$refs.body)).width('');
    this.checkCellWidth();
  },

  //, 
  checkCellWidth: function checkCellWidth() {
    var _this2 = this;

    var tableWidth;
    var $ths = this.$gridHead.find('th');

    //
    if (!this._$el.is(':visible') || !this.showHeader) {
      return;
    }

    // if(!this.canResizeColum) {
    //   return;
    // }

    var autoThs = [];
    $ths.each(function (i, th) {
      var $th = $(th);
      var width = $th.width();

      //
      if (_this2.hasFirst && i == 0) {
        return;
      }

      var col = _this2.getColByIndex(i);
      var minWidth = col.minWidth || _this2.colMinWidth;

      if (minWidth > width) {
        _this2.setCellWidth(i, width);
      }
      if (!col.width || col.width == 'auto') {
        autoThs.push({ $th: $th, col: col, i: i });
      }
    });

    autoThs.forEach(function (item) {
      var width = item.$th.width();
      var minWidth = item.col.minWidth || _this2.colMinWidth;

      if (minWidth > width) {
        _this2.setCellWidth(item.i, width);
      }
    });

    tableWidth = $(this.$refs.head).width();

    // 100% , .
    if (tableWidth > this.$gridHead.width()) {
      $(this.$refs.head).width(tableWidth);
      $(this.$refs.body).width(tableWidth);
    }

    var lockedWidth = 0;
    $ths.filter('[data-locked-th]').each(function (i, th) {
      var width = $(th).width();
      //
      lockedWidth += width;
    });
    this.$set('lockedWidth', lockedWidth);
  },

  //
  //
  resize: function resize() {
    this.checkCellWidth();
    if (this.autoMaxHeight) {
      this._$el.is(':visible') && this.setMaxHeight();
    }

    if (this.resizeAutoWidth) {
      this.$lastCol.width('auto');
    }
  },

  /**
  * . 
  */
  backList: function backList() {
    this.listFn({
      page: 1,
      count: this.count,

      order: this.order,
      orderField: this.orderField,
      searchKey: false
    });
  },

  bindEvent: function bindEvent() {
    var _this3 = this;

    this.$watch('colums', function () {
      var shownColums = this.colums.filter(function (col) {
        return !col.hide;
      }); //

      this.$set({
        shownColums: shownColums,
        lockedColums: shownColums.filter(function (col) {
          return col.locked;
        })
      });

      this.$locked = this._$el.find('[data-locked]');
      this.$lockedHead = this.$locked.find('[data-grid-head]');
      this.$lockedBody = this.$locked.find('[data-grid-body]');

      this._setLastCol();
      this.checkWidth();
      this.autoMaxHeight && this.setMaxHeight();
    }, true);

    this.$watch('list', function () {
      return _this3.$checkAll();
    });

    this.$watch('list.length', function (length) {
      if (!_this3.searchKey) {
        if (!length) {
          _this3.showTips(_this3.emptyTips);
        } else {
          if (_this3._tips == _this3.emptyTips) {
            _this3.hideTips();
          }
        }
      }
    });

    this.$watch('getSelected(list).length', function (length) {
      length = this.getSelectedLength ? this.getSelectedLength() : length;
      this.$set('selectedNum', length);
    });

    this.$watch('ischeckAll', function (val) {
      val || this.$set('isSelectTotal', false);
    }, true);

    $(window).on('resize', function () {
      _this3.resize();
    });

    // hover
    this._$el.on('mouseenter mouseleave', '[data-grid-body]>table>tbody>tr, [data-locked] [data-grid-body]>table>tbody>tr', function (e) {
      if (_this3.lockedColums.length) {
        var $tr = $(e.currentTarget);
        var index = $tr.index();
        var action = e.type === 'mouseenter' ? 'addClass' : 'removeClass';

        _this3._$el.find('[data-grid-body]>table>tbody>tr').eq(index)[action]('tr-hover');
        _this3._$el.find('[data-locked] [data-grid-body]>table>tbody>tr').eq(index)[action]('tr-hover');
      }
    });
  },
  $events: {
    //
    'click th [data-order]': function clickThDataOrder(e) {
      var orderField = $(e.currentTarget).closest('th').attr('data-orderfield');
      var order;
      var that = this;
      if (orderField === this.orderField) {
        order = 1 - this.order;
      } else {
        order = 1;
      }

      this.listFn({ orderField: orderField, order: order });
    },

    //
    'mousedown [data-role=resizer]': function mousedownDataRoleResizer(e) {
      if (!$(e.currentTarget).closest('[data-grid-panel]').is(e.delegateTarget)) {
        //
        return;
      }

      var index = $(e.currentTarget).closest('th').index();
      this.__draging = true;
      this.__dragingIndex = index;
      this.__$col = $(this.$el).find('[data-grid-body] col').eq(index).add($(this.$el).find('[data-grid-head] col').eq(index));
      this.__originlWidth = $(e.currentTarget).closest('th').width();
      this.__lastWidth = this.__originlWidth;
      this.__originalX = e.clientX;
      e.preventDefault();
      this._dragEventBind();
      $('body').css('cursor', 'e-resize');
      //this._$el.find('.tc-table-fixed-body').css('overflow', 'hidden')
    },

    //
    'change [data-check-all]': function changeDataCheckAll(e) {
      var _this4 = this;

      var checked = e.target.checked;
      this.list.forEach(function (item, i, arr) {
        if (!item.$disable && !item.$loading && !item.$disableCheckbox) {
          _this4.updateItem(i, { $selected: checked });
        }
      });

      //, 
      if (!this.list.filter(function (item) {
        return item.$disable || item.$loading || item.$disableCheckbox;
      }).length) {
        var tr = this._$el.find('[data-select-total]');
        checked ? this.showSelectAllTips(tr) : this.hideSelectAllTips(tr);
      }
    },

    // bee.js b-repeat . 
    'change input:checkbox[data-checkbox]': function changeInputCheckboxDataCheckbox(e) {
      if (this.lockedColums.length) {
        var index = $(e.target).closest('tr').attr('data-index');
        var selected = e.target.selected;
        this.updateItem(index, {
          $selected: selected
        });
      }
    },

    //
    'click a[data-restore]': function clickADataRestore() {
      this.backList();
    },

    //
    'click [data-select-total-toggle]': function clickDataSelectTotalToggle() {
      var selectTotal = !this.isSelectTotal;
      this.$set('isSelectTotal', selectTotal);
    }
  },

  //
  _synScroll: function _synScroll() {
    $(this.$refs.head).css({ left: -this.$gridBody[0].scrollLeft });

    if (this.lockedColums.length) {
      if (this._lastScrollTop === undefined || this._lastScrollTop == this.$lockedBody[0].scrollTop || this._lastScrollTop && this.$lockedBody[0].scrollTop == 0) {
        this._lastScrollTop = this.$lockedBody[0].scrollTop = this.$gridBody[0].scrollTop;
      }
    }
    clearTimeout(this.gridtimer);
    this.gridtimer = setTimeout(this.checkScroll.bind(this, 'grid'), 20);
  },
  __synScroll: function __synScroll() {
    if (this._lastScrollTop === undefined || this._lastScrollTop == this.$gridBody[0].scrollTop || this._lastScrollTop && this.$lockedBody[0].scrollTop == 0) {
      this._lastScrollTop = this.$gridBody[0].scrollTop = this.$lockedBody[0].scrollTop;
    }
    clearTimeout(this.gridtimer);
    this.gridtimer = setTimeout(this.checkScroll.bind(this, 'lock'), 20);
  },
  checkScroll: function checkScroll(flag) {
    if (!this.$lockedBody.length) {
      return;
    }
    if (flag == 'grid') {
      this._lastScrollTop = this.$lockedBody[0].scrollTop = this.$gridBody[0].scrollTop;
    } else {
      this._lastScrollTop = this.$gridBody[0].scrollTop = this.$lockedBody[0].scrollTop;
    }
  },
  _dragEventBind: function _dragEventBind() {
    var that = this;
    $(document).off('mouseup.grid_view').on('mouseup.grid_view', function () {
      //
      if (that.__draging) {
        that.__draging = false;

        $(this).off('mousemove.grid_view');
        $('body').css('cursor', '');
        //that._$el.find('.tc-table-fixed-body').css('overflow', '')

        delete that.__$col;
        delete that.__lastWidth;
        delete that.__dragingIndex;
        that.autoMaxHeight && that.setMaxHeight();
      }
    }).on('mousemove.grid_view', function (e) {
      //
      var offset, width, curGridWidth;
      if (that.__draging) {
        offset = e.clientX - that.__originalX;
        width = that.__originlWidth * 1 + offset;

        that.setCellWidth(that.__dragingIndex, width);

        e.preventDefault();
      }
    });
  },

  //
  setCellWidth: function setCellWidth(index, width) {
    var col = this.getColByIndex(index);
    var minWidth = col.minWidth || this.colMinWidth;
    var lastMinWidth = this.shownColums[this.shownColums.length - this.lockedColums.length - 1].minWidth || this.colMinWidth;

    if (width < minWidth) {
      width = minWidth;
    }
    var curGridWidth = $(this.$refs.body).width();
    var $col = this.__$col || this.$gridHead.find('col').eq(index).add(this.$gridBody.find('col').eq(index));

    var lastWidth = this.__lastWidth;
    var offset = width - lastWidth;

    var curLastColWidth = this.$gridHead.find('th:not([data-locked-th]):last').width();

    //

    if (offset < 0 && $(this.$refs.head).width() > this.$gridHead.width() || offset > 0 && curLastColWidth - offset <= lastMinWidth) {
      $(this.$refs.head).width(curGridWidth + offset);
      $(this.$refs.body).width(curGridWidth + offset);
    } else {
      if (offset < 0 || curLastColWidth - offset > lastMinWidth) {
        this.$lastCol.width(curLastColWidth - offset);
      }
    }

    $col.width(width);

    if (this.__lastWidth) {
      this.__lastWidth = width;
    }
  },

  //
  getColByIndex: function getColByIndex(index) {
    if (this.hasFirst) {
      index--;
    }
    return this.shownColums[index];
  },

  $checkAll: function $checkAll(checked) {
    var list = this.$get('list');
    var _checked;

    if (typeof checked !== 'boolean') {
      checked = !list.filter(function (item) {
        if (item.$selected) {
          _checked = true;
        }
        return !item.$selected && !item.$disable && !item.$loading && !item.$disableCheckbox;
      }).length && _checked;
    }
    this.$set('ischeckAll', checked);
    checked || this.$root.hideSelectAllTips(this._$el.find('[data-select-total]'));
  },
  $dataCallback: function $dataCallback(err, data) {
    if (err) {
      //TODO
    } else {
        this.setData(data);
      }
  },
  //html
  $getNoDataHtml: function $getNoDataHtml() {
    var noDataHtml = this.keyword ? this.searchNoData : this.filterNoData;
    return noDataHtml;
  },

  //
  _setLastCol: function _setLastCol() {
    this.$lastCol = this.$gridHead.find('col:not([data-locked-col]):last').add(this.$gridBody.find('col:not([data-locked-col]):last'));
  }
}, {
  defaults: defaults
});

module.exports = GridView;

},{"../componentBase":1,"../pagination":8,"./lib/scroll-bar-size":6,"beejs":27}],6:[function(_dereq_,module,exports){
//
"use strict";

exports.getScrollBarSize = function getScrollBarSize(className) {
  var inner = document.createElement('p');
  inner.style.width = "100%";
  inner.style.height = "200px";

  var outer = document.createElement('div');
  outer.style.position = "absolute";
  outer.style.top = "0px";
  outer.style.left = "0px";
  outer.style.visibility = "hidden";
  outer.style.width = "200px";
  outer.style.height = "150px";
  outer.style.overflow = "hidden";
  outer.className = className || '';
  outer.appendChild(inner);

  document.body.appendChild(outer);
  var w1 = inner.offsetWidth;
  outer.style.overflow = 'scroll';
  var w2 = inner.offsetWidth;
  if (w1 == w2) w2 = outer.clientWidth;

  document.body.removeChild(outer);

  return w1 - w2;
};

},{}],7:[function(_dereq_,module,exports){
'use strict';


var tpl = "<div data-role=\"input-slider\"  class=\"num\" b-on=\"$events\" style=\"display:inline-block\" b-style=\"style\">\n  <span class=\"number-input-decoration\">\n    <input b-ref=\"input\" data-input b-model=\"value\" class=\"tc-input-text\" type=\"text\">\n    <span class=\"arrows\">\n        <a href=\"javascript:;\" data-down>\n            <i class=\"sequence\"></i>\n        </a>\n        <i class=\"line\"></i>\n        <a href=\"javascript:;\" data-up>\n            <i class=\"sequence desc\"></i>\n        </a>\n    </span>\n  </span>\n  <div b-ref='slider' class=\"ui_progress\" style=\"display:none\">\n    <div class=\"progress_area\">\n        <div b-ref=\"sliderBar\" class=\"progress_bar\">\n            <div class=\"progress_bg\">\n                <div class=\"progress_in\"\n                  b-style=\"{width: Math.max(0, Math.min(100, ((value - min) / (max - min)) * 100)) + '%'}\">\n                </div>\n                <a data-handler href=\"javascript:;\" class=\"btn_drag\"\n                   b-style=\"{left: Math.max(0, Math.min(100, ((value - min) / (max - min)) * 100)) + '%' }\"></a>\n            </div>\n        </div>\n    </div>\n  </div>\n</div>\n";
var Bee = _dereq_('beejs');
var SliderRange = _dereq_('../slider-range');

//InputSlider  Bee 
var InputSlider = SliderRange.extend({
  $tpl: tpl,

  showSlider: function showSlider() {
    $(this.$refs.slider).show();
  },

  hideSlider: function hideSlider() {
    $(this.$refs.slider).hide();
  },

  $events: {
    'click [data-input]': function clickDataInput(e) {
      this.showSlider();
      e.target.select();
    },
    'click [data-up]': function clickDataUp() {
      this.stepUp();
    },
    'click [data-down]': function clickDataDown() {
      this.stepDown();
    },
    'keydown': function keydown(e) {
      if (e.keyCode == 37 || e.keyCode == 40) {
        this.stepDown();
        e.preventDefault();
      } else if (e.keyCode == 38 || e.keyCode == 39) {
        this.stepUp();
        e.preventDefault();
      }
    }
  },
  $afterInit: function $afterInit() {
    InputSlider.__super__.$afterInit.call(this);
    var that = this;
    var $body = $('body');

    $body.on('click.slider_' + this.guid, function (e) {
      //
      if (e.target === that.$refs.slider || $(that.$refs.slider).find(e.target).length || e.target === that.$refs.input) {
        return;
      }
      that.hideSlider();
    });
  }
});

module.exports = InputSlider;

},{"../slider-range":21,"beejs":27}],8:[function(_dereq_,module,exports){
'use strict';


var tpl = "<div data-role=\"pagination\" class=\"tc-15-page-operate\" b-on=\"$events\">\n    <div b-template b-if=\"totalNum\">\n    <span class=\"tc-15-page-text\"></span>\n    <div class=\"tc-15-page-select\" data-page-select>\n        <a class=\"indent\" href=\"javascript:;\">{{count}}<span class=\"ico-arrow\"></span></a>\n        <ul data-list class=\"tc-15-simulate-option tc-15-def-scroll\">\n            <li data-count=\"{{c}}\" b-repeat=\"c in setCountList(totalNum)\">{{c}}</li>\n        </ul>\n    </div>\n    <a data-page=\"1\" class=\"tc-15-page-first {{page<=1?'disable':''}}\" title=\"\" href=\"javascript:;\"></a>\n    <a data-page=\"{{page-1}}\" class=\"tc-15-page-pre {{page<=1?'disable':''}}\" title=\"\" href=\"javascript:;\"></a>\n    <div class=\"tc-15-page-select\" data-page-select disable?='lastPage==1'>\n        <a class=\"tc-15-page-num\" href=\"javascript:;\">{{page}}/{{lastPage}}<span b-if=\"lastPage>1\" class=\"ico-arrow\"></span></a>\n        <ul class=\"tc-15-simulate-option tc-15-def-scroll\">\n            <li title=\"{{p}}\" data-page=\"{{p}}\" b-repeat=\"p in setPageList(totalNum, count)\">{{p}}</li>\n        </ul>\n    </div>\n    <a data-page=\"{{page*1+1}}\" class=\"tc-15-page-next {{page==lastPage?'disable':''}}\" title=\"\" href=\"javascript:;\"></a>\n    <a data-page=\"{{lastPage}}\" class=\"tc-15-page-last {{page==lastPage?'disable':''}}\" title=\"\" href=\"javascript:;\"></a>\n    </div>\n</div>\n";
var Bee = _dereq_('beejs');
var Base = _dereq_('../componentBase');

//Pagination  Base 
var Pagination = Base.extend({
  constructor: function constructor() {
    var that = this;
    Base.apply(this, arguments);

    this.bindEvent();
  },
  $beforeInit: function $beforeInit() {
    Pagination.__super__.$beforeInit.call(this);
    this.originalCount = this.count;
  },
  $tpl: tpl,

  //
  $data: {
    pageInterval: 1,
    countInterval: 5,
    minCount: 10,
    maxCount: 50,

    totalNum: 0, //.
    page: 1, //.
    count: 20, //.

    lastPage: 1,
    demo: false
  },

  selectedClass: 'tc-15-page-selected',

  //.  page  count
  listFn: function listFn() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    //this.$set(opts)
    console.log(opts);
    console.log('');
  },

  _listFn: function _listFn(opts) {
    var _this = this;

    if (!this.loading) {
      this.loading = true;
      this.listFn(opts, function () {
        _this.loading = false;
      });
    }
  },

  listToggle: function listToggle($box, type) {
    if (type !== false) {
      type = !$box.hasClass(this.selectedClass);
    }
    if (type) {
      $box.addClass(this.selectedClass);
      $box.children('[data-list]').show();
    } else {
      $box.removeClass(this.selectedClass);
      $box.children('[data-list]').hide();
    }
  },

  setPageList: function setPageList(totalNum, count) {
    var page = 1;
    var arr = [];
    var max = Math.ceil(totalNum / count);

    while (page <= max) {
      arr.push(page);
      page += this.pageInterval;
    }
    this.$set({ 'lastPage': max, page: Math.min(this.page || 1, max) });
    return arr.reverse();
  },

  //
  setCountList: function setCountList(totalNum) {
    var a = [];
    var count = this.minCount * 1;

    //
    //30,  10
    while (count <= Math.max(this.minCount * 1, Math.min(this.maxCount * 1, totalNum * 1 + this.countInterval * 1 - 1), this.originalCount)) {
      a.push(count);
      count += this.countInterval * 1;
    }

    return a.reverse();
  },

  bindEvent: function bindEvent() {
    var that = this;
    $(document).on('click', function (e) {
      var $box = $(that.$el).find('[data-page-select]');
      that.listToggle($box.not(e.target).not($(e.target).closest('[data-page-select]')), false);
    });
  },
  $events: {
    'click [data-page-select]:not([disable]) a': function clickDataPageSelectNotDisableA(e) {
      //if(this.totalNum > this.count){
      this.listToggle($(e.currentTarget).parent());
      //}
    },
    'click [data-page]': function clickDataPage(e) {
      var $el = $(e.target);
      var page;

      if ($el.hasClass('disable')) {
        return;
      }
      page = $el.attr('data-page') * 1 || this.page;

      this.demo && this.$set({ page: page });

      this.listToggle($(e.target).closest('[data-page-select]'));

      this._listFn({
        page: page,
        count: this.count
      });
    },
    'click [data-count]': function clickDataCount(e) {
      var count = $(e.target).attr('data-count') * 1;
      this.demo && this.$set('count', count);
      this.listToggle($(e.target).closest('[data-page-select]'));
      this._listFn({
        page: 1, //, 
        count: count
      });
    }
  }
});

module.exports = Pagination;

},{"../componentBase":1,"beejs":27}],9:[function(_dereq_,module,exports){
//Beejs 

// `brfs`
'use strict';


var tpl = "<div data-role=\"qc-popover\" style=\"display:none;\" b-style=\"style\" class=\"tc-15-confirm-popout {{_getPosClass(position)}}\">\n    <div class=\"tc-15-confirm-popout-bd\">\n        <p class=\"tc-15-msg\"><strong>{{title}}</strong>\n          <br b-if=\"content\">\n          {{> content }}\n        </p>\n    </div>\n    <div class=\"tc-15-confirm-popout-ft\">\n        <button class=\"tc-15-btn m\" b-on-click=\"hide(true)\">{{confirmKey}}</button>\n        <button class=\"tc-15-btn m weak\" b-on-click=\"hide()\">{{cancelKey}}</button>\n    </div>\n</div>\n";
var Bee = _dereq_('beejs');
var QCPopover = _dereq_('../qc-popover');

var classes = {
  top: 'tc-15-confirm-popout-bottom',
  bottom: 'tc-15-confirm-popout-top',
  'top left': 'tc-15-confirm-popout-bottom align-end',
  'top right': 'tc-15-confirm-popout-bottom align-start',
  'bottom left': 'tc-15-confirm-popout-top align-end',
  'bottom right': 'tc-15-confirm-popout-top align-start'
};

var PopupConfirm = QCPopover.extend({
  $tpl: tpl,
  _getPosClass: function _getPosClass(position) {
    return classes[position] || '';
  },
  hide: function hide(isConfirm) {
    var _this = this;

    var result = isConfirm ? this.onConfirm() : this.onCancel();
    if (result === false) {
      return;
    }
    if (result && result.then) {
      result.then(function () {
        PopupConfirm.__super__.hide.call(_this);
      });
    } else {
      PopupConfirm.__super__.hide.call(this);
    }
  },
  /**
   * . 
   * @return {Boolean|Promise}  `true`  `resolved` Promise , 
   */
  onConfirm: function onConfirm() {},
  /**
   * 
   */
  onCancel: function onCancel() {}
}, {
  //
  defaults: {
    availablePos: ['top left', 'top right', 'top', 'bottom left', 'bottom right', 'bottom'],
    trigger: 'click',
    arrowPad: 30,
    confirmKey: '',
    cancelKey: '',
    style: 'width: auto',
    position: 'bottom left'
  }
});

PopupConfirm.bootFromAttr('popup-confirm');

module.exports = PopupConfirm;

},{"../qc-popover":15,"beejs":27}],10:[function(_dereq_,module,exports){
'use strict';


var tpl = "<button\n  b-on=\"$events\"\n  class=\"tc-15-btn m{{className ? ' ' + className : ''}}{{disabled ? ' disabled' : ''}}\"\n  tabindex=\"0\" b-attr=\"attr\">{{label}}\n</button>\n";
var Bee = _dereq_('beejs');
var Base = _dereq_('../componentBase');
var Event = _dereq_('beejs/addons/event');

var QCActionButton = Base.extend({

  $tpl: tpl,

  $events: {
    'click': function click() {
      this._executeAction();
    }
  },

  _executeAction: function _executeAction() {
    if (this.disabled) return;
    if (typeof this.action == 'function') {
      this.action(this);
    }
    this.$emit('action', this.$data);
  },

  setEnable: function setEnable(enable) {
    this.$set('disabled', !enable);
  },

  enable: function enable() {
    this.setEnable(true);
  },

  disable: function disable() {
    this.setEnable(false);
  }
}, {
  defaults: {
    disabled: false,
    attr: {}
  }
});

module.exports = QCActionButton;

},{"../componentBase":1,"beejs":27,"beejs/addons/event":26}],11:[function(_dereq_,module,exports){
/**
 * @fileoverview
 *
 *  - 
 * */

'use strict';


var tpl = "<div class=\"tc-15-action-panel action-panel-root\" b-on=\"handle()\">\n  <div\n    b-repeat=\"widget in widgets\"\n    data-widget-type=\"{{widget.type}}\"\n    data-widget-name=\"{{widget.name}}\"\n    b-style=\"{ float: widget.float || 'left'}\">\n\n    <!-- widget type: date-picker -->\n    <div b-tag=\"qc-date-picker\" b-if=\"widget.type == 'date-picker'\" b-with=\"widget\"></div>\n\n    <!-- widget type: action -->\n    <div b-tag=\"qc-action-button\" b-if=\"widget.type == 'action'\" b-with=\"widget\">{{widget.label}}</div>\n\n    <!-- widget type: action-list -->\n    <div b-tag=\"qc-dropdown-list\" b-if=\"widget.type == 'action-list'\" b-with=\"widget\"></div>\n\n    <!-- widget type: seperator -->\n    <div b-if=\"widget.type == 'seperator'\" class=\"tc-15-v-sep\" role=\"separator\"></div>\n\n    <!-- widget type: filter-expander -->\n    <button\n      b-if=\"widget.type == 'filter-expander'\"\n      class=\"tc-15-btn weak m for-select{{widget.expand ? ' show' : ''}}\">{{widget.label}}\n    </button>\n\n    <!-- widget type: search -->\n    <div b-tag=\"qc-search\" b-if=\"widget.type == 'search'\" b-with=\"widget\"></div>\n\n    <!-- widget type: filter-panel -->\n    <div\n      b-if=\"widget.type == 'filter-panel'\"\n      b-style=\"{ display: widget.expand ? 'block' : 'none' }\"\n      class=\"tc-15-action-select-panle\">\n\n      <div class=\"param-line\" b-repeat=\"param in widget.params\" data-param=\"{{param.key}}\">\n        <strong>{{param.label}}</strong>\n        <p>\n          <span class=\"param-option\" data-role=\"select-all\">\n            <label>\n              <input type=\"checkbox\" class=\"tc-15-checkbox\" b-model=\"param.all\" />{{param.allLabel || ''}}\n            </label>\n          </span>\n          <span class=\"param-option\" b-repeat=\"option in param.options\">\n            <label>\n              <input type=\"checkbox\" class=\"tc-15-checkbox\" b-model=\"option.checked\" />{{option.label}}\n            </label>\n          </span>\n        </p>\n      </div>\n\n      <div class=\"tc-15-action-select-panle-btns\">\n        <button class=\"tc-15-btn m\" data-role=\"accept\"></button>\n        <button class=\"tc-15-btn m weak\" data-role=\"cancel\"></button>\n      </div>\n    </div>\n\n    <!-- widget type: filter-result-tag-list -->\n    <div\n      b-if=\"widget.type == 'filter-result-tag-list' && widget.visible && widget.result.length\"\n      class=\"tc-15-tag-list\">\n      <div class=\"tc-15-tag\" tabindex=\"0\"\n        b-repeat=\"param in widget.result\"\n        data-clear-param=\"{{param.key}}\">{{param.label}}{{param.optionsText}}\n        <span class=\"tc-15-btn-close\"></span>\n      </div>\n      <div class=\"tc-15-tag-clear\" data-role=\"clear-options\" role=\"button\" tabindex=\"0\" b-if=\"widget.result.length\"></div>\n    </div>\n  </div>\n</div>\n";
var Bee = _dereq_('beejs');
var Base = _dereq_('../componentBase');
var Event = _dereq_('beejs/addons/event');

_dereq_('../qc-action-button');
_dereq_('../qc-date-picker');
_dereq_('../qc-dropdown-list');
_dereq_('../qc-search');

var filterSessionStates = {};

//QcFilterPanel  Bee 
var QCActionPanel = Base.extend({
  $tpl: tpl,

  //
  $data: {
    widgets: []
  },

  findWidgetByName: function findWidgetByName(name) {
    var $wrapper = $(this.$el).find('div[data-widget-name="' + name + '"]');
    var $inner = $wrapper.children();

    var widgetBee = $inner.prop('bee');

    return widgetBee || $wrapper.prop('bee');
  },

  handle: function handle() {
    var handler = {};
    var selector = {
      'action-list-expand': 'click div[data-widget-type="action-list"] button.tc-15-simulate-select',
      'action-list-execute': 'click div[data-widget-type="action-list"] ul.tc-15-simulate-option li',
      'action-list-mask': 'click div.popup-mask',
      'search': 'click div[data-widget-type="search"] button.search',
      'filter-expand': 'click div[data-widget-type="filter-expander"]',
      'filter-option-change': 'change div[data-widget-type="filter-panel"] span.param-option',
      'filter-accept': 'click div[data-widget-type="filter-panel"] button[data-role="accept"]',
      'filter-cancel': 'click div[data-widget-type="filter-panel"] button[data-role="cancel"]',
      'filter-param-clear': 'click div[data-widget-type="filter-result-tag-list"] .tc-15-tag',
      'filter-clear': 'click div[data-widget-type="filter-result-tag-list"] div[data-role="clear-options"]'
    };
    var component = this;

    var findWidget = function findWidget(context) {
      if (context.currentTarget) {
        return $(context.currentTarget).closest('div[data-widget-type]').prop('bee');
      } else if (typeof context == 'string') {
        return $(component.$el).find('div[data-widget-type="' + context + '"]').prop('bee');
      }
    };

    var handle = function handle(name, fn) {
      handler[selector[name]] = fn;
    };

    /* ##################  ##################### */

    //  JSON
    var updateFilterResult = function updateFilterResult(filterWidget) {
      var result = filterWidget.result = {};
      filterWidget.params.forEach(function (param) {
        var paramResult = result[param.key] = {};
        paramResult.all = !!param.all;
        paramResult.selected = [];
        param.options.forEach(function (option) {
          if (option.checked) {
            paramResult.selected.push(option.value);
          }
        });
      });
    };

    // 
    var fillParamCheckState = function fillParamCheckState(paramBee, checkState) {
      paramBee.$replace('param.options', paramBee.options.map(function (option) {
        option = JSON.parse(JSON.stringify(option));
        option.checked = checkState;
        return option;
      }));
      paramBee.$replace('param.all', checkState);
    };

    // 
    var setFilterExpandState = function setFilterExpandState(expanded) {
      var filterExpander = findWidget('filter-expander');
      var filterPanel = findWidget('filter-panel');
      var filterResultTagList = findWidget('filter-result-tag-list');
      if (filterExpander) {
        filterExpander.$replace('widget.expand', expanded);
      }
      if (filterPanel) {
        filterPanel.$replace('widget.expand', expanded);
      }
      if (filterResultTagList) {
        findWidget('filter-result-tag-list').$replace('widget.visible', !expanded);
      }
    };

    // 
    var clone = function clone(json) {
      return JSON.parse(JSON.stringify(json));
    };

    var equal = function equal(obj1, obj2) {
      return JSON.stringify(obj1) == JSON.stringify(obj2);
    };

    var updateFilterTagList = function updateFilterTagList(filterWidget) {
      var tagListWidget = findWidget('filter-result-tag-list');
      var result = [];
      var params = filterWidget.params.slice();
      params.sort(function (a, b) {
        return a.modifyTime - b.modifyTime;
      });
      params.forEach(function (param) {
        var options = [];
        param.options.forEach(function (option) {
          if (option.checked) {
            options.push(option.label);
          }
        });
        if (!options.length) return;
        result.push({
          label: param.label,
          key: param.key,
          optionsText: options.join(', ')
        });
      });
      tagListWidget.$replace('widget.result', result);
    };

    var saveFilterSessionState = function saveFilterSessionState(filterWidget) {
      if (filterWidget.sessionKey && filterWidget.lastState) {
        filterSessionStates[filterWidget.sessionKey] = clone(filterWidget.lastState);
      }
    };

    var restoreFilterSessionState = function restoreFilterSessionState(filterWidget) {
      if (filterWidget.sessionKey && filterSessionStates[filterWidget.sessionKey]) {
        return filterSessionStates[filterWidget.sessionKey];
      }
      return filterWidget.params;
    };

    // 
    var saveFilterState = function saveFilterState(filterWidget) {
      if (!equal(filterWidget.lastState, filterWidget.params)) {
        filterWidget.lastState = clone(filterWidget.params);
        updateFilterResult(filterWidget);
        if (filterWidget.change) {
          filterWidget.change.call(filterWidget, filterWidget);
        }
        updateFilterTagList(filterWidget);
      }
      saveFilterSessionState(filterWidget);
    };

    var installInitState = function installInitState(filterWidget) {
      var initState = restoreFilterSessionState(filterWidget);
      filterWidget.reset = function () {
        this.$replace('widget.params', clone(initState));
        updateFilterResult(this);
        updateFilterTagList(this);
      };
      filterWidget.reset();
    };

    var installCommonInitState = function installCommonInitState(widget) {
      if (widget) {
        var initState = clone(widget.$data);
        widget.reset = function () {
          this.$set(clone(initState));
        };
      }
    };

    // 
    var restoreFilterState = function restoreFilterState(filterWidget) {
      if (!equal(filterWidget.lastState, filterWidget.params)) {
        filterWidget.$replace('widget.params', clone(filterWidget.lastState));
        return true;
      }
      return false;
    };

    // 
    this.$afterInit = function () {
      var filterWidget = findWidget('filter-panel');

      if (filterWidget) {
        setFilterExpandState(false);
        installInitState(filterWidget);
        saveFilterState(filterWidget);
      }

      installCommonInitState(component.findWidgetByName('search'));
      installCommonInitState(component.findWidgetByName('date-picker'));
    };

    handle('filter-expand', function (e) {
      var expandState = findWidget(e).$get('widget.expand');
      setFilterExpandState(!expandState);
    });

    handle('filter-option-change', function (e) {
      var $paramEl = $(e.currentTarget);

      var paramBee = $paramEl.closest('.param-line').prop('bee');
      var allChecked;

      // 
      if ($paramEl.data('role') == 'select-all') {
        allChecked = paramBee.$get('param.all');
        fillParamCheckState(paramBee, allChecked);
      }

      // 
      else {
          allChecked = true;
          for (var i = 0; i < paramBee.options.length; i++) {
            if (!paramBee.options[i].checked) {
              allChecked = false;
            }
          }
          paramBee.$replace('param.all', allChecked);
        }
      paramBee.$replace('param.modifyTime', +new Date());
    });

    handle('filter-accept', function (e) {
      var filterWidget = findWidget(e);
      saveFilterState(filterWidget);
      setFilterExpandState(false);
    });

    handle('filter-cancel', function (e) {
      var filterWidget = findWidget(e);
      if (restoreFilterState(filterWidget)) {
        updateFilterResult(filterWidget);
      }
      setFilterExpandState(false);
    });

    /* ##################  ##################### */
    handle('filter-param-clear', function (e) {
      var paramName = $(e.currentTarget).data('clear-param');
      var paramBee = $(e.delegateTarget).find('.param-line[data-param="' + paramName + '"]').prop('bee');
      fillParamCheckState(paramBee, false);
      saveFilterState(findWidget('filter-panel'));
    });

    handle('filter-clear', function (e) {
      var paramBee;
      $(e.delegateTarget).find('.param-line[data-param]').each(function (index, paramEl) {
        fillParamCheckState(paramEl.bee, false);
        paramEl.bee.$replace('param.all', false);
        paramBee = paramBee || paramEl.bee;
      });
      saveFilterState(findWidget('filter-panel'));
    });

    return handler;
  }

});

module.exports = QCActionPanel;

},{"../componentBase":1,"../qc-action-button":10,"../qc-date-picker":12,"../qc-dropdown-list":13,"../qc-search":16,"beejs":27,"beejs/addons/event":26}],12:[function(_dereq_,module,exports){
'use strict';


var tpl = "<div class=\"tc-15-calendar-select-wrap tc-15-calendar2-hook\">\r\n\r\n  <div role=\"tablist\" b-if=\"tabs\" b-style=\"{ opacity: disabled ? 0.4 : 1 }\">\r\n    <span b-repeat=\"tab in tabs\" role=\"tab\" tabindex=\"0\"\r\n          class=\"{{tab.current ? 'current' : ''}}\"\r\n          b-style=\"{ cursor: disabled ? 'not-allowed' : ''}\"\r\n          data-from=\"{{tab.from}}\"\r\n          data-to=\"{{tab.to}}\"\r\n          b-on=\"{ click: handleTabSelect }\">{{tab.label}}</span>\r\n  </div>\r\n\r\n  <div class=\"tc-15-calendar-select{{calPopup ? ' show' : ''}}\" b-if=\"showCalendar\" disabled?=\"disabled\">\r\n    <button class=\"tc-15-simulate-select m{{calPopup ? ' show' : ''}}\" b-on=\"{ mousedown: handlePickButtonDown.bind(this) }\">{{displayCalendarText(value)}}</button>\r\n\r\n    <div class=\"tc-15-calendar-triangle-wrap\"></div>\r\n\r\n    <div class=\"tc-15-calendar-triangle\"></div>\r\n\r\n    <div class=\"tc-15-calendar tc-15-calendar2\" b-on=\"{ click: handleDateClick, mousedown: stopPropagation }\" b-style=\"{ 'margin-left': pull == 'right' ? '-200px' : '' }\">\r\n      <div class=\"tc-15-calendar-cont\" style=\"font-size: 0;\">\r\n        <table class=\"{{month.className}}\" cellspacing=\"0\" b-repeat=\"month in months\">\r\n          <caption>{{month.display}}</caption>\r\n          <thead>\r\n            <tr>\r\n              <th b-repeat=\"weekday in langs[lang].weekdays\">{{weekday}}</th>\r\n            </tr>\r\n          </thead>\r\n          <tbody>\r\n            <tr>\r\n              <td colspan=\"7\">\r\n                <i class=\"tc-15-calendar-i-pre-m{{month.hasPrev ? '' : ' disabled'}}\" tabindex=\"0\"\r\n                   b-if=\"$index == 0\"\r\n                   b-on=\"{ click: prevMonth }\">\r\n                  <b>\r\n                    <span b-if=\"month.hasPrev\">{{langs[lang].prev_month}}</span>\r\n                    <span b-if=\"!month.hasPrev\">{{langs[lang].prev_month_disabled}}</span>\r\n                  </b>\r\n                </i>\r\n                <i class=\"tc-15-calendar-i-next-m{{month.hasNext ? '' : ' disabled'}}\" tabindex=\"0\"\r\n                   b-if=\"$index == months.length - 1\"\r\n                   b-on=\"{ click: nextMonth }\">\r\n                  <b>\r\n                    <span b-if=\"month.hasNext\">{{langs[lang].next_month}}</span>\r\n                    <span b-if=\"!month.hasNext\">{{langs[lang].next_month_disabled}}</span>\r\n                  </b>\r\n                </i>\r\n              </td>\r\n            </tr>\r\n            <tr b-repeat=\"week in month.weeks\">\r\n              <td b-repeat=\"day in week.days\" class=\"{{day.className}}\" data-date=\"{{day.date}}\">\r\n                {{day.display}}\r\n              </td>\r\n            </tr>\r\n          </tbody>\r\n        </table>\r\n      </div>\r\n      <div class=\"tc-15-calendar-footer\">\r\n        <div class=\"tc-15-calendar-input\">\r\n          <div class=\"tc-15-input-text-wrap m\">\r\n            <input type=\"text\"\r\n               class=\"tc-15-input-text\"\r\n               data-role=\"date-from\"\r\n               value=\"{{parseDate(selected.from) || value.tab.display}}\"\r\n               b-on=\"{ keyup: parseDateInput, blur: validateDateInput }\"\r\n               disabled?=\"mode == 'duration' && durationAnchor != 'start'\"\r\n            />\r\n          </div>\r\n          <span role=\"separator\" b-if=\"mode == 'range' || mode == 'duration'\">{{langs[lang].to}}</span>\r\n          <div class=\"tc-15-input-text-wrap m\" b-if=\"mode == 'range' || mode == 'duration'\">\r\n            <input type=\"text\"\r\n               class=\"tc-15-input-text\"\r\n               data-role=\"date-to\"\r\n               value=\"{{parseDate(selected.to)}}\"\r\n               b-on=\"{ keyup: parseDateInput, blur: validateDateInput }\"\r\n               disabled?=\"mode == 'duration' && durationAnchor != 'end'\"\r\n            />\r\n          </div>\r\n          <!--<div b-if=\"formatError\" class=\"tc-15-calendar-error\">YY-MM-DD</div>-->\r\n        </div>\r\n        <div class=\"tc-15-calendar-btns\">\r\n          <button class=\"tc-15-btn m{{selected ? '' : ' disabled'}}\" b-on=\"{ click: acceptPick }\" disabled?=\"!selected\">{{langs[lang].ok}}</button>\r\n          <button class=\"tc-15-btn m weak\" b-on=\"{ click: cancelPick }\">{{langs[lang].cancel}}</button>\r\n        </div>\r\n      </div>\r\n      <div class=\"tc-15-calendar-for-style\"></div>\r\n    </div>\r\n  </div>\r\n</div>\r\n";
var Bee = _dereq_('beejs');
var Base = _dereq_('../componentBase');
var Event = _dereq_('beejs/addons/event');

_dereq_('beejs/src/es5-bee-shim');

var SELECTED_START_CLASS = 'tc-15-calendar-first';
var SELECTED_RANGE_CLASS = 'tc-15-calendar-current';
var SELECTED_END_CLASS = 'tc-15-calendar-last';
var SELECTED_SINGLE_CLASS = 'tc-15-calendar-today';

var DISABLE_CLASS = 'tc-15-calendar-dis';
var PREV_MONTH_CLASS = 'tc-15-calendar-left';
var LAST_MONTH_CLASS = 'tc-15-calendar-right';

/**Parses string formatted as YYYY-MM-DD to a Date object.
 * If the supplied string does not match the format, an
 * invalid Date (value NaN) is returned.
 * @param {string} dateStringInRange format YYYY-MM-DD, with year in
 * range of 0000-9999, inclusive.
 * @return {Date} Date object representing the string.
 */
function parseISO8601(dateStringInRange) {
  var isoExp = /^\s*(\d{4})-(\d\d)-(\d\d)\s*/,
      date = new Date(NaN),
      month,
      parts = isoExp.exec(dateStringInRange);

  if (parts) {
    month = +parts[2];
    date.setFullYear(parts[1], month - 1, parts[3]);
    if (month != date.getMonth() + 1) {
      date.setTime(NaN);
    }
  }
  return date;
}

function dateToInt(date) {
  if (!date) return 0;
  if (typeof date == 'string') date = parseISO8601(date);
  return date.getFullYear() * 10000 + (date.getMonth() + 1) * 100 + date.getDate();
}

function dateToStr(date) {
  function pad(number) {
    var r = String(number);
    if (r.length === 1) {
      r = '0' + r;
    }
    return r;
  }
  if (typeof date == 'number') {
    return String(date).replace(/(\d\d\d\d)(\d\d)(\d\d)/, '$1-$2-$3');
  }
  return [date.getFullYear(), pad(date.getMonth() + 1), pad(date.getDate())].join('-');
}

function swap(obj, key1, key2) {
  var tmp = obj[key1];
  obj[key1] = obj[key2];
  obj[key2] = tmp;
}

function _parseDate(dateStr) {
  if (/^(\d{4})[-\s\.,\/]*(\d\d)[-\s\.,\/]*(\d\d)\s*$/.test(dateStr)) {
    var year = RegExp.$1;
    var month = RegExp.$2;
    var day = RegExp.$3;
    return [year, month, day].join('-');
  }
  return null;
}

function isValidDateString(dateStr) {
  return !isNaN(+parseISO8601(dateStr));
}

function dateOffset(date, day) {
  date = new Date(date);
  date.setDate(date.getDate() + day);
  return date;
}

function dateDelta(date1, date2) {
  return Math.floor(+parseISO8601(date2) - +parseISO8601(date1)) / (24 * 60 * 60 * 1000);
}

/**
 * 
 *
 * */

var defaults = {
  months: [],

  selected: {

    /**
     *  'YYYY-MM-DD' '2015-06-08'
     */
    from: '%TODAY',

    /**
     *  'YYYY-MM-DD' '2015-06-08'
     */
    to: '%TODAY'
  },

  placeHolder: '',

  tabs: [],

  value: {
    from: null,
    to: null
  },

  range: {
    min: null,
    max: null,
    maxLength: 0
  },

  /**
   * mode 
   *
   *   - `single` 
   *   - `range` 
   *   - `duration` 
   * */
  mode: 'range',

  /**
   * mode == 'duration' 
   * */
  durationLength: 1,

  /**
   * mode == 'duration' 
   *
   *   - `start`  x 
   *   - `end`  x 
   *
   *  x  durationLength 
   */
  durationAnchor: 'start',

  today: dateToStr(new Date()),

  /**
   * @type Date
   *
   *  2015-01-01
   * */
  focusDate: null,

  showCalendar: true,

  calPopup: false,

  disabled: false,

  lang: 'zh-cn',

  langs: {
    'zh-cn': {
      'caption_year': '',
      'caption_month': '',
      'weekdays': ['', '', '', '', '', '', ''],
      'to': '',
      'ok': '',
      'cancel': '',
      'prev_month': '',
      'next_month': '',
      'prev_month_disabled': '',
      'next_month_disabled': ''
    },
    'en-us': {
      'caption_year': '/',
      'caption_month': '',
      'weekdays': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      'to': 'To',
      'ok': 'OK',
      'cancel': 'Cancel',
      'prev_month': 'Previous Month',
      'next_month': 'Next Month',
      'prev_month_disabled': 'Invalid for date before',
      'next_month_disabled': 'Invalid for date after'
    }
  },

  onPick: function onPick() {
    return null;
  }, //noop

  pull: 'left'
};
/*only,en;
defaults.langs['zh-cn'] = defaults.langs['en-us'];
only*/

var QCDatePicker = Base.extend({

  constructor: function constructor() {
    Base.apply(this, arguments);
    this._update();
    this._updateValue();
  },

  /*
   * 
   * empty - 
   * single -  from == to
   * range -  from < to
   */
  getState: function getState() {
    var selected = this.selected;
    if (!selected || !selected.from || !selected.to || !isValidDateString(selected.from) || !isValidDateString(selected.to)) {
      return 'empty';
    }
    return selected.from == selected.to ? 'single' : 'range';
  },

  getAllowRange: function getAllowRange() {
    if (!this.range) return null;
    var range = $.extend({}, this.range);
    if (this.mode == 'duration') {
      if (this.durationAnchor == 'start' && range.max) {
        range.max = dateToStr(dateOffset(range.max, 1 - this.durationLength));
      }
      if (this.durationAnchor == 'end' && range.min) {
        range.min = dateToStr(dateOffset(range.min, this.durationLength - 1));
      }
    }
    return range;
  },

  $mixins: [Event],

  $tpl: tpl,

  $afterInit: function $afterInit() {
    var _this = this;

    $(document).on('mousedown', function () {
      if (_this.calPopup && !_this._popupingUp) {
        _this.cancelPick();
      }
    });
    this.$watch('[mode, durationLength, durationAnchor]', this._update.bind(this));
  },

  _getLangText: function _getLangText(key) {
    return this.langs[this.lang][key];
  },

  _getClassNameMapper: function _getClassNameMapper() {

    var root = this;

    var selected = {
      from: this.selected ? dateToInt(this.selected.from) : null,
      to: this.selected ? dateToInt(this.selected.to) : null
    };

    var allowRange = this.getAllowRange();

    var range = {
      min: allowRange ? dateToInt(allowRange.min) : null,
      max: allowRange ? dateToInt(allowRange.max) : null
    };

    if (selected.to < selected.from) {
      swap(selected, 'from', 'to');
    }

    if (range.max < range.min) {
      swap(range, 'min', 'max');
    }

    var maxLength = this.range && this.range.maxLength;
    if (maxLength && selected.from == selected.to) {
      var from = parseISO8601(_parseDate(selected.from));
      var to = parseISO8601(_parseDate(selected.from));
      var min = dateOffset(from, -maxLength);
      var max = dateOffset(to, +maxLength);
      min = dateToInt(min);
      max = dateToInt(max);
      if (!range.min || min > range.min) {
        range.min = min;
      }
      if (!range.max || max < range.max) {
        range.max = max;
      }
    }

    return function mapper(date) {
      date = dateToInt(date);

      var className = [];

      if (root.getState() != 'empty' && date >= selected.from && date <= selected.to) {

        if (date == selected.from && date == selected.to) {
          className.push(SELECTED_SINGLE_CLASS);
        } else if (date == selected.from) {
          className.push(SELECTED_START_CLASS);
        } else if (date == selected.to) {
          className.push(SELECTED_END_CLASS);
        } else {
          className.push(SELECTED_RANGE_CLASS);
        }
      }

      if (range.min && date < range.min || range.max && date > range.max) {
        className.push(DISABLE_CLASS);
      }

      return className.join(' ');
    };
  },

  /**
   * @method _buildMonth()
   *
   * @param firstDateOfMonth {Date} 
   * @param monthClassName {string}  CSS 
   *
   * 
   * */
  _buildMonth: function _buildMonth(firstDateOfMonth, monthClassName) {
    var month = firstDateOfMonth.getMonth();
    var weeks = [];

    var mapClassName = this._getClassNameMapper();

    var firstDate = null;
    var lastDate = null;

    // 
    var buildWeek = function buildWeek(date) {

      // 
      if (date.getMonth() == (month + 1) % 12) {
        return false;
      }

      var days = [];

      //  7 
      for (var i = 0; i < 7; i++) {

        if (date.getMonth() == month) {
          var day = {
            display: date.getDate(),
            date: dateToStr(date),
            className: mapClassName(date)
          };
          days.push(day);
          firstDate = firstDate || new Date(date);
          lastDate = new Date(date);
        }

        // 
        else {
            days.push({
              className: DISABLE_CLASS
            });
          }

        // move next
        date.setDate(date.getDate() + 1);
      }
      return { days: days, className: monthClassName };
    };

    var week;
    var date = new Date(firstDateOfMonth);

    // 
    date.setDate(1 - date.getDay());

    while (week = buildWeek(date)) {
      weeks.push(week);
    }

    return {
      weeks: weeks,
      display: firstDateOfMonth.getFullYear() + this._getLangText('caption_year') + (month + 1) + this._getLangText('caption_month'),
      hasPrev: !this.range.min || dateToInt(firstDate) > dateToInt(this.range.min),
      hasNext: !this.range.max || dateToInt(lastDate) < dateToInt(this.range.max)
    };
  },

  _resolveDate: function _resolveDate(dateStr) {
    var today = this.today;
    if (!dateStr) {
      return null;
    }
    if (/%TODAY([+-]\d+)?/.test(dateStr)) {
      var delta = parseInt(RegExp.$1, 10) || 0;
      var date = parseISO8601(today);
      date.setDate(date.getDate() + delta);
      dateStr = dateToStr(date);
    }
    return dateStr;
  },

  _resolveRange: function _resolveRange(range) {
    if (!range) return null;
    if (range.from) {
      range.from = this._resolveDate(range.from);
    }
    if (range.to) {
      range.to = this._resolveDate(range.to);
    }
    if (range.min) {
      range.min = this._resolveDate(range.min);
    }
    if (range.max) {
      range.max = this._resolveDate(range.max);
    }
    return range;
  },

  /**
   * @method _update()
   *
   * 
   * */
  _update: function _update() {
    this.$replace('selected', this._resolveRange(this.selected));
    this.$replace('range', this._resolveRange(this.range));

    var focusDate = this.focusDate;

    if (!focusDate) {
      focusDate = this.selected && this.selected.to ? parseISO8601(this.selected.to) : new Date();
      if (isNaN(focusDate)) {
        focusDate = new Date();
      }
      this.focusDate = focusDate;
    }

    var months = [];

    var date = new Date(focusDate);

    date.setDate(1);
    months.unshift(this._buildMonth(date, PREV_MONTH_CLASS));
    date.setMonth(date.getMonth() - 1);
    months.unshift(this._buildMonth(date, LAST_MONTH_CLASS));

    this.$replace('months', months);
  },

  _updateTabs: function _updateTabs(selected) {
    var tabs = this.tabs;
    if (!tabs) return;
    for (var i = 0; i < tabs.length; i++) {
      var tab = this._resolveRange(tabs[i]);
      var isCurrent = selected && tab.from == selected.from && tab.to == selected.to;
      tabs.$set(i, {
        current: isCurrent
      });
    }
  },

  _jumpMonth: function _jumpMonth(e, d) {
    if ($(e.target).closest('i').hasClass('disabled')) return;
    this.focusDate.setDate(1);
    this.focusDate.setMonth(this.focusDate.getMonth() + d);
    this._update();
  },

  parseDate: function parseDate(str) {
    return _parseDate(str);
  },

  nextMonth: function nextMonth(e) {
    this.$root._jumpMonth(e, +1);
  },

  prevMonth: function prevMonth(e) {
    this.$root._jumpMonth(e, -1);
  },

  handlePickButtonDown: function handlePickButtonDown(e) {
    var _this2 = this;

    if (this.disabled) return;
    if (!this.calPopup) {
      this._popupingUp = true;
      this.$replace('calPopup', true);
      setTimeout(function () {
        return _this2._popupingUp = false;
      });
    }
  },

  handleDateClick: function handleDateClick(e) {
    e.stopPropagation();
    var $clicked = $(e.target);

    if ($clicked.hasClass(DISABLE_CLASS)) {
      return;
    }

    var date = $clicked.data('date');

    if (!date) {
      return;
    }
    var selected = $.extend({}, this.selected);

    switch (this.getState()) {
      case 'empty':
        selected.from = selected.to = date;
        break;

      case 'single':
        if (this.mode == 'range') {
          var from = dateToInt(selected.from);
          var to = dateToInt(date);
          if (from == to) {
            break;
          }
          if (from > to) {
            selected.from = date;
          } else {
            selected.to = date;
          }
        } else {
          selected.from = selected.to = date;
        }
        break;

      case 'range':
        selected.from = selected.to = date;
        break;
    }

    if (this.mode == 'duration') {
      if (this.durationAnchor == 'end') {
        selected.from = dateToStr(dateOffset(selected.to, 1 - this.durationLength));
      } else {
        selected.to = dateToStr(dateOffset(selected.from, this.durationLength - 1));
      }
    }

    this.$set('selected', selected);

    this._update();
  },

  parseDateInput: function parseDateInput(e) {
    var dateString = $(e.target).val();
    var date = _parseDate(dateString);

    if (!date) return;

    var role = $(e.target).data('role');
    var selected = this.selected;
    var allowed = this.getAllowRange();
    var from, to;

    switch (this.mode) {
      case 'single':
        from = to = dateToInt(date);
        break;
      case 'range':
        if (role == 'date-from') {
          from = dateToInt(date);
          to = dateToInt(selected.to) || from;
        } else if (role == 'date-to') {
          to = dateToInt(date);
          from = dateToInt(selected.from) || to;
        }
        break;
      case 'duration':
        if (role == 'date-from') {
          from = dateToInt(date);
          to = dateToInt(dateOffset(date, this.durationLength - 1));
        } else if (role == 'date-to') {
          to = dateToInt(date);
          from = dateToInt(dateOffset(date, 1 - this.durationLength));
        }
    }

    if (!from && !to) {
      return;
    }

    if (from > to) {
      var t = from;
      from = to;
      to = t;
    }

    if (allowed.min) {
      from = Math.max(dateToInt(allowed.min), from);
      to = Math.max(dateToInt(allowed.min), to);
    }
    if (allowed.max) {
      from = Math.min(dateToInt(allowed.max), from);
      to = Math.min(dateToInt(allowed.max), to);
    }

    if (this.mode == 'duration' && from >= to) {
      if (role == 'date-to') {
        from = dateToInt(dateOffset(_parseDate(to), 1 - this.durationLength));
      } else {
        to = dateToInt(dateOffset(_parseDate(from), this.durationLength - 1));
      }
    }

    if (this.range.maxLength) {
      var max = dateOffset(parseISO8601(selected.from), this.range.maxLength);
      var min = dateOffset(parseISO8601(selected.to), -this.range.maxLength);
      max = dateToInt(max);
      min = dateToInt(min);
      if (role == 'date-to' && max < to) to = max;
      if (role == 'date-from' && min > from) from = min;
    }

    // from  to  NaN
    if (!isNaN(from)) {
      selected.from = dateToStr(from);
    }
    if (!isNaN(to)) {
      selected.to = dateToStr(to);
    }

    var focus = this.focusDate;
    if (role == 'date-from') {
      from = parseISO8601(selected.from);
      if (from.getMonth() < focus.getMonth() - 1 || from.getMonth() > focus.getMonth()) {
        from.setMonth(from.getMonth() + 1);
        this.focusDate = from;
      }
    }
    if (role == 'date-to') {
      to = parseISO8601(selected.to);
      if (to.getMonth() < focus.getMonth() - 1 || to.getMonth() > focus.getMonth()) {
        this.focusDate = to;
      }
    }

    this._update();

    // 
    var newValue = role == 'date-from' ? selected.from : selected.to;
    if (newValue != $(e.target).val()) {
      $(e.target).val(newValue);
    }
  },

  validateDateInput: function validateDateInput(e) {
    var dateString = $(e.target).val();
    var date = _parseDate(dateString);

    if (!date && this.value && !this.value.tab && !this.value.tab.display) {
      var selected = this.$data.selected;
      $(e.target).val(selected[$(e.target).data('role').split('-').pop()]);
    }
  },

  stopPropagation: function stopPropagation(e) {
    e.stopPropagation();
  },

  _updateValue: function _updateValue() {
    var selected = this.selected;
    this._updateTabs(selected);

    if (!selected) {
      this.$replace('value', null);
      return;
    }

    var value = {
      from: selected.from,
      to: selected.to,
      length: Math.abs(dateDelta(selected.from, selected.to)) + 1
    };
    var tabs = this.tabs;
    for (var i = 0; i < tabs.length; i++) {
      var tab = tabs[i];
      if (tab.from == value.from && tab.to == value.to) {
        value.tab = tab;
        break;
      }
    }
    this.$replace('value', value);

    return value;
  },

  displayCalendarText: function displayCalendarText(value) {
    if (value && value.tab && value.tab.display) {
      return value.tab.display;
    }
    if (this.getState() == 'empty') {
      return this.placeHolder;
    }
    if (this.getState() == 'single') {
      return value.from;
    }
    return [value.from, this.langs[this.lang].to, value.to].join(' ');
  },

  acceptPick: function acceptPick() {
    if (!this.selected) return;
    var value = this._updateValue();
    var focusDate = parseISO8601(this.selected.to);
    if (!isNaN(+focusDate)) {
      this.focusDate = focusDate;
    }
    this._update();
    this.$replace('calPopup', false);
    this.$emit('datepick', value);
    if (typeof this.onPick == 'function') {
      this.onPick(value);
    }
  },

  cancelPick: function cancelPick() {
    var selected = this.selected;
    var value = this.value;
    this.$set({
      selected: value ? {
        from: value.from || selected.from,
        to: value.to || selected.to
      } : null
    });
    var focusDate = parseISO8601(this.selected && this.selected.to);
    if (!isNaN(+focusDate)) {
      this.focusDate = focusDate;
    }
    this._update();
    this.$replace('calPopup', false);
    if (typeof this.onCancel == 'function') {
      this.onCancel(value);
    }
  },

  handleTabSelect: function handleTabSelect(e) {

    if (this.$root.disabled) return;

    var $tab = $(e.target);
    if ($tab.hasClass('current')) return;

    var from = $tab.data('from');
    var to = $tab.data('to');
    var label = $tab.text();

    this.$root.setSelectedRange(from, to, label);
    this.$root.acceptPick();
  },

  setSelectedRange: function setSelectedRange(from, to, label) {
    if (!to) {
      to = from;
    }
    this.$set({
      selected: from ? {
        from: this._resolveDate(from),
        to: this._resolveDate(to),
        label: label
      } : null
    });
    this._updateValue();
    var focusDate = parseISO8601(to);
    if (!isNaN(+focusDate)) {
      this.focusDate = focusDate;
    }
    this._update();
  },

  setAllowRange: function setAllowRange(min, max, maxLength) {
    this.$data.range.min = this._resolveDate(min);
    this.$data.range.max = this._resolveDate(max);
    this.$data.range.maxLength = maxLength;
    this._update();
  }
}, { defaults: defaults });

module.exports = QCDatePicker;

},{"../componentBase":1,"beejs":27,"beejs/addons/event":26,"beejs/src/es5-bee-shim":45}],13:[function(_dereq_,module,exports){
'use strict';


var tpl = "<div b-on=\"$events\" data-role=\"qcSelect\" class=\"tc-15-simulate-select-wrap\">\n\t<button data-handler class=\"tc-15-simulate-select m{{popup ? ' show' : ''}}\" b-style=\"style\">\n\t\t{{simulateSelect ? (selected ? selected.label : label) : label}}\n\t</button>\n  <div class=\"dropdown-list-mask\" style=\"left: 0; right: 0; bottom: 0; top: 0; position: fixed; background: transparent; z-index: 999;\" b-style=\"{display: popup ? 'block' : 'none'}\"></div>\n\t<ul data-list class=\"tc-15-simulate-option\" style=\"z-index: 1000;\" b-style=\"{ display: popup ? 'block' : 'none'}\">\n\t\t<span b-content=\"listTpl\"></span>\n\t</ul>\n</div>\n";
var Bee = _dereq_('beejs');
var Base = _dereq_('../componentBase');

//
var defaults = {
  popup: false,

  //  select. 
  simulateSelect: false,

  // ,  simulateSelect  false 
  label: '',

  // 
  list: []
};

var guid = 0;

var QCDropdownList = Base.extend({
  $tpl: tpl,

  //
  listTpl: '<li data-item b-repeat="item in list" tabindex="0">{{item.label}}</li>',

  constructor: function constructor() {
    var _this = this;

    Base.apply(this, arguments);
    var selected = this.selected || this.list[0];
    this.$set('selected', selected);

    this.popup ? this.open() : this.close();

    this.guid = guid++;

    $(window).on('click.qc-dropdown-list_' + this.guid, function (e) {
      if (!$(e.target).parents().is(_this.$el)) {
        _this.close();
      }
    });
  },

  $beforeDestroy: function $beforeDestroy() {
    $(window).off('click.qc-dropdown-list_' + this.guid);
  },

  open: function open() {
    this.$set('popup', true);
  },

  close: function close() {
    this.$set('popup', false);
  },

  onSelect: function onSelect(selected) {
    // event call when selected changed.
  },

  /**
   * 
   * @param {Object | Number | Element} item 
   */
  select: function select(item) {
    var selected;
    if (typeof item === 'object') {
      selected = item.bee && item.bee.$data || item;
    } else if (!isNaN(item * 1)) {
      selected = this.list[item];
    }

    if (!selected || selected.$disabled) {
      return;
    }

    this.close();
    this.$replace('selected', selected);
    this.$emit('selected', selected);
    this.onSelect(selected);
    if (typeof selected.action == 'function') {
      selected.action.call(selected, selected);
    }
  },

  $events: {
    'click [data-handler]': function clickDataHandler(e) {
      this.popup ? this.close() : this.open();
    },
    'click [data-item]': function clickDataItem(e) {
      this.select(e.currentTarget);
    },
    'click .dropdown-list-mask': function clickDropdownListMask() {
      this.close();
    }
  }
}, { defaults: defaults });

module.exports = QCDropdownList;

},{"../componentBase":1,"beejs":27}],14:[function(_dereq_,module,exports){
/**
 * @author techirdliu
 * @created 2015/11/6
 */

'use strict';


var tpl = "<div class=\"tc-15-calendar-select-wrap tc-15-calendar2-hook\">\r\n  <div class=\"tc-15-calendar-select tc-15-calendar-month{{state.popup ? ' show' : ''}}\">\r\n    <button class=\"tc-15-simulate-select m{{state.popup ? ' show' : ''}}\" b-on-click=\"_togglePopup()\">{{_getValueText(state.year, state.month)}}</button>\r\n    <div class=\"tc-15-calendar-triangle-wrap\" b-if=\"state.popup\"></div>\r\n    <div class=\"tc-15-calendar-triangle\" b-if=\"state.popup\"></div>\r\n    <div class=\"tc-15-calendar tc-15-calendar2\" b-if=\"state.popup\" b-on=\"{click: _stopPropagation}\">\r\n      <div class=\"tc-15-calendar-cont\">\r\n        <table class=\"tc-15-calendar-mm\" cellspacing=\"0\">\r\n          <caption>\r\n            {{_getYearText(state.year)}}\r\n          </caption>\r\n          <tbody>\r\n          <tr>\r\n            <td colspan=\"2\">\r\n              <i class=\"tc-15-calendar-i-pre-m{{state.prevYearExcceed ? ' disabled' : ''}}\"\r\n                 tabindex=\"0\" b-on-click=\"_setYear(state.year - 1)\">\r\n                <b><span>{{state.prevYearExcceed ? texts.prevYearDisabled : texts.prevYear}}</span></b>\r\n              </i>\r\n            </td>\r\n            <td colspan=\"2\">\r\n              <i class=\"tc-15-calendar-i-next-m{{state.nextYearExcceed ? ' disabled' : ''}}\"\r\n                 tabindex=\"0\" b-on-click=\"_setYear(state.year + 1)\">\r\n                <b><span>{{state.nextYearExcceed ? texts.nextYearDisabled : texts.nextYear}}</span></b>\r\n              </i>\r\n            </td>\r\n          </tr>\r\n          <tr b-repeat=\"monthRow in [0, 1, 2]\">\r\n            <td b-repeat=\"monthCol in [1, 2, 3, 4]\" class=\"{{_getMonthClass(state.year, monthRow * 4 + monthCol, selected)}}\"\r\n                b-on-click=\"_pickMonth(monthRow * 4 + monthCol)\">\r\n              {{_getMonthText(monthRow * 4 + monthCol)}}\r\n            </td>\r\n          </tr>\r\n          </tbody>\r\n        </table>\r\n      </div>\r\n      <div class=\"tc-15-calendar-for-style\"></div>\r\n    </div>\r\n  </div>\r\n</div>\r\n";
var Bee = _dereq_('beejs');
var Base = _dereq_('../componentBase');

var monthPattern = /^(\d{4})(\d{2})$/;

/**
 * 
 *
 * parseMonth(null)      => {}
 * parseMonth('current') => { year: 2015, month: 11, value: 201511 } // 
 * parseMonth('201403')  => { year: 2014, month: 3, value: 201403 } // 
 * parseMonth('abcd')    => Error!
 * */
function parseMonth(str) {
  if (!str) {
    return {};
  }
  var year, month, match;

  str = String(str);

  if (str == 'current') {
    year = new Date().getFullYear();
    month = new Date().getMonth() + 1;
  } else if (match = monthPattern.exec(str)) {
    year = parseInt(match[1], 10);
    month = parseInt(match[2], 10);
  } else {
    throw new RangeError(' yyyymm ');
  }
  return {
    year: year,
    month: month,
    value: year * 100 + month
  };
}

//
var defaults = {

  // 'single' 'range' 
  mode: 'single',

  //  null  'current'  201511, 201503
  minValue: null,
  maxValue: 'current',

  state: {
    popup: false,
    year: new Date().getFullYear(),
    month: new Date().getMonth() + 1
  },

  texts: {
    prevYear: '',
    prevYearDisabled: '',
    nextYear: '',
    nextYearDisabled: ''
  }
};

var QCMonthPicker = Base.extend({
  $tpl: tpl,

  $afterInit: function $afterInit() {
    var _this = this;

    if (this.value) {
      this._updateValue(this.value);
    }
    this._updateState();
    this._updateSelected();
    this.$watch('value', this._setValue);
    $(document).on('click', this._globalClickHandler = function () {
      return _this.toggling || _this.$set('state.popup', false);
    });
  },

  $destroy: function $destroy() {
    $(document).off('click', this._globalClickHandler);
  },

  $valuekey: 'value',

  _stopPropagation: function _stopPropagation(e) {
    e.stopPropagation();
  },

  _setValue: function _setValue(valueStr) {
    var value = parseMonth(valueStr);
    if (!value.year || this._monthExceed(value.year, value.month)) return;
    this.$set('state', $.extend(this.state, {
      year: value.year,
      month: value.month
    }));
    this._updateState();
    this._updateSelected();
  },

  _togglePopup: function _togglePopup() {
    var _this2 = this;

    this.toggling = true;
    this.$set('state.popup', !this.state.popup);
    setTimeout(function () {
      return _this2.toggling = false;
    });
  },

  _updateState: function _updateState() {
    this.$set('state', $.extend(this.state, {
      prevYearExcceed: this._yearExceed(this.state.year - 1),
      nextYearExcceed: this._yearExceed(this.state.year + 1)
    }));
  },

  _updateSelected: function _updateSelected() {
    this.$replace('selected', {
      year: this.state.year,
      month: this.state.month,
      toString: function toString() {
        return String(this.year * 100 + this.month);
      }
    });
    var value = this.selected.toString();
    if (this.value != value) {
      this.$set('value', value);
    }
  },

  _yearExceed: function _yearExceed(year) {
    var minYear = parseMonth(this.minValue).year;
    var maxYear = parseMonth(this.maxValue).year;

    return minYear && year < minYear || maxYear && year > maxYear;
  },

  _monthExceed: function _monthExceed(year, month) {
    var value = year * 100 + month;
    var minValue = parseMonth(this.minValue).value;
    var maxValue = parseMonth(this.maxValue).value;

    return minValue && value < minValue || maxValue && value > maxValue;
  },

  _getMonthClass: function _getMonthClass(year, month) {
    if (this._monthExceed(year, month)) {
      return 'tc-15-calendar-dis';
    }
    if (this.selected.year == this.state.year && this.selected.month == month) {
      return 'tc-15-calendar-mm-select';
    }
  },

  _setYear: function _setYear(year) {
    if (this._yearExceed(year)) return;
    this.$set('state', $.extend(this.state, {
      year: year
    }));
    this._updateState();
  },

  _pickMonth: function _pickMonth(month) {
    if (this._monthExceed(this.state.year, month)) {
      return;
    }
    this.$set('state', $.extend(this.state, {
      month: month
    }));
    this._updateSelected();
    this.$set('state', $.extend(this.state, {
      popup: false
    }));
  },

  _getMonthText: function _getMonthText(month) {
    var lang = window.VERSION;
    if (lang == 'en') {
      return ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'June', 'July', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec'][month - 1];
    } else {
      return month + '';
    }
  },

  _getYearText: function _getYearText(year) {
    var lang = window.VERSION;
    if (lang == 'en') {
      return 'Year ' + year;
    } else {
      return year + '';
    }
  },

  _getValueText: function _getValueText(year, month) {
    var lang = window.VERSION;
    if (lang == 'en') {
      return this._getMonthText(month) + ' ' + year;
    } else {
      return year + '  ' + month + ' ';
    }
  }

}, { defaults: defaults });

module.exports = QCMonthPicker;

},{"../componentBase":1,"beejs":27}],15:[function(_dereq_,module,exports){
'use strict';


var tpl = "<div data-role=\"qc-popover\" style=\"display:none;z-index:999;top:-1000px;left:-1000px\" class=\"tc-15-bubble {{_getPosClass(position)}}\" b-style=\"style\">\r\n    <div class=\"tc-15-bubble-inner\" b-style=\"_getLeft(position)\">\r\n        {{> content }}\r\n    </div>\r\n</div>\r\n";
var Bee = _dereq_('beejs');
var Base = _dereq_('../componentBase');
var box = _dereq_('../../lib/box');

var classes = {
  top: 'tc-15-bubble-bottom',
  left: 'tc-15-bubble-right',
  bottom: 'tc-15-bubble-top',
  right: 'tc-15-bubble-left',
  'top left': 'tc-15-bubble-bottom',
  'top right': 'tc-15-bubble-bottom',
  'bottom left': 'tc-15-bubble-top',
  'bottom right': 'tc-15-bubble-top'
};

/**
 * 
 * @namespace
 * @memberof QcPopover
 * @property {Object} defaults 
 * @property {Boolean} defaults.auto=true 
 * @property {String} defaults.position='bottom' 
 * @property {Array} defatuls.availablePos  `position` 
 * @property {String|Element} defaults.content 
 * @property {String} defaults.trigger='hover' . : `hover, click, focus`
 * @property {Boolean} defaults.hideDestroy=false 
 * @property {Number} defatuls.hideDelay 
 * @property {String|Object} defaults.style 
 */
var defaults = {
  //
  position: 'bottom',
  //
  auto: true,
  //
  content: '',
  //
  offset: { top: 0, left: 0 },
  //
  arrowOffset: 8,
  arrowPad: 14,

  trigger: 'hover',

  hideDelay: 300,

  //
  hideDestroy: false,

  //
  availablePos: ['top', 'left', 'bottom', 'right', 'top left', 'top right', 'bottom left', 'bottom right']
};

var events = {
  hover: ['mouseenter', 'mouseleave'],
  click: ['click', 'click'],
  focus: ['focusin', 'focusout']
};

var popovers = [];

/**
 * @class QcPopover
 * @desc 
 * - 
 *  ```js
 *  new QcPopover({
 *  	handler: document.querySelector('#target'),
 *  	$data: {
 *   		hideDestroy: true,
 *   	 	content: 'I\'m QcPopover',
 *      trigger: ''
 *  	}
 *  })
 *  ```
 * - .  `data-` 
 *  ```html
 *  <a href="javascript:;" qc-popover="" data-trigger="click"></a>
 *  ```
 */
var QcPopover = Base.extend(
/**
 * @lends QcPopover.prototype
 */
{
  $tpl: tpl,

  $afterInit: function $afterInit() {
    QcPopover.__super__.$afterInit.call(this);
    this._$el = $(this.$el);

    if (!this.handler) {
      // `handler`, 
      this.$handler = $(this.$content).children();
      this.handler = this.$handler[0];
      this._$el.before(this.$handler);
    } else {
      this.$handler = $(this.handler);
    }

    if (!this.target) {
      this.target = this.handler;
      this.$target = this.$handler;
    } else {
      this.$target = $(this.target);
    }

    if (typeof this.attachEl === 'function') {
      this.attachEl(this.$el);
    } else {
      ;(this.attachEl ? $(this.attachEl) : this.$target).eq(0).after(this.$el);
    }

    this.$handler.data('qc-popover', this);

    this.$box = $(this.box || box.getBox(this.$el));

    this.bindEvent();

    popovers.push(this);
  },

  $afterDestroy: function $afterDestroy() {
    QcPopover.__super__.$afterDestroy.call(this);
    var index = popovers.indexOf(this);
    if (index > -1) {
      popovers.splice(index, 1);
    }
    this.$handler.removeData('qc-popover');
  },

  /**
  * .  `handler`
  * @type {Element}
  */
  target: null,

  /**
  * 
  * @type {Element}
  */
  handler: null,

  /**
  * .  `target`
  * @type {Element|Function}
  */
  attachEl: null,

  /**
  * 
  */
  reposition: function reposition(pos) {
    var off = this._offset(pos);

    var newpos = this.auto && this.suggested(pos, off);

    if (newpos && newpos !== pos) {
      pos = newpos;
      off = this._offset(pos);
    }

    if (pos) {
      if (this.availablePos.indexOf(pos) == -1) {
        throw new Error('invalid position "' + pos + '"');
      }
    }

    this.$set('position', pos);
    this._$el.css(off);
  },

  /**
  * 
  */
  show: function show() {
    this._$el.fadeIn('fast');
    this.state = true;
    this.reposition(this.position);
  },

  /**
  * .  `hideDestroy=true` ,  `hide`  `show` .
  */
  hide: function hide() {
    this.state = false;
    this._$el.hide();
    this.hideDestroy && this.$destroy(true);
  },

  /**
  * 
  * @param {String} pos 
  * @param {Object} off 
  * @returns {String} 
  */
  suggested: function suggested(pos, off) {
    var $box = this.$box;
    var $target = this.$target;

    var arrowOffset = this.arrowOffset;

    var toff = $target.offset();
    var boff = $box.offset() || { top: 0, left: 0 };

    var tl = toff.left;
    var tt = toff.top;
    var tw = $target.outerWidth();
    var th = $target.outerHeight();

    var ew = this._$el.outerWidth() + arrowOffset;
    var eh = this._$el.outerHeight() + arrowOffset;

    var w, h;

    var box = $box[0];

    w = $box.innerWidth();
    h = $box.innerHeight();

    var good = {
      top: true,
      bottom: true,
      left: true,
      right: true
    };

    //
    if (toff.top + th + eh > boff.top + h) good.bottom = false;

    //
    if (toff.top - boff.top < eh) good.top = false;

    //
    if (toff.left - boff.left < ew) good.left = false;

    //
    if (toff.left + tw + ew > boff.left + w) good.right = false;

    var positions = pos.split(/\s+/);

    //
    if (good[positions[0]] && (positions[1] ? good[positions[1]] : true) && this.availablePos.indexOf(pos) > -1) {
      return pos;
    }

    //
    for (var i = 0, position; position = this.availablePos[i]; i++) {
      positions = position.split(/\s+/);
      if (good[positions[0]] && (positions[1] ? good[positions[1]] : true)) {
        return position;
      }
    }

    //
    return this.availablePos[0];
  },

  /**
  * ,  `target` 
  * @private
  */
  _offset: function _offset(pos) {
    var arrowOffset = this.arrowOffset;
    var pad = this.arrowPad;

    var ew = this._$el.outerWidth();
    var eh = this._$el.outerHeight();

    var targetRect = this.$target.offset();

    if (!targetRect) throw new Error('could not get bounding client rect of `target`');
    var tw = this.$target.outerWidth();
    var th = this.$target.outerHeight();
    var to = offset(targetRect, this._$el.offsetParent());
    var off;
    if (!to) throw new Error('could not determine page offset of `target`');
    switch (pos) {
      case 'top':
        off = {
          top: to.top - eh - arrowOffset,
          left: to.left + tw / 2 - ew / 2
        };
        break;
      case 'bottom':
        off = {
          top: to.top + th + arrowOffset,
          left: to.left + tw / 2 - ew / 2
        };
        break;
      case 'right':
        off = {
          top: to.top + th / 2 - eh / 2,
          left: to.left + tw + arrowOffset
        };
        break;
      case 'left':
        off = {
          top: to.top + th / 2 - eh / 2,
          left: to.left - ew - arrowOffset
        };
        break;
      case 'top left':
        off = {
          top: to.top - eh - arrowOffset,
          left: to.left + tw / 2 - ew + pad
        };
        break;
      case 'top right':
        off = {
          top: to.top - eh - arrowOffset,
          left: to.left + tw / 2 - pad
        };
        break;
      case 'bottom left':
        off = {
          top: to.top + th + arrowOffset,
          left: to.left + tw / 2 - ew + pad
        };
        break;
      case 'bottom right':
        off = {
          top: to.top + th + arrowOffset,
          left: to.left + tw / 2 - pad
        };
        break;
      default:
        throw new Error('invalid position "' + pos + '"');
    }

    off.top += this.offset.top;
    off.left += this.offset.left;

    return off;
  },

  _getPosClass: function _getPosClass(position) {
    return classes[position] || '';
  },
  _getLeft: function _getLeft(position) {
    if (/\s+right$/.test(position)) {
      return { left: 12 };
    } else if (/\s+left$/.test(position)) {
      return this._$el ? { left: this._$el.width() - 12 } : {};
    }
  },

  bindEvent: function bindEvent() {
    var _this = this;

    if (this.trigger) {
      var $handler = this.$handler.add(this.$el);

      $handler.on(events[this.trigger][1], function (e) {
        if (_this.trigger === 'hover' && ($.contains(_this.$el, e.toElement) || $.contains(_this.$handler[0], e.toElement) || $handler.is(e.toElement))) {
          return;
        }

        clearTimeout(_this._delay);

        _this._delay = setTimeout(function () {
          _this.state && _this.hide();
        }, _this.hideDelay);
      }).on(events[this.trigger][0], function () {
        clearTimeout(_this._delay);
      });

      this.$handler.on(events[this.trigger][0], function () {
        _this.show();
      });
    }
  }
},
/**
* @lends QcPopover
*/
{
  defaults: defaults,
  /**
  *  popover
  */
  hide: function hide() {
    popovers.forEach(function (popover) {
      return popover.hide();
    });
  },
  /**
  *  `pop`  popover
  * @param  {QcPopover} pop popover 
  */
  hideExcept: function hideExcept(pop) {
    popovers.forEach(function (popover) {
      return pop !== popover && popover.hide();
    });
  }
});

function offset(box, $offsetEl) {
  var el = $offsetEl[0];

  var off = $offsetEl.offset() || { left: 0, top: 0 };
  var scrollTop = $offsetEl.scrollTop();
  var scrollLeft = $offsetEl.scrollLeft();
  return {
    top: box.top + scrollTop - off.top,
    left: box.left + scrollLeft - off.left
  };
}

var egroup = '.qc_popover';
QcPopover.bootFromAttr = function (attr) {
  var Cstr = this;
  $(document).on('mouseenter' + egroup + ' click' + egroup + ' focusin' + egroup, '[' + attr + ']', function (e) {
    var $target = $(this);

    var qcPopover, trigger;
    var data;

    if (!$target.data('qc-popover')) {
      data = $target.data();
      trigger = data.trigger || Cstr.defaults.trigger;

      if (e.type === events[trigger][0]) {
        qcPopover = new Cstr({
          $data: $.extend({}, data, {
            handler: this,
            content: $target.attr(attr),
            position: $target.attr(attr + '-position'),
            style: $target.attr(attr + '-style'),
            attachEl: $target.attr(attr + '-attach-el')
          })
        });
        qcPopover.show();
      }
    }
  });
};

// `popover` 
$(document).on('click', function (e) {
  var $target = $(e.target);
  var popover;
  if ($target.attr('data-role') === 'qc-popover' || $target.parents('[data-role=qc-popover]').length) {
    return;
  }

  popover = $target.parents().data('qc-popover') || $target.data('qc-popover');

  if (popover) {
    QcPopover.hideExcept(popover);
    return;
  } else {
    QcPopover.hide();
  }
});

QcPopover.bootFromAttr('qc-popover');
// React
QcPopover.bootFromAttr('aria-qc-popover');

module.exports = QcPopover;

},{"../../lib/box":23,"../componentBase":1,"beejs":27}],16:[function(_dereq_,module,exports){
'use strict';


var tpl = "<div b-on=\"$events\" data-role=\"qc-search\" class=\"tc-15-search {{multiple ? 'tc-15-multi-search' : ''}}\" b-style=\"style\">\n\t<textarea data-input class=\"tc-15-search-words\" placeholder=\"{{placeholder}}\" b-if=\"multiple\" b-model=\"keyword\"></textarea>\n  <input data-input class=\"tc-15-search-words\" placeholder=\"{{placeholder}}\" b-if=\"!multiple\" b-model=\"keyword\" type=\"text\" />\n\t<button data-search class=\"tc-15-btn weak m search\"></button>\n</div>\n";
var Bee = _dereq_('beejs');
var Base = _dereq_('../componentBase');

//
var defaults = {
  keyword: '', //
  searchEmpty: false, // / 
  multiple: false, //
  placeholder: ''
};

//QCSearch  Bee 
var QCSearch = Base.extend({
  $tpl: tpl,

  $events: {
    'click [data-search]': function clickDataSearch() {
      this._search();
    },
    'keydown [data-input]': function keydownDataInput(e) {
      var goSearch;
      if (e.keyCode == 13) {
        goSearch = this.multiple ? e.ctrlKey : true;
      }
      goSearch && this._search();
    }
  },

  _search: function _search() {
    var keyword = this.keyword.trim();
    if (keyword === '' && !this.searchEmpty) {
      return;
    }
    this.search(keyword);
    this.onSearch(keyword);
    this.$el.querySelector('[data-input]').blur();
    $(this.$el).trigger('search', [keyword]);
    this.$emit('search', keyword);
  },

  //
  getKeyword: function getKeyword() {
    return this.$get('keyword');
  },

  //
  search: function search(keyword) {
    console.log(keyword);
  },
  onSearch: function onSearch(keyword) {}
}, { defaults: defaults });

module.exports = QCSearch;

},{"../componentBase":1,"beejs":27}],17:[function(_dereq_,module,exports){
/**
 * 
 * interface listItem {
 *    label: string,
 *    value: string,
 *    ico: string,
 *    iconVal: string
 * }
 * @param list: listItem[]
 * @param onSelect: (selected: listItem[]) => void
 */

'use strict';


var tpl = "<div class=\"tc-15-rich-radio\" role=\"radiogroup\" data-role=\"qc-segment\">\n    <button b-repeat=\"item in list\" b-on-click=\"toggle(item)\"\n      class=\"tc-15-btn {{item.$checked ? 'checked' : ''}} {{$index == 0 ? 'first' : ''}}\n       {{$index == list.length - 1 ? 'last' : ''}} {{(disabled || item.$disabled) ? 'disabled' : ''}}\n       {{big ? '' : 'm'}}\"\n      role=\"radio\"  aria-checked=\"{{item.$checked}}\">\n      <span>{{item.label}}</span>\n      <i b-if=\"item.ico\" class=\"{{item.ico}}\">{{item.iconVal}}</i>\n    </button>\n</div>\n";
var Base = _dereq_('../componentBase');

var QcSegment = Base.extend({
  $tpl: tpl,
  $valuekey: 'selected',
  $afterInit: function $afterInit() {
    var _this = this;

    this.list.forEach(function (item) {
      if (item.$checked) {
        _this.toggle(item, true);
      }
    });

    this.$watch('selected', function (selects) {
      selects && selects.forEach(function (selected) {
        return selected.$checked || _this.toggle(selected, true);
      });
    }, true);
  },

  /**
   * 
   * @param  {[type]} selected [description]
   * @return {[type]}          [description]
   */
  onSelect: function onSelect(selected, c) {},
  //
  toggle: function toggle(item, checked) {
    var _this2 = this;

    var index, _item, isChecked, selects;
    var index = typeof item === 'object' ? this._getIndex(item) : item;
    var _item = this.list[index];

    if (!this.disabled && _item && !_item.$disabled) {

      if (this.type == 'checkbox') {
        isChecked = typeof checked == 'boolean' ? checked : !_item.$checked;
      } else {
        // `radio`
        isChecked = true;
        this.list.forEach(function (item, i) {
          i !== index && _this2.list.$set(i, {
            $checked: false
          });
        });
        if (_item.$checked && this.selected) {
          return false;
        }
      }

      this.list.$set(index, {
        $checked: isChecked
      });

      selects = this.list.filter(function (item) {
        return item.$checked;
      });

      this.$set('selected', selects);
      this.$emit('selected', _item, selects);
      this.onSelect(_item, selects);
    }
  },
  updateItem: function updateItem(i, item) {
    this.list.$set(i, item);
  },
  _getIndex: function _getIndex(item) {
    var index = -1,
        _item;
    for (var i = 0, l = this.list.length; i < l; i++) {
      _item = this.list[i];
      if (item == _item || (typeof this.idKey == 'function' ? this.idKey(item, _item) : item[this.idKey] == _item[this.idKey])) {
        index = i;
        break;
      }
    }
    return index;
  }
}, {
  /**
   * 
   * @namespace
   * @memberof QcSegment
   * @property {Object} defaults
   */
  defaults: {
    list: [{
      label: ''
    }],
    idKey: 'label', //
    big: false,
    disabled: false,
    type: 'radio' //checkbox | radio
  }
});

// `qc-segment`  QcSegment .  `img`  `Image` 
Bee.tag('qc-segment', QcSegment);

module.exports = QcSegment;

},{"../componentBase":1}],18:[function(_dereq_,module,exports){
'use strict';


var tpl = "<div b-on=\"$events\" class=\"tc-15-dropdown {{styleType == 0 ? 'tc-15-dropdown-in-hd' : 'tc-15-dropdown-btn-style'}} tc-15-menu-{{popup ? 'active' : ''}}  {{cls}}\">\r\n  <a data-handler href=\"javascript:;\" class=\"tc-15-dropdown-link\" b-style=\"style\">\r\n    {{simulateSelect ? (selected ? selected.label : label) : label}}<i class=\"caret\"></i>\r\n  </a>\r\n  <div class=\"dropdown-list-wrap\">\r\n    <div class=\"search-box search-box-simple m\" b-if=\"popup && filter\">\r\n        <form action=\"javascript:;\" b-on-submit=\"search(filterKey)\">\r\n          <div class=\"search-input-wrap\">\r\n              <textarea data-filter b-model=\"filterKey\" b-if=\"filter === 'multiple'\"\r\n                class=\"tc-15-input-text search-input\" placeholder=\"{{filterPlaceHolder}}\"></textarea>\r\n              <input data-filter type=\"text\" b-if=\"filter && filter !== 'multiple'\"\r\n                b-model=\"filterKey\"class=\" tc-15-input-text search-input\"  placeholder=\"{{filterPlaceHolder}}\">\r\n          </div>\r\n          <input class=\"search-btn\" type=\"submit\" value=\"\">\r\n        </form>\r\n    </div>\r\n    <ul data-list class=\"tc-15-dropdown-menu\" role=\"menu\">\r\n    \t<span b-content=\"listTpl\"></span>\r\n      <li b-if=\"!(list | _filter : filterKey).length && !$loading\" class=\"disabled\">\r\n        <a href=\"javascript:;\">\r\n          {{> emptyTips }}\r\n        </a>\r\n      </li>\r\n    </ul>\r\n  </div>\r\n</div>\r\n";
var Bee = _dereq_('beejs');
var DropDown = _dereq_('../qc-dropdown-list');

var QCSelect = DropDown.extend({
  $tpl: tpl,
  $valuekey: 'selected',
  $afterInit: function $afterInit() {
    QCSelect.__super__.$afterInit.call(this);
    this.$watch('popup', function (popup) {
      var filterEl;
      if (popup) {
        this.openReset && this.$set('filterKey', '');
        filterEl = this.$el.querySelector('[data-filter]');
        filterEl && filterEl.focus();
      }
    });
  },

  search: function search() {},

  filterData: function filterData(list, filterKey) {
    return list.filter(function (item) {
      return filterKey ? item.label.indexOf(filterKey) > -1 : true;
    });
  },

  listTpl: '<li data-item role="presentation" b-repeat="item in list | _filter : filterKey"\n                title="{{item.title || item.label}}"\n                class="{{selected == item ? \'selected\' : \'\'}} {{item.$disabled ? \'disabled\' : \'\'}}">\n              <a role="menuitem" href="javascript:;">{{item.label}}</a>\n            </li>'
}, {
  defaults: {
    filterKey: '',
    filter: false,
    filterPlaceHolder: '',
    styleType: 0,
    simulateSelect: true,
    emptyTips: '',
    openReset: true
  },
  filters: {
    _filter: function _filter(list, filterKey) {
      return this.filterData(list, filterKey);
    }
  }
});

module.exports = QCSelect;

},{"../qc-dropdown-list":13,"beejs":27}],19:[function(_dereq_,module,exports){
//Beejs 

// `brfs`
'use strict';


var tpl = "<div data-role=\"qc-tabs\">\n  <div class=\"tc-15-tab {{className}}\">\n      <ul class=\"tc-15-tablist\" role=\"tablist\">\n          <li class=\"{{$index == activeIndex ? 'tc-cur': ''}}\" b-repeat=\"tab in list\">\n            <a b-on-click=\"$set('activeIndex', $index)\" role=\"tab\" title=\"{{tab.label}}\" href=\"javascript:;\">{{tab.label}}</a>\n          </li>\n      </ul>\n  </div>\n  <div data-tab-pane b-repeat=\"tab in list\" b-style=\"{display: $index == activeIndex ? 'block': 'none'}\">\n    {{> tab.content }}\n  </div>\n</div>\n";
var Bee = _dereq_('beejs');
var Base = _dereq_('../componentBase');

//QcTabs  Bee 
var QcTabs = Base.extend({
  $tpl: tpl,
  $afterInit: function $afterInit() {
    QcTabs.__super__.$afterInit.call(this);
    this.$watch('activeIndex', function (i) {
      this.$emit('tabchange', i);
      this.onChange(i);
    }, this.initTriggerChange);
  },
  onChange: function onChange() {}
}, {
  //
  defaults: {
    activeIndex: 0,
    initTriggerChange: false // onChange
  }
});

module.exports = QcTabs;

},{"../componentBase":1,"beejs":27}],20:[function(_dereq_,module,exports){
'use strict';

var Base = _dereq_('../componentBase');


var tpl = "<div class=\"tc-15-bubble\" data-role=\"qc-title\" data-state=\"{{state}}\" b-style='{left:x, top: y, display: state ? \"\" : \"none\", overflow: \"hidden\", maxWidth: maxWidth, maxHeight: maxHeight, width: width, height: height, zIndex: zIndex}'>\n    <div class=\"tc-15-bubble-inner\">{{> content || $content }}</div>\n</div>\n";

var box = _dereq_('../../lib/box');

//
var _qcTitle;

var QcTitle = Base.extend({
  $tpl: tpl,

  $afterInit: function $afterInit() {
    QcTitle.__super__.$afterInit.call(this);

    _qcTitle && _qcTitle.$destroy(true);

    _qcTitle = this;
  },

  $afterDestroy: function $afterDestroy() {
    QcTitle.__super__.$afterDestroy.call(this);
    _qcTitle = null;
  },

  setPosition: function setPosition(x, y) {
    var newPos = this.reposition({
      x: x + this.offsetX,
      y: y + this.offsetY
    });

    this.$set(newPos);
  },

  reposition: function reposition(pos) {
    var newPos = {},
        $el = $(this.$el),
        $box = $(box.getBox(this.$el)),
        pOffset = $box.offset() || { left: 0, top: 0 },
        ew = $el.width(),
        eh = $el.height(),
        pw = $box.width(),
        ph = $box.height();

    newPos.x = Math.min(pos.x, pw - ew + pOffset.left);
    newPos.y = Math.min(pos.y, ph - eh + pOffset.top);

    return newPos;
  }
}, {
  defaults: {
    state: true,
    offsetX: 8,
    offsetY: 1,

    zIndex: 9999,
    maxWidth: 360,
    maxHeight: '',
    width: '',
    height: ''
  }
});

QcTitle.config = function (attr) {
  $(document).off('.qc_title').on('mouseenter.qc_title click.qc_title', '[' + attr + ']', function (e) {
    var $target = $(this);
    var content = $target.attr(attr);
    var data = $target.data();

    if (!content) {
      return;
    }

    var old = $target.data('qcTitle');

    old && old.$destroy(true);

    var qcTitle = new QcTitle({
      $data: $.extend({}, data, {
        target: this,
        content: content
      })
    });

    var $tar = $target.add(qcTitle.$el);

    $tar.on('mouseleave.qc_title', function (e) {
      if (!$.contains(qcTitle.$el, e.toElement)) {
        $tar.off('.qc_title').removeData('qcTitle');
        qcTitle.$destroy(true);
      }
    });

    $target.add(qcTitle.$el).data('qcTitle', qcTitle);
    document.body.appendChild(qcTitle.$el);
    qcTitle.setPosition(e.clientX, e.clientY);
  }).on('mousemove.qc_title', function (e) {
    if (_qcTitle) {
      var $target = $(_qcTitle.target);
      var offset = $target.offset();
      var size = {
        width: $target.outerWidth(),
        height: $target.outerHeight()
      };

      if (e.clientX < Math.floor(offset.left) || e.clientX > offset.left + size.width || e.clientY < Math.floor(offset.top) || e.clientY > offset.top + size.height) {
        //
        $target.add(_qcTitle.$el).off('.qc_title').removeData('qcTitle');
        _qcTitle.$destroy(true);
      } else {
        _qcTitle.setPosition(e.clientX, e.clientY);
      }
    }
  });
};

QcTitle.config('data-title');

module.exports = QcTitle;

},{"../../lib/box":23,"../componentBase":1}],21:[function(_dereq_,module,exports){
//Beejs 

// `brfs`
'use strict';


var tpl = "<div class=\"ui_progress\" b-on=\"$events\" b-style=\"style\">\n  <div class=\"progress_area\">\n    <div class=\"progress_bar\" b-ref=\"sliderBar\">\n      <div class=\"progress_bg\">\n        <div class=\"progress_in\"\n            b-style=\"{width: _width}\"></div>\n        <div class=\"btn_drag\" data-handler style=\"margin-left: -6px;z-index: 1;\" role=\"slider\" tabindex=\"0\"\n            b-style=\"{left: _width }\">\n        </div>\n      </div>\n      <div class=\"scale\">\n        <div b-repeat=\"item in _section\" class=\"scale_dot my-range-scale dot_pass\" b-style=\"{left:item.offset*100 + '%', marginLeft: '-1px'}\"></div>\n      </div>\n    </div>\n    <div class=\"input_area\" b-if=\"showInput\">\n      <input type=\"text\" data-input b-model=\"value\" class=\"input_mini\" style=\"margin-left: 10px\">\n      <span>{{unit}}</span>\n    </div>\n  </div>\n  <div class=\"text_area\">\n    <span b-repeat=\"item in _section\" class=\"text\" b-style=\"{marginLeft: '-50%', width: '100%', textAlign: 'center', left: item.offset*100 + '%'}\">{{item.value}}{{unit}}</span>\n  </div>\n  <div b-if=\"tips\" class=\"tc-15-slider-tips\" style=\"margin-top: 10px;\">{{tips}}</div>\n</div>\n";
var Base = _dereq_('../componentBase');
var Bee = _dereq_('beejs');

var guid = 0;

//SliderRange  Bee 
var SliderRange = Base.extend({
  $tpl: tpl,
  $valuekey: 'value',
  $lazy: true,

  $beforeInit: function $beforeInit() {
    SliderRange.__super__.$beforeInit.call(this);
    this._section = this.section.slice();
    this._section.unshift({
      value: this.min,
      offset: 0
    });
    this._section.push({
      value: this.max,
      offset: 1
    });
  },
  $afterInit: function $afterInit() {
    SliderRange.__super__.$afterInit.call(this);
    var that = this;
    var $body = $('body');

    // guid 
    this.guid = guid++;

    $body.on('mouseup.slider_' + that.guid, function (e) {
      //
      if (that._sliding) {
        that._sliding = false;
        $body.off('mousemove.slider_' + that.guid);
        that.onFinallyChange(that.value);
      }
    });

    $(that.$el).on('mousedown.slider_' + this.guid, '[data-handler]', function (e) {
      //
      that._sliding = true;
      var fullWidth = $(that.$refs.sliderBar).width(); //
      var left = $(that.$refs.sliderBar).offset().left;

      $body.on('mousemove.slider_' + that.guid, function (e) {
        //
        if (that._sliding) {

          that._setWidth((e.clientX - left) / fullWidth);

          e.preventDefault();
        }
      });
      e.preventDefault();
    });

    $(that.$refs.sliderBar).on('click.slider_' + that.guid, function (e) {
      var left = $(this).offset().left;
      var fullWidth = $(that.$refs.sliderBar).width();

      that._setWidth((e.clientX - left) / fullWidth);

      that.onFinallyChange(that.value);
    });

    that.$watch('value', function () {
      this._checkValue();
    });
    that.$watch('min', function (min) {
      this._section.$set(0, {
        value: min
      });
      this._checkValue();
    });
    that.$watch('max', function (max) {
      this._section.$set(this._section.length - 1, {
        value: max
      });
      this._checkValue();
    });
  },

  //
  _setWidth: function _setWidth(width) {
    width = Math.max(0, Math.min(1, width));
    var that = this;
    var value = this._getSection(width, 'offset');

    that.setValue(value);
  },

  //
  //, 
  _getSection: function _getSection(_val, key) {
    var section = {};
    var val;

    if (key == 'value') {
      val = 'offset';
    } else {
      val = 'value';
    }

    this._section.some(function (item, i, _section) {
      if (item[key] >= _val && i) {
        if (_section[i - 1]) {
          if (!('left' in section)) {
            section.left = _section[i - 1];
            section.right = item;
            return true;
          }
        } else {
          throw new Error('section ');
        }
      }
    });

    return section.left[val] * 1 + (_val - section.left[key]) / (section.right[key] - section.left[key]) * (section.right[val] - section.left[val]);
  },

  // value 
  _checkValue: function _checkValue() {
    var that = this;
    var last = that._lastValue;
    var val = that.value,
        min = that.min * 1,
        max = that.max * 1;

    // value  step 
    val = Math.round((val - min) / this.step) * this.step + min;

    if (min <= max) {
      if (val > max) {
        val = max;
      } else if (val < min) {
        val = min;
      }
    }
    if (isNaN(val)) {
      val = last;
    }
    that._lastValue = val;

    var width = this._getSection(val, 'value');

    that.$set({
      value: val,
      _width: width * 100 + '%'
    });
    that.onChange({
      max: max,
      min: min,
      value: val
    });
  },
  $beforeDestroy: function $beforeDestroy() {
    $('body').off('.slider_' + this.guid);
  },

  //
  getValue: function getValue() {
    return this.$get('value');
  },
  setValue: function setValue(value) {
    var val = (this.min || this.min === 0) && this.max ? Math.max(this.min, Math.min(this.max, value)) : value;
    if (isNaN(val)) {
      return false;
    } else {
      this.$set('value', val);
      return true;
    }
  },
  onChange: function onChange() {},
  onFinallyChange: function onFinallyChange() {},
  stepUp: function stepUp() {
    this.setValue(this.value * 1 + this.step * 1);
  },

  stepDown: function stepDown() {
    this.setValue(this.value * 1 - this.step * 1);
  },

  $events: {
    'click [data-input]': function clickDataInput(e) {
      e.target.select();
    },
    'blur [data-input]': function blurDataInput(e) {
      var that = this;
      setTimeout(function () {
        that.onFinallyChange(that.value);
      }, 0);
    },
    'keydown': function keydown(e) {
      if (e.keyCode == 37 || e.keyCode == 40) {
        this.stepDown();
        e.preventDefault();
      } else if (e.keyCode == 38 || e.keyCode == 39) {
        this.stepUp();
        e.preventDefault();
      }
    }
  }
}, {
  defaults: {
    step: 1,
    min: 0,
    max: 100,
    value: 50,

    _section: [],

    //. [{ offset: 0.5, value: 50 }]
    //offset , value 
    section: [],

    showInput: true // input 
  }
});

module.exports = SliderRange;

},{"../componentBase":1,"beejs":27}],22:[function(_dereq_,module,exports){
var Bee = _dereq_('beejs')

_dereq_('beejs/src/es5-bee-shim');

_dereq_('./components/qc-title');

Bee.tag('input-slider', _dereq_('./components/input-slider'));
Bee.tag('device-selector', _dereq_('./components/device-selector'));
Bee.tag('pagination', _dereq_('./components/pagination'));
Bee.tag('grid-view', _dereq_('./components/grid-view'));
Bee.tag('grid-view-header-filter', _dereq_('./components/grid-view-header-filter'));
Bee.tag('qc-date-picker', _dereq_('./components/qc-date-picker'));
Bee.tag('qc-dropdown-list', _dereq_('./components/qc-dropdown-list'));
Bee.tag('qc-select', _dereq_('./components/qc-select'));
Bee.tag('qc-search', _dereq_('./components/qc-search'));
Bee.tag('qc-action-button', _dereq_('./components/qc-action-button'));
Bee.tag('qc-action-panel', _dereq_('./components/qc-action-panel'));
Bee.tag('slider-range', _dereq_('./components/slider-range'));
Bee.tag('qc-popover', _dereq_('./components/qc-popover'));
Bee.tag('qc-tabs', _dereq_('./components/qc-tabs'));
Bee.tag('popup-confirm', _dereq_('./components/popup-confirm'));
Bee.tag('grid-editor', _dereq_('./components/grid-editor'));
Bee.tag('qc-month-picker', _dereq_('./components/qc-month-picker'));
Bee.tag('qc-segment', _dereq_('./components/qc-segment'));

_dereq_('./mixins');

module.exports = Bee;

},{"./components/device-selector":2,"./components/grid-editor":3,"./components/grid-view":5,"./components/grid-view-header-filter":4,"./components/input-slider":7,"./components/pagination":8,"./components/popup-confirm":9,"./components/qc-action-button":10,"./components/qc-action-panel":11,"./components/qc-date-picker":12,"./components/qc-dropdown-list":13,"./components/qc-month-picker":14,"./components/qc-popover":15,"./components/qc-search":16,"./components/qc-segment":17,"./components/qc-select":18,"./components/qc-tabs":19,"./components/qc-title":20,"./components/slider-range":21,"./mixins":24,"beejs":27,"beejs/src/es5-bee-shim":45}],23:[function(_dereq_,module,exports){
//
//
'use strict';

exports.getBox = function (el) {
  var node = el;
  var $offsetParent = $(el).offsetParent();
  var overflow;

  while (el = el.parentNode) {
    node = el;
    overflow = $(node).css('overflow');
    if (node === document || overflow === 'auto' || overflow !== 'visible' && ($offsetParent.is(node) || $.contains(node, $offsetParent[0]))) {
      return node;
    }
  }
  return node;
};

},{}],24:[function(_dereq_,module,exports){
var ComponentBase = _dereq_('../components/componentBase');

var mixins = {
  'scroll-loader': _dereq_('./scroll-loader')
};

ComponentBase.getMixin = function(name) {
  return mixins[name];
};
},{"../components/componentBase":1,"./scroll-loader":25}],25:[function(_dereq_,module,exports){


/**
 * Recommended by John Resig solution:
 *
 * (tested: IE7+, iOS5+ Safari, Android2+, Blackberry, Opera Mobile, IE Mobile)
 *
 * @see http://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport/7557433#7557433
 * */
function isElementInViewport(element, view, distance) {
  //special bonus for those using jQuery
  if (typeof jQuery === "function") {
    if (element instanceof jQuery) {
      element = element[0];
    }
    if (view instanceof jQuery) {
      view = view[0];
    }
  }

  /*  */
  var rect = element.getBoundingClientRect();
  var viewRect = view.getBoundingClientRect();

  var viewport = {
    left: viewRect.left - distance,
    top: viewRect.top - distance,
    right: viewRect.right + distance,
    bottom: viewRect.bottom + distance
  };

  /* @see https://github.com/fex-team/kity/blob/dev/src/graphic/box.js#L219-L232 */
  var left = Math.max(rect.left, viewport.left),
      right = Math.min(rect.right, viewport.right),
      top = Math.max(rect.top, viewport.top),
      bottom = Math.min(rect.bottom, viewport.bottom);

  return left <= right && top <= bottom;
}

var instanceList = [];

function ScrollLoader(options) {
  options = $.extend({
    triggerDistance: 0
  }, options);

  return {

    $afterInit: function() {
      instanceList.push(this);
      if (typeof this.load != 'function') {
        console.error(' ScrollLoader  load()  Promise ');
      }
      if (!this.scrollView) {
        console.error(' ScrollLoader  scrollView Dom  jQuery ');
      }
      var _this = this;

      $(this.scrollView).on('scroll', this._scrollLoadBindFn = function() {
        _this._detectLoad();
      });

      // $afterInit Dom  detached
      setTimeout(function() {
        _this.reload();
      }, 1);
    },

    $destroy: function() {
      var index = instanceList.indexOf(this);
      if (index != -1) {
        instanceList.splice(index, 1);
      }
      $(this.scrollView).off('scroll', this._scrollLoadBindFn);
    },

    _detectLoad: function() {

      // load has triggered
      if (this.loaderState == 'triggered') return;

      if (isElementInViewport(this.$el, $(this.scrollView)[0], options.triggerDistance)) {

        var loadResult = this.load();

        if (loadResult && typeof loadResult.then == 'function') {
          this.$set('loaderState', 'triggered');
          var _this = this;
          loadResult.then(function() {
            _this.$set('loaderState', 'loaded');
          });
        }
      }
    },

    reload: function() {
      this._detectLoad();
    }
  };
}

$(window).on('DOMContentLoaded load resize', function() {
  instanceList.forEach(function(instance) {
    instance._detectLoad();
  });
});

module.exports = ScrollLoader;
},{}],26:[function(_dereq_,module,exports){

var Event = {
  //.
  $on: function(name, handler, context) {
    var ctx = context || this
      ;

    ctx._handlers = ctx._handlers || {};
    ctx._handlers[name] = ctx._handlers[name] || [];

    ctx._handlers[name].push({handler: handler, context: context, ctx: ctx});
  },
  $one: function (name, handler, context) {
    if(handler){
      handler.one = true;
    }
    return this.$on(name, handler, context);
  },
  //.
  $off: function(name, handler, context) {
    var ctx = context || this
      , handlers = ctx._handlers || {}
      ;

    if(name && handlers[name]){
      if(typeof handler === 'function'){
        for(var i = handlers[name].length - 1; i >=0; i--) {
          if(handlers[name][i].handler === handler){
            handlers[name].splice(i, 1);
          }
        }
      }else{
        handlers[name] = [];
      }
    }
  },
  //.
  // context . , : `Event.$emit.call(context, name, data)`
  $emit: function(name, data) {
    var args = [].slice.call(arguments, 1)
      , handlers = this._handlers && this._handlers[name]
      ;

    if(handlers){
      for(var i = 0, item; item = handlers[i]; i++) {
        item.handler.apply(this, args);
        if(item.handler.one) {
          handlers.splice(i, 1);
          i--;
        }
      }
    }
  }
};

module.exports = Event;

},{}],27:[function(_dereq_,module,exports){
"use strict";

var doc = _dereq_('./env.js').document
  , utils = _dereq_('./utils.js')
  , Class = _dereq_('./class.js')
  , directive = _dereq_('./directive.js')
  , Com = _dereq_('./component.js')
  , Watcher = _dereq_('./watcher.js')

  , dirs = _dereq_('./directives')
  , domUtils = _dereq_('./dom-utils.js')
  , checkBinding = _dereq_('./check-binding.js')
  , scope = _dereq_('./scope')

  , Dir = directive.Directive
  ;


var isObject = utils.isObject
  , isPlainObject = utils.isPlainObject
  , parseKeyPath = utils.parseKeyPath
  , deepSet = utils.deepSet
  , extend = utils.extend
  , create = utils.create
  ;

// directive 
function setPrefix(newPrefix) {
  if(newPrefix){
    this.prefix = newPrefix;
  }
}

//TODO 
var mergeProps = {
  $data: 1
};

var lifeCycles = {
  $beforeInit: utils.noop
, $afterInit: utils.noop
, $beforeUpdate: utils.noop
, $afterUpdate: utils.noop
, $beforeDestroy: utils.noop
, $afterDestroy: utils.noop
};

/**
 * 
 * @constructor
 * @param {String|Element} [tpl] .  props.$tpl
 * @param {Object} [props] /
 */
function Bee(tpl, props) {
  if(isPlainObject(tpl)) {
    props = tpl;
  }else{
    props = props || {};
    if(tpl) {
      props.$tpl = tpl;
    }
  }

  var defaults = {
    //$ /
    $data: extend(true, {}, this.constructor.defaults)
  , $refs: {}
  , $mixins: []

  , $el: this.$el || null
  , $tpl: this.$tpl || '<div>{{> $content }}</div>'
  , $content: this.$content || null

  , $isReplace: false
  , $parent: null
  , $root: this
  , $context: null

    ///
  , _watchers: {}
  , _assignments: null// vm 
  , _relativePath: []
  , __links: []
  , _isRendered: false
  };

  var mixins = [defaults].concat(this.$mixins).concat(props.$mixins).concat([props])

  mixins.forEach(function(mixin) {
    var prop;
    for(var propKey in mixin) {
      if(mixin.hasOwnProperty(propKey)) {
        if ((propKey in mergeProps) && isObject(mixin[propKey])) {
          //
          //mergeProps 
          prop = extend({}, this[propKey], mixin[propKey])
          this[propKey] = extend(mixin[propKey], prop)
        } else if (propKey in lifeCycles) {
          this[propKey] = utils.afterFn(this[propKey], mixin[propKey])
        } else {
          this[propKey] = mixin[propKey];
        }
      }
    }
  }.bind(this))

  extend(this, this.$data);

  resolveTpl.call(this);

  this.$beforeInit()
  this.$el.bee = this;

  //__links  $el 
  this.__links = this.__links.concat( checkBinding.walk.call(this, this.$el) );

  this._isRendered = true;
  this.$afterInit();
}

//
extend(Bee, {extend: utils.afterFn(Class.extend, utils.noop, function(sub, args) {
  var staticProps = args[1] || {};
  // directives ,components, filters , 
  //,  directive, components, filters . 
  sub.directives = extend(create(this.directives), staticProps.directives);
  sub.components = extend(create(this.components), staticProps.components);
  sub.filters = extend(create(this.filters), staticProps.filters);

  sub.defaults = extend(true, {}, this.defaults, staticProps.defaults);
}), utils: utils}, Dir, Com, {
  setPrefix: setPrefix
, directive: directive.directive
, prefix: ''
, doc: doc
, directives: {}
, components: {}
, defaults: {}
, filters: {
    //build in filter
    json: function(obj, replacer, space) {
      return JSON.stringify(obj, replacer, space) }
  }
, filter: function(filterName, filter) {
    this.filters[filterName] = filter;
  }
, mount: function(id, props) {
    var el = id.nodeType ? id : doc.getElementById(id);
    var instance;
    var dirs = directive.getDirs(el, this);
    var Comp, dir;

    dir = dirs.filter(function(dir) {
      return  dir.type === 'tag' || dir.type === 'component'
    })[0];

    if(dir) {
      Comp = this.getComponent(dir.path)
    }

    props = props || {};
    if(Comp) {
      props.$data = extend(domUtils.getAttrs(el), props.$data)
      instance = new Comp(extend({$el: el, $isReplace: true, __mountcall: true}, props))
    }else{
      instance = new this(el, props);
    }
    return instance
  }
});


Bee.setPrefix('b-');

// directive
for(var dir in dirs) {
  Bee.directive(dir, dirs[dir]);
}

//
//----
extend(Bee.prototype, lifeCycles, {
  /**
   * /
   * @param {String} expression /
   * @returns {*}
   */
  $get: function(expression) {
    var dir = new Dir('$get', {
      path: expression
    , watch: false
    });
    dir.parse();
    return dir.getValue(this, false)
  }

  /**
   *  `.data` . ,  .$data
   * @param {String} [key] .
   * @param {AnyType|Object} val .
   */
, $set: function(key, val) {
    var add, keys, hasKey = false;
    var reformed, reKey, reVm = this;

    if(arguments.length === 1){
      if(isObject(key)) {
        extend(this.$data, key);
        extend(this, key);
      }else{
        this.$data = key;
      }
      update.call(reVm, key);
    }else{
      this.$replace(key, val);
    }
  }
  /**
   * 
   */
, $replace: function (key, val) {
    var keys, last, hasKey = false;
    var reformed, reKey, reVm = this;

    if(arguments.length === 1){
      val = key;
      reKey = '$data';
      keys = [reKey];
    }else{
      hasKey = true;
      reformed = scope.reformScope(this, key)
      reKey = reformed.path;
      reVm = reformed.vm;
      keys = parseKeyPath(reKey);
    }

    last = reVm.$get(reKey);

    if (keys[0] === '$data') {
      if(reKey === '$data') {
        if(isObject(this.$data)) {
          Object.keys(this.$data).forEach(function (k) {
            delete this[k];
          }.bind(this))
        }
        extend(reVm, val);
      }else {
        deepSet(keys.shift().join('.'), val, reVm)
      }
    } else {
      deepSet(reKey, val, reVm.$data);
    }
    deepSet(reKey, val, reVm)

    hasKey ? update.call(reVm, reKey, extend({}, last, val)) : update.call(reVm, extend({}, last, val));
  }
  /**
   * 
   * @param {String} keyPath  keyPath
   * @param {Boolean} [isBubble=true]  keyPath 
   */
, $update: function (keyPath, isBubble) {
    isBubble = isBubble !== false;

    var keys = parseKeyPath(keyPath.replace(/^\$data\./, '')), key;
    var watchers;

    while(key = keys.join('.')) {
      watchers = this._watchers[key] || [];

      for (var i = 0, l = watchers.length; i < l; i++) {
        watchers[i] && watchers[i].update();
      }

      if(isBubble) {
        keys.pop();
        // $data
        if(!keys.length && key !== '$data'){
          keys.push('$data');
        }
      }else{
        break;
      }
    }

    //
    Watcher.getWatchers(this, keyPath).forEach(function(watcher) {
      watcher.update();
    }.bind(this))

    //
    if(isBubble) {
      if(this.$parent) {
        // vm 
        this._relativePath.forEach(function (path) {
          this.$parent.$update(path);
        }.bind(this))
      }
    }
  }
, $watch: function (expression, callback, immediate) {
    if(callback) {
      var update = callback.bind(this);
      update._originFn = callback;
      return Watcher.addWatcher.call(this, new Dir('$watch', {path: expression, update: update, immediate : !!immediate}))
    }
  }
, $unwatch: function (expression, callback) {
    Watcher.unwatch(this, expression, callback)
  }
  //
  //removeEl  false 
, $destroy: function(removeEl) {
    this.$beforeDestroy()
    this.__links.forEach(function(wacher) {
      wacher.unwatch()
    })

    var node = this.$el.firstChild
    while(node) {
      if(node.bee) {
        node.bee.$destroy(removeEl)
        node = node.nextSibling
      }else {
        node = node.nextSibling || node.firstChild
      }
    }

    removeEl !== false && this.$el.parentNode && this.$el.parentNode.removeChild(this.$el)
    this.__links = [];
    this.$afterDestroy()
  }
});

function update (keyPath, data) {
  var keyPaths;
  this.$beforeUpdate(this.$data)
  if(arguments.length === 1) {
    data = keyPath;
  }else{
    keyPaths = [keyPath];
  }

  if(!keyPaths) {
    if(isObject(data)) {
      keyPaths = Object.keys(data);
    }else{
      //.$data 
      keyPaths = ['$data'];
    }
  }

  for(var i = 0, path; path = keyPaths[i]; i++){
    this.$update(path, true);
  }
  this.$afterUpdate(this.$data)
}

// $el,  $content, $tpl
function resolveTpl() {
  var el = this.$el
    , content = this.$content
    , tpl = this.$tpl
    , tplEl
    ;

  content = el && el.childNodes ? el.childNodes : content

  if(el) {
    // $el  $conten 
    content = el.childNodes;
  }

  if(content) {
    // $content documentFragment
    this.$content = domUtils.createContent(content)
  }

  if(utils.isObject(tpl)){
    //DOM 
    tplEl = tpl;
    tpl = tplEl.outerHTML;
  }else{
    //
    tplEl = domUtils.createContent(tpl).childNodes[0];
  }

  if(el) {
    if(this.$isReplace) {
      el.parentNode && el.parentNode.replaceChild(tplEl, el)
      el = tplEl;
    }else{
      el.appendChild(tplEl)
    }
  }else{
    el = tplEl;
  }

  this.$el = el;
}

Bee.version = '0.5.4';

module.exports = Bee;

},{"./check-binding.js":28,"./class.js":29,"./component.js":30,"./directive.js":31,"./directives":37,"./dom-utils.js":43,"./env.js":44,"./scope":49,"./utils.js":51,"./watcher.js":52}],28:[function(_dereq_,module,exports){
"use strict";

var Watcher = _dereq_('./watcher')
  , token = _dereq_('./token.js')
  , utils = _dereq_('./utils')
  , doc = _dereq_('./env.js').document
  , directive = _dereq_('./directive')
  ;

var NODETYPE = {
    ELEMENT: 1
  , ATTR: 2
  , TEXT: 3
  , COMMENT: 8
  , FRAGMENT: 11
};

doc.createElement('template');

/**
 *  dom 
 * @private
 * @param {Element|NodeList} el
 * @returns {Array} 
 */

function walk(el) {
  var watchers = [], dirResult;
  if(el.nodeType === NODETYPE.FRAGMENT) {
    el = el.childNodes;
  }

  if(('length' in el) && utils.isUndefined(el.nodeType)){
    //node list
    // nodelist  {{text}} , , 
    for(var i = 0; i < el.length; i++) {
      watchers = watchers.concat( walk.call(this, el[i]) );
    }
    return watchers;
  }

  switch (el.nodeType) {
    case NODETYPE.ELEMENT:
      break;
    case NODETYPE.COMMENT:
      //
      return watchers;
      break;
    case NODETYPE.TEXT:
      //
      watchers = watchers.concat( checkText.call(this, el) );
      return watchers;
  }

  if(el.nodeName.toLowerCase() === 'template') {
    //template shim
    if(!el.content) {
      el.content = doc.createDocumentFragment();
      while(el.childNodes[0]) {
        el.content.appendChild(el.childNodes[0])
      }
    }
  }

  dirResult = checkAttr.call(this, el);
  watchers = watchers.concat(dirResult.watchers)
  if(dirResult.terminal){
    return watchers;
  }

  if(el.nodeName.toLowerCase() === 'template') {
    watchers = watchers.concat( walk.call(this, el.content) )
  }

  for(var child = el.firstChild, next; child; ){
    next = child.nextSibling;
    watchers = watchers.concat( walk.call(this, child) );
    child = next;
  }

  return watchers
}

//
function checkAttr(el) {
  var cstr = this.constructor
    , dirs = directive.getDirs(el, cstr, this.$context)
    , dir
    , terminalPriority, watchers = []
    , result = {};
  ;

  for (var i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    dir.dirs = dirs;

    // terminal  true  directive,  directive 
    if(terminalPriority > dir.priority) {
      break;
    }

    el.removeAttribute(dir.nodeName);

    watchers = watchers.concat( setBinding.call(this, dir) );

    if(dir.terminal) {
      result.terminal = true;
      terminalPriority = dir.priority;
    }
  }

  result.watchers = watchers

  return result
}

var partialReg = /^>\s*/;
//({{...}})
function checkText(node) {
  var watchers = [];
  if(token.hasToken(node.nodeValue)) {
    var tokens = token.parseToken(node.nodeValue)
      , textMap = tokens.textMap
      , el = node.parentNode
      , dirs = this.constructor.directives
      , t, dir
      ;

    //{{key}}
    if(textMap.length > 1) {
      textMap.forEach(function(text) {
        var tn = doc.createTextNode(text);
        el.insertBefore(tn, node);
        watchers = watchers.concat(checkText.call(this, tn));
      }.bind(this));
      el.removeChild(node);
    }else{
      t = tokens[0];
      //.
      if(partialReg.test(t.path)) {
        t.path = t.path.replace(partialReg, '');
        dir = utils.create(dirs.content)
        dir.dirName = dir.type
        dir.anchors = directive.setAnchors(node, dir.type)
      }else{
        dir = utils.create(t.escape ? dirs.text : dirs.html)
      }

      watchers = setBinding.call(this, utils.extend(dir, t, {
        el: node
      }));
    }
  }
  return watchers
}

function setBinding(dir) {
  var watcher
  if(dir.replace) {
    var el = dir.el;
    if(utils.isFunction(dir.replace)) {
      dir.node = dir.replace();
    }else{
      dir.node = doc.createTextNode('');
    }

    dir.el = dir.el.parentNode;
    dir.el.replaceChild(dir.node, el);
  }

  dir.vm = this;
  dir.link();

  watcher = Watcher.addWatcher.call(this, dir)
  return watcher ? [watcher] : []
}

function unBinding(watchers) {
  watchers.forEach(function(watcher) {
    watcher.unwatch()
  })
}

module.exports = {
  walk: walk,
  unBinding: unBinding
};

},{"./directive":31,"./env.js":44,"./token.js":50,"./utils":51,"./watcher":52}],29:[function(_dereq_,module,exports){
var extend = _dereq_('./utils.js').extend;

var Class = {
  /**
   * .
   * : `var Car = Bee.extend({drive: function(){}}); new Car();`
   * @param {Object} [protoProps] 
   * @param {Object} [staticProps] 
   * @returns {Function} 
   */
  extend: function (protoProps, staticProps) {
    protoProps = protoProps || {};
    var constructor = protoProps.hasOwnProperty('constructor') ?
          protoProps.constructor : function(){ return sup.apply(this, arguments); }
    var sup = this;
    var Fn = function() { this.constructor = constructor; };
    var supRef = {__super__: sup.prototype};

    Fn.prototype = sup.prototype;
    constructor.prototype = new Fn();
    extend(constructor.prototype, supRef, protoProps);
    extend(constructor, sup, supRef, staticProps);

    return constructor;
  }
};

module.exports = Class;

},{"./utils.js":51}],30:[function(_dereq_,module,exports){
"use strict";

var utils = _dereq_('./utils.js');

/**
 * 
 * @param {String} tagName 
 * @param {Function|props} Component  / 
 * @return {Function} 
 */
function tag(tagName, Component, statics) {
  var tags = this.components = this.components || {};

  this.doc.createElement(tagName);//for old IE

  if(utils.isObject(Component)) {
    Component = this.extend(Component, statics);
  }
  return tags[tagName] = Component;
}

/**
 * 
 * @param {String} componentName 
 * @param {Bee} context 
 */
function getComponent(componentName, context) {
  var paths = utils.parseKeyPath(componentName);
  var CurCstr = this;
  paths.forEach(function(comName) {
    CurCstr = CurCstr && CurCstr.components[comName];
  });

  if(context && context.constructor && !CurCstr) {
    CurCstr = context.constructor.getComponent(componentName, context.$context);
  }
  return CurCstr || null;
}

exports.tag = exports.component = tag;
exports.getComponent = getComponent;

},{"./utils.js":51}],31:[function(_dereq_,module,exports){
"use strict";

var utils = _dereq_('./utils.js')
  , token = _dereq_('./token.js')
  , doc = _dereq_('./env.js').document
  , parse = _dereq_('./parse.js').parse
  , evaluate = _dereq_('./eval.js')
  , domUtils = _dereq_('./dom-utils')

  , create = utils.create
  ;

/**
 *  Bee  (directive). `Bee.directive`
 * @param {String} key directive 
 * @param {Object} [opts] directive 
 * @param {Number} opts.priority=0 directive . .
 * @param {Boolean} opts.terminal=false  directive ,  directive .
 *   terminal ,  directive  directive , .
 * @param {Boolean} opts.anchor anchor  true , .  `anchors.start`  `anchors.end`
 */
function directive(key, opts) {
  var dirs = this.directives = this.directives || {};

  return dirs[key] = new Directive(key, opts);
}

function Directive(key, opts) {
  this.type = key;
  utils.extend(this, opts);
}

var astCache = {};

Directive.prototype = {
  priority: 0//
, type: '' //
, subType: '' //.  `b-on-click`  type  `on`, subType  `click`
, sub: false //
, link: utils.noop//
, unLink: utils.noop//
, update: utils.noop//
, tearDown: utils.noop
, terminal: false//
, replace: false//. , 
, watch: true// key .  false , update 
, immediate: true // dir  update 

, anchor: false
, anchors: null

  //.
, getNodes: function(start, end) {
    start = start || this.anchors.start;
    end = end || this.anchors.end;

    var nodes = [], node = start.nextSibling;
    if(this.anchor && node) {
      while(node !== end){
        nodes.push(node);
        node = node.nextSibling;
      }

      return nodes;
    }
  }
  //
, parse: function() {
    var cache = astCache[this.path]
    if(cache && cache._type === this.type){
      this.ast = cache
    }else {
      if(this.type == 'attr' && this.escape === false) {
        this.path = '{' + this.path + '}'
      }
      try {
        this.ast = parse(this.path, this.type);
        this.ast._type = this.type;
        astCache[this.path] = this.ast;
      } catch (e) {
        this.ast = {};
        e.message = 'SyntaxError in "' + this.path + '" | ' + e.message;
        console.error(e);
      }
    }
  }
  //
  //forgive[true]:  undefined  null 
, getValue: function(scope, forgive) {
    forgive = forgive !== false;
    var val;

    try{
      val = evaluate.eval(this.ast, scope, this);
    }catch(e){
      val = '';
      console.error(e);
    }
    if(forgive && (utils.isUndefined(val) || val === null)) {
      val = '';
    }
    return val;
  }
};

var attrPostReg = /\?$/;

/**
 *  HTML 
 * @param  {Element} el   
 * @param  {Function} cstr 
 * @param  {Bee} context 
 * @return {directeve[]}      `el` 
 */
function getDirs(el, cstr, context){
  var attr, attrName, dirName, proto
    , dirs = [], dir
    , parent = el.parentNode
    , nodeName = el.nodeName.toLowerCase()
    , directives = cstr.directives
    , prefix = cstr.prefix
    ;

  //,  directive
  if(cstr.getComponent(nodeName, context)) {
    el.setAttribute(prefix + 'component', nodeName);
  }

  for(var i = el.attributes.length - 1; i >= 0; i--){
    attr = el.attributes[i];
    attrName = attr.nodeName;
    dirName = attrName.slice(prefix.length);
    proto = {el: el, node: attr, nodeName: attrName, path: attr.value};
    dir = null;

    if(attrName.indexOf(prefix) === 0 && (dir = getDir(dirName, directives))) {
      //
      dir.dirName = dirName//dir 
    }else if(token.hasToken(attr.value)) {
      //
      token.parseToken(attr.value).forEach(function(origin) {
        origin.dirName = attrName ;
        dirs.push(utils.extend(create(directives.attr), proto, origin))
      });
      // anchor, 
    }else if(attrPostReg.test(attrName)) {
      //
      dir = utils.extend(create(directives.attr), { dirName: attrName.replace(attrPostReg, ''), conditional: true });
    }

    if(dir) {
      if(dir.anchor) {
        dir.anchors = setAnchors(el, dir.dirName);
      }
      dirs.push(utils.extend(dir, proto));
    }
  }
  dirs.sort(function(d0, d1) {
    return d1.priority - d0.priority;
  });
  return dirs;
}

function getDir(dirName, dirs) {
  var dir, subType;
  for(var key in dirs) {
    if(dirName === key){
      dir = dirs[key]
      break
    }else if(dirName.indexOf(key + '-') === 0){
      dir = dirs[key]
      if(!dir.sub){
        dir = null
      }else{
        subType = dirName.slice(key.length + 1)
      }
      break;
    }
  }
  if(dir) {
    dir = create(dir);
    dir.subType = subType;
  }
  return dir;
}

function setAnchors(node, dirName) {
  var parent = node.parentNode
    , anchors = {}
    ;

    anchors.start = doc.createComment(dirName + ' start');
    parent.insertBefore(anchors.start, node);

    anchors.end = doc.createComment(dirName + ' end');
    if(node.nextSibling) {
      parent.insertBefore(anchors.end, node.nextSibling);
    }else{
      parent.appendChild(anchors.end);
    }
    return anchors
}

module.exports = {
  Directive: Directive,
  directive: directive,
  getDirs: getDirs,
  setAnchors: setAnchors
};

},{"./dom-utils":43,"./env.js":44,"./eval.js":46,"./parse.js":48,"./token.js":50,"./utils.js":51}],32:[function(_dereq_,module,exports){
"use strict";

//

var utils = _dereq_('../utils.js');

module.exports = {
  link: function() {
    if(this.dirName === this.type && this.nodeName !== this.dirName) {//attr binding
      this.attrs = {};
    }else {
      //, 
      this.update('')
    }
  }
, update: function(val) {
    var el = this.el;
    var newAttrs = {};
    var textMap = this.textMap

    //b-attr
    if(this.attrs) {
      for(var attr in val) {
        setProperty.call(this, el, attr, val[attr]);

        delete this.attrs[attr];

        newAttrs[attr] = true;
      }

      //
      for(var attr in this.attrs) {
        removeProperty.call(this, el, attr);
      }
      this.attrs = newAttrs;
    }else{
      if(this.conditional) {
        val ? setProperty.call(this, el, this.dirName, val) : removeProperty.call(this, el, this.dirName);
      }else{
        textMap[this.position] = val;
        setProperty.call(this, el, this.dirName, textMap.length > 1 ? textMap.join('') : textMap[0]);
      }
    }
  }
};

function setProperty(el, key, val) {
  if(isComponent(this)) {
    el.bee.$set(utils.hyphenToCamel(key), val)
  }else{
    setAttr(el, key, val)
  }
}

function removeProperty(el, key, undef) {
  if(isComponent(this)) {
    el.bee.$set(utils.hyphenToCamel(key), undef)
  }else{
    el.removeAttribute(key);
  }
}


//IE  `setAttribute` .
// `el[attr] = value`  `removeAttribute` .
function setAttr(el, attr, val){
  try{
    if(((attr in el) || attr === 'class')){
      if(attr === 'style' && el.style.setAttribute){
        el.style.setAttribute('cssText', val);
      }else if(attr === 'class'){
        el.className = val;
      }else{
        el[attr] = typeof el[attr] === 'boolean' ? true : val;
      }
    }
  }catch(e){}
  //chrome setattribute with `{{}}` will throw an error
  el.setAttribute(attr, val);
}

function isComponent (dir) {
  var component = dir.el.bee;
  return component && !component.__repeat && component != dir.vm;
}

},{"../utils.js":51}],33:[function(_dereq_,module,exports){
"use strict";

module.exports = {
  link: function() {
    this.initClass = this.el.className || ''
    this.keys = {};
  },
  update: function(classes) {
    var classStr = this.initClass
      , watcher = this.watcher
      , key
      ;

    //class  className  {className: 'key'} 
    if(typeof classes === 'string') {
      if(classes) {
        classStr += ' ' + classes;
      }
    }else{
      for(var className in classes) {
        key = classes[className]

        if(!this.keys[key]) {// key
          this.keys[key] = true;
          //, 
          this.vm.$watch(key, function() {
            watcher.update()
          })
        }
        if(this.vm.$get(key)) {
          classStr += ' ' + className
        }
      }
    }
    this.el.className = classStr;
  }
};

},{}],34:[function(_dereq_,module,exports){
//component as directive
var utils = _dereq_('../utils.js');
var domUtils = _dereq_('../dom-utils')
var checkBinding = _dereq_('../check-binding')

module.exports = {
  priority: -1
, watch: false
, unLink: function() {
    this.component && this.component.$destroy()
  }
, link: function() {
    var vm = this.vm;
    var el = this.el;
    var cstr = vm.constructor;
    var comp;
    var dirs, $data = {};
    var Comp = cstr.getComponent(this.path, vm.$context)
    var statics = {};

    if(Comp) {

      // `Bee.mount` 
      if(Comp === cstr && vm.__mountcall || el.bee && el.bee === vm) {
        return;
      }

      dirs = this.dirs.filter(function (dir) {
        return dir.type == 'attr' || dir.type == 'with';
      });

      dirs.forEach(function (dir) {
        var curPath, comPath;

        curPath = dir.path;
        if(dir.type === 'with') {
          //comPath = '$data'
          utils.extend(true, $data, vm.$get(curPath))

          //, 
          //TODO  b-with 
          vm.$watch(curPath, function (val) {
            comp && comp.$set(utils.extend({}, vm.$get(curPath)));
          })
        }else{
          comPath = utils.hyphenToCamel(dir.dirName);
          $data[comPath] = getProperty(dir)
          dir.el.removeAttribute(dir.dirName)
        }
      });

      //
      vm.__links = vm.__links.concat(checkBinding.walk.call(vm, el.childNodes));

      statics = domUtils.getAttrs(el)

      //
      var _dir;
      for(var attr in statics) {
        _dir = utils.camelToHyphen(attr);
        _dir = _dir.slice(vm.constructor.prefix.length)

        if(_dir in vm.constructor.directives) {
          delete statics[attr]
        }
      }

      this.component = comp = new Comp({
        $el: el,
        $isReplace: true,
        $context: vm,

        $data: utils.extend(true, {}, $data, statics)
      });
      el.bee = comp;

      return comp;
    }else{
      console.error('Component: ' + this.path + ' not defined!');
    }
  }
};

//, 
function getProperty(dir) {
  var textMap = dir.textMap, val
  val = textMap && textMap.length > 1 ? textMap.join('') : textMap[0]

  return utils.isPlainObject(val) ? utils.extend(true, {}, val) : val;
}

},{"../check-binding":28,"../dom-utils":43,"../utils.js":51}],35:[function(_dereq_,module,exports){
"use strict";

var domUtils = _dereq_('../dom-utils')
  , checkBinding = _dereq_('../check-binding')
  ;

module.exports = {
  replace: true
, anchor: true
, link: function() {
    this.watchers = [];
  }
, unLink: function() {
    this.watchers.forEach(function(watcher) {
      watcher.unwatch()
    });
  }
, update: function(tpl) {
    var nodes = this.getNodes()
    var parent = this.anchors.end.parentNode

    nodes.forEach(function(node) {
      parent.removeChild(node);
    });

    this.unLink();

    var content = domUtils.createContent(tpl)

    this.watchers = checkBinding.walk.call(this.vm, content)
    parent.insertBefore(content, this.anchors.end)
  }
}

},{"../check-binding":28,"../dom-utils":43}],36:[function(_dereq_,module,exports){
"use strict";

var checkBinding = _dereq_('../check-binding')
  , domUtils = _dereq_('../dom-utils')
  , doc = _dereq_('../env').document

module.exports = {
  anchor: true
, priority: 900
, terminal: true
, link: function() {
    this.watchers = [];

    if(this.el.content) {
      this.frag = this.el.content;
      this.el.parentNode.removeChild(this.el);
    }else{
      this.frag = doc.createDocumentFragment()
    }
    this.remove();
  }
, update: function(val) {
    if(val) {
      if(!this.state) { this.add() }
    }else{
      if(this.state) { this.remove(); }
    }
    this.state = val;
  }

, add: function() {
    var anchor = this.anchors.end;
    if(!this.walked) {
      this.walked = true;
      this.watchers = checkBinding.walk.call(this.vm, this.frag);
    }
    this.watchers.forEach(function(watcher) {
      watcher._hide = false;
      if(watcher._needUpdate) {
        watcher.update()
        watcher._needUpdate = false;
      }
    })
    anchor.parentNode && anchor.parentNode.insertBefore(this.frag, anchor);
  }
, remove: function() {
    var nodes = this.getNodes();

    for(var i = 0, l = nodes.length; i < l; i++) {
      this.frag.appendChild(nodes[i]);
    }

    this.watchers.forEach(function(watcher) {
      watcher._hide = true;
    })
  }
};

},{"../check-binding":28,"../dom-utils":43,"../env":44}],37:[function(_dereq_,module,exports){
"use strict";

var doc = _dereq_('../env.js').document
  , utils = _dereq_('../utils.js')
  , checkBinding = _dereq_('../check-binding')
  ;

var dirs = {};


dirs.text = {
  terminal: true
, replace: true
, update: function(val) {
    this.node.nodeValue = utils.isUndefined(val) ? '' : val;
  }
};


dirs.html = {
  terminal: true
, replace: true
, link: function() {
    this.nodes = [];
  }
, update: function(val) {
    var el = doc.createElement('div');
    el.innerHTML = utils.isUndefined(val) ? '' : val;

    var node;
    while(node = this.nodes.pop()) {
      node.parentNode && node.parentNode.removeChild(node);
    }

    var nodes = el.childNodes;
    while(node = nodes[0]) {
      this.nodes.push(node);
      this.el.insertBefore(node, this.node);
    }
  }
};

dirs.template = {
  priority: 10000
, watch: false
, link: function() {
    var nodes = this.el.childNodes
      , frag = doc.createDocumentFragment()
      ;

    while(nodes[0]) {
      frag.appendChild(nodes[0]);
    }

    this.el.content = frag;
    //this.el.setAttribute(this.nodeName, '');
  }
};

//,  URL 
dirs.src = {
  update: function(val) {
    this.el.src = val;
  }
};

dirs['with'] = {};

dirs['if'] = _dereq_('./if')
dirs.repeat = _dereq_('./repeat');
dirs.attr = _dereq_('./attr');
dirs.model = _dereq_('./model');
dirs.style = _dereq_('./style');
dirs.on = _dereq_('./on');
dirs.component = dirs.tag = _dereq_('./component');
dirs.content = _dereq_('./content')
dirs.ref = _dereq_('./ref')
dirs['class'] = _dereq_('./class.js')

module.exports = dirs;

},{"../check-binding":28,"../env.js":44,"../utils.js":51,"./attr":32,"./class.js":33,"./component":34,"./content":35,"./if":36,"./model":38,"./on":39,"./ref":40,"./repeat":41,"./style":42}],38:[function(_dereq_,module,exports){
"use strict";

var utils = _dereq_('../utils.js')
  , hasToken = _dereq_('../token.js').hasToken
  , events = _dereq_('../event-bind.js')
  , checkBinding = _dereq_('../check-binding')
  ;


module.exports = {
  teminal: true
, priority: -2
, link: function() {
    var keyPath = this.path;
    var vm = this.vm;

    if(!keyPath) { return false; }

    var comp = this.el
      , ev = 'change'
      , attr, compVal
      , value = attr = 'value'
      , isSetDefaut = utils.isUndefined(vm.$get(keyPath))// model 
      , crlf = /\r\n/g//IE 8  textarea  \n  \r\n. 

        //
      , update = function(val) {
          if(val === 0 && comp.type !== 'checkbox') { val = '0' }
          var newVal = (val || '') + ''
            , val = comp[attr]
            ;
          val && val.replace && (val = val.replace(crlf, '\n'));
          if(newVal !== val){ comp[attr] = newVal; }
        }

        // viewModel
      , handler = function() {
          var val = comp[value];

          val.replace && (val = val.replace(crlf, '\n'));
          vm.$set(keyPath, val);
        }
      , callHandler = function(e) {
          if(e && e.propertyName && e.propertyName !== attr) {
            return;
          }
          handler.apply(this, arguments)
        }
      , ie = utils.ie
      ;

    if(comp.bee) {
      // 
      comp = comp.bee;
      value = comp.$valuekey;
      if(value) {
        update = function(val) {
          comp.$replace(value, val)
        };
        handler = function() {
          vm.$replace(keyPath, comp.$get(value))
        }
        comp.$watch(value, function(val, oldValue) {
          val !== oldValue && handler()
        })
        compVal = vm.$get(keyPath)

        //,  key  `undefined` 
        if(utils.isUndefined(compVal)) {
          handler()
        }else{
          update(compVal)
        }
      }
    }else{
      //
      vm.__links = vm.__links.concat(checkBinding.walk.call(vm, comp.childNodes));

      //HTML 
      switch(comp.tagName) {
        default:
          value = attr = 'innerHTML';
          //ev += ' blur';
        case 'INPUT':
        case 'TEXTAREA':
          switch(comp.type) {
            case 'checkbox':
              value = attr = 'checked';
              //IE6, IE7  propertychange ?
              if(ie) { ev += ' click'; }
            break;
            case 'radio':
              attr = 'checked';
              if(ie) { ev += ' click'; }
              update = function(val) {
                comp.checked = comp.value === val + '';
              };
              isSetDefaut = comp.checked;
            break;
            default:
              if(!vm.$lazy){
                if('oninput' in comp){
                  ev += ' input';
                }
                //IE  input 
                if(ie) {
                  ev += ' keyup propertychange cut';
                }
              }
            break;
          }
        break;
        case 'SELECT':
          if(comp.multiple){
            handler = function() {
              var vals = [];
              for(var i = 0, l = comp.options.length; i < l; i++){
                if(comp.options[i].selected){ vals.push(comp.options[i].value) }
              }
              vm.$replace(keyPath, vals);
            };
            update = function(vals){
              if(vals && vals.length){
                for(var i = 0, l = comp.options.length; i < l; i++){
                  comp.options[i].selected = vals.indexOf(comp.options[i].value) !== -1;
                }
              }
            };
          }else{
            if(comp.hasAttribute && comp.hasAttribute('data-forcesync') || ('data-forcesync' in comp)) {
              update = function(val) {
                if(val === 0 && comp.type !== 'checkbox') { val = '0' }
                var newVal = (val || '') + ''
                  , val = comp[attr]
                  ;
                val && val.replace && (val = val.replace(crlf, '\n'));
                if(newVal !== val){
                  for(var i = 0, l = comp.options.length; i < l; i++){
                    if(comp.options[i].value === newVal + '') {
                      comp.options[i].selected = true;
                      comp[attr] = newVal;
                      break;
                    }
                  }
                  if(i == l) {
                    handler()
                  }
                }
              }
            }
          }
          isSetDefaut = isSetDefaut && !hasToken(comp[value]);
        break;
      }

      ev.split(/\s+/g).forEach(function(e){
        events.removeEvent(comp, e, callHandler);
        events.addEvent(comp, e, callHandler);
      });
      // model 
      if(comp[value] && isSetDefaut){
         handler();
      }
    }

    this.update = update;
  }
};

},{"../check-binding":28,"../event-bind.js":47,"../token.js":50,"../utils.js":51}],39:[function(_dereq_,module,exports){
"use strict";

//

var eventBind = _dereq_('../event-bind.js');
var utils = _dereq_('../utils')

module.exports = {
  watch: false
, sub: true
, priority: -3 // b-model . 
, immediate: false // watch  immediate  false ,  update 
, link: function() {
    var dir = this;
    if(this.subType){
      // be-on-click 
      eventBind.addEvent(this.el, this.subType, function() {
        dir.vm.$get(dir.path)
      })
    }else{
      //link  watcher  immediate ,
      // immediate  true  update 
      this.immediate = true;
      //this.update(this.vm.$get(this.path))
    }
  }
, update: function (events) {
    var selector, eventType;
    for(var name in events) {
      selector = name.split(/\s+/);
      eventType = selector.shift();
      selector = selector.join(' ');
      eventBind.addEvent(this.el, eventType, callHandler(this, selector, events[name]));
    }
  }
}

//
// IE8+
// event.currentTarget  event.delegateTarget  jQuery 
function callHandler (dir, selector, callback) {
  return function(e) {
    var cur = e.target || e.srcElement;
    var els = selector ? utils.toArray(dir.el.querySelectorAll(selector)) : [cur];
    do{
      if(els.indexOf(cur) >= 0) {
        e.delegateTarget = cur;//
        return callback.call(dir.vm, e)
      }
    }while(cur = cur.parentNode)
  }
}

},{"../event-bind.js":47,"../utils":51}],40:[function(_dereq_,module,exports){

var utils = _dereq_('../utils')

module.exports = {
  watch: false
, priority: -2 // ref  component 
, unLink: function() {
    if(!utils.isArray(this.ref)) {
      this.vm.$refs[this.path] = null;
    }
  }
, link: function() {
    var vm = this.vm
    // `repeat`  `ref`  `viewmodel`
    //ref   repeat  vm  this.el.bee  repeat  vm
    if(vm.__repeat && vm == this.el.bee){
      if(!vm.$index) {
        vm.$parent.$refs[this.path] = vm.__vmList;
      }
    }else{
      vm.$refs[this.path] = this.el.bee || this.el;
    }
  }
}

},{"../utils":51}],41:[function(_dereq_,module,exports){
"use strict";

var doc = _dereq_('../env.js').document
  , utils = _dereq_('../utils.js')
  , scope = _dereq_('../scope')
  ;

//
var arrayMethods = ['splice', 'push', 'pop', 'shift', 'unshift', 'sort', 'reverse'];

module.exports = {
  priority: 1000
, anchor: true
, terminal: true
, unLink: function(){
    this.vmList.forEach(function(vm){
      vm.$destroy()
    })
  }
, link: function() {
    var Bee = _dereq_('../bee')

    this.trackId = this.el.getAttribute('track-by')
    this.el.removeAttribute('track-by')

    // repeat 
    // `directives, components, filters` 
    this.cstr = Bee.extend({}, this.vm.constructor)

    //
    this.cstr.defaults = {};

    this.curArr = [];
    this.vmList = [];// VM list

    if(this.el.content) {
      this.frag = this.el.content;
      this.isRange = true
    }else{
      this.frag = this.el;
    }
    this.el.parentNode.removeChild(this.el);
  }
, update: function(items) {
    var curArr = this.curArr;
    var parentNode = this.anchors.end.parentNode;
    var that = this, vmList = this.vmList;
    var trackId = this.trackId;

    //TODO 
    var arrs = []; //repeat 

    if(utils.isArray(items)) {
      //  repeat 
      this.listPath = this.summary.paths.filter(function(path) {
        return !utils.isFunction(that.vm.$get(path))
      });

      //
      arrDiff(curArr, items, trackId).forEach(function(item) {
        var pos = indexByTrackId(item, curArr, trackId)
        curArr.splice(pos, 1)

        if(that.isRange) {
          getNodesByIndex(that, pos).forEach(function(node) {
            parentNode.removeChild(node)
          })
        }else{
          parentNode.removeChild(vmList[pos].$el)
        }
        vmList[pos].$destroy()
        vmList.splice(pos, 1)
      })

      items.forEach(function(item, i) {
        var pos = indexByTrackId(item, items, trackId, i)
          , oldPos = indexByTrackId(item, curArr, trackId, i)
          , vm, el, anchor
          ;

        //
        if(oldPos < 0) {

          el = this.frag.cloneNode(true)

          if(this.isRange) {
            anchor = doc.createComment('')
            el.childNodes.length ? el.insertBefore(anchor, el.childNodes[0]) : el.appendChild(anchor)
          }

          vm = new this.cstr(el, {
            $data: item,
            $index: pos,
            $root: this.vm.$root,
            $parent: this.vm,
            $context: this.vm.$context,
            _assignments: this.summary.assignments,
            __repeat: true,
            __anchor: anchor,
            __vmList: this.vmList
          });

          parentNode.insertBefore(vm.$el, getAnchor(that, pos))
          vmList.splice(pos, 0, vm);
          curArr.splice(pos, 0, item)

          // `_relativePath`, 
          //,  vm  update , .
          vm._relativePath = this.listPath;
        }else {

          //
          if (pos !== oldPos) {

            parentNode.insertBefore(getElByIndex(that, oldPos), getAnchor(that, pos))
            parentNode.insertBefore(getElByIndex(that, pos), getAnchor(that, oldPos + 1))

            vmList[oldPos] = [vmList[pos], vmList[pos] = vmList[oldPos]][0]
            curArr[oldPos] = [curArr[pos], curArr[pos] = curArr[oldPos]][0]
            vmList[pos].$index = pos
            vmList[pos].$update('$index')
          }
        }
      }.bind(this))

      //
      vmList.forEach(function(vm, i) {
        vm.$index = i
        vm.$el.$index = i
        vm.$update('$index', false)
      });

      this.listPath.forEach(function(localKey) {
        var local = that.vm.$get(localKey)
        utils.isArray(local) && arrs.push(local)
      })
      arrs.push(items)
      arrs.forEach(function(local) {
        var dirs = local.__dirs__;

        if(!dirs){
          //
          utils.extend(local, {
            $set: function(i, item) {
              local.splice(i, 1, utils.isObject(item) ? utils.extend({}, local[i], item) : item)
            },
            $replace: function(i, item) {
              local.splice(i, 1, item)
            },
            $remove: function(i) {
              local.splice(i, 1);
            }
          });
          arrayMethods.forEach(function(method) {
            local[method] = utils.afterFn(local[method], function() {
              dirs.forEach(function(dir) {
                dir.listPath.forEach(function(path) {
                  var reformed = scope.reformScope(dir.vm, path)
                  reformed.vm.$update(reformed.path)
                })
              })
            })
          });
          dirs = local.__dirs__  = [];
        }
        //
        //TODO 
        if(dirs.indexOf(that) === -1) {
          dirs.push(that)
        }
      })

    }else{
      //TODO 
    }
  }
};

function getAnchor(dir, index) {
  var vm = dir.vmList[index]
  return vm ? ( dir.isRange ? vm.__anchor : vm.$el ) : dir.anchors.end
}

//
function getNodesByIndex(dir, index) {
  var vmList = dir.vmList
    , anchor = vmList[index].__anchor
    , next = vmList[index + 1]
    ;
  return [anchor].concat(dir.getNodes(anchor, next && next.__anchor))
}

function getElByIndex (dir, index) {
  var frag = doc.createDocumentFragment()
  if(dir.isRange) {
    getNodesByIndex(dir, index).forEach(function(node) {
      frag.appendChild(node)
    })
  }else{
    frag.appendChild(dir.vmList[index].$el)
  }
  return frag
}

function arrDiff(arr1, arr2, trackId) {
  var arr2Copy = arr2.slice();
  return arr1.filter(function(el) {
    var result, index = indexByTrackId(el, arr2Copy, trackId)
    if(index < 0) {
      result = true
    }else{
      arr2Copy.splice(index, 1)
    }
    return result
  })
}

function indexByTrackId(item, list, trackId, startIndex) {
  startIndex = startIndex || 0;
  var index = list.indexOf(item, startIndex);
  if(index === -1 && trackId){
    for(var i = startIndex, item1; item1 = list[i]; i++) {
      if(item[trackId] ===  item1[trackId] && !utils.isUndefined(item[trackId])){
        index = i;
        break;
      }
    }
  }
  return index;
}

},{"../bee":27,"../env.js":44,"../scope":49,"../utils.js":51}],42:[function(_dereq_,module,exports){
"use strict";

//
var utils = _dereq_('../utils')

// px 
var pixelAttrs = [
  'width','height','min-width', 'min-height', 'max-width', 'max-height',
  'margin', 'margin-top', 'margin-right', 'margin-left', 'margin-bottom',
  'padding', 'padding-top', 'padding-right', 'padding-bottom', 'padding-left',
  'top', 'left', 'right', 'bottom'
]

// IE6, IE7  `el.style.getAttribute('cssText')`  `el.style.setAttribute('cssText')`  style 

module.exports = {
  link: function() {
    this.initStyle = this.el.style.getAttribute ? this.el.style.getAttribute('cssText') : this.el.getAttribute('style')
  },
  update: function(styles) {
    var el = this.el;
    var styleStr = this.initStyle ? this.initStyle.replace(/;?$/, ';') : '';
    var dashKey, val;

    if(typeof styles === 'string') {
      styleStr += styles;
    }else {
      for (var key in styles) {
        val = styles[key];

        //marginTop -> margin-top. 
        dashKey = utils.camelToHyphen(key);

        if (pixelAttrs.indexOf(dashKey) >= 0 && utils.isNumeric(val)) {
          val += 'px';
        }
        if(!utils.isUndefined(val)){
          styleStr += dashKey + ': ' + val + '; ';
        }
      }
    }
    if(el.style.setAttribute){
      // IE
      el.style.setAttribute('cssText', styleStr);
    }else{
      el.setAttribute('style', styleStr);
    }
  }
};

},{"../utils":51}],43:[function(_dereq_,module,exports){
"use strict";

var doc = _dereq_('./env.js').document
var utils = _dereq_('./utils')

module.exports = {
  ////nodelist  fragment 
  createContent: function createContent(tpl) {
    var content = doc.createDocumentFragment();
    var wraper;
    var nodes = [];
    if(utils.isObject(tpl)) {
      if(tpl.nodeName && tpl.nodeType) {
        //dom 
        content.appendChild(tpl);
      }else if('length' in tpl){
        //nodelist
        nodes = tpl;
      }
    }else {
      wraper = doc.createElement('div')
      // IE8 .  component 
      wraper.innerHTML = (tpl + '').trim();
      nodes = wraper.childNodes;
    }
    while(nodes[0]) {
      content.appendChild(nodes[0])
    }
    return content;
  },

  //
  getAttrs: function(el) {
    var attributes = el.attributes;
    var attrs = {};

    for(var i = attributes.length - 1; i >= 0; i--) {
      //
      attrs[utils.hyphenToCamel(attributes[i].nodeName)] = attributes[i].value;
    }

    return attrs;
  },

  hasAttr: function(el, attrName) {
    return el.hasAttribute ? el.hasAttribute(attrName) : !utils.isUndefined(el[attrName]);
  }
};

},{"./env.js":44,"./utils":51}],44:[function(_dereq_,module,exports){
(function(root){
  "use strict";

  exports.root = root;
  exports.document = root.document || _dereq_('jsdom').jsdom();

})((function() {return this})());

},{"jsdom":53}],45:[function(_dereq_,module,exports){
//ES5 and other staff shim for beejs

if(!Array.prototype.forEach){
  Array.prototype.forEach = function(fn, scope) {
    for(var i = 0, len = this.length; i < len; ++i) {
      if (i in this) {
        fn.call(scope, this[i], i, this);
      }
    }
  };
}

if(!Array.isArray){
  Array.isArray = function(val) {
    return ({}).toString.call(val) === '[object Array]'
  }
}

if(!String.prototype.trim) {
  String.prototype.trim = function() {
    return this.replace(/^\s+|\s+$/g,'');
  };
}

if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function (obj, start) {
    for (var i = (start || 0); i < this.length; i++) {
      if (this[i] === obj) {
        return i;
      }
    }
    return -1;
  }
}

if (!('lastIndexOf' in Array.prototype)) {
  Array.prototype.lastIndexOf= function(find, i /*opt*/) {
    if (i===undefined) i= this.length-1;
    if (i<0) i+= this.length;
    if (i>this.length-1) i= this.length-1;
    for (i++; i-->0;) /* i++ because from-argument is sadly inclusive */
      if (i in this && this[i]===find)
        return i;
    return -1;
  };
}

if (!Array.prototype.filter) {
  Array.prototype.filter = function(fun /*, thisArg */)
  {
    "use strict";

    if (this === void 0 || this === null)
      throw new TypeError();

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== "function") {
      throw new TypeError();
    }

    var res = [];
    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++) {
      if (i in t) {
        var val = t[i];

        // NOTE: Technically this should Object.defineProperty at
        //       the next index, as push can be affected by
        //       properties on Object.prototype and Array.prototype.
        //       But that method's new, and collisions should be
        //       rare, so use the more-compatible alternative.
        if (fun.call(thisArg, val, i, t)) {
          res.push(val);
        }
      }
    }

    return res;
  };
}

if (!Array.prototype.map) {
  Array.prototype.map = function(callback, thisArg) {

    var T, A, k;

    if (this == null) {
      throw new TypeError(" this is null or not defined");
    }

    var O = Object(this);
    var len = O.length >>> 0;

    if ({}.toString.call(callback) != "[object Function]") {
      throw new TypeError(callback + " is not a function");
    }

    if (thisArg) {
      T = thisArg;
    }

    A = new Array(len);

    k = 0;

    while(k < len) {

      var kValue, mappedValue;

      if (k in O) {

        kValue = O[ k ];

        mappedValue = callback.call(T, kValue, k, O);

        A[ k ] = mappedValue;
      }
      k++;
    }

    return A;
  };
}

if (!Function.prototype.bind) {
  Function.prototype.bind = function (oThis) {
    if (typeof this !== "function") {
      // closest thing possible to the ECMAScript 5 internal IsCallable function
      throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    }

    var aArgs = Array.prototype.slice.call(arguments, 1), 
        fToBind = this, 
        fNOP = function () {},
        fBound = function () {
          return fToBind.apply(this instanceof fNOP && oThis
                                 ? this
                                 : oThis,
                               aArgs.concat(Array.prototype.slice.call(arguments)));
        };

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();

    return fBound;
  };
}

if (!Object.keys) {
  Object.keys = function(o) {
    if (o !== Object(o)){
      throw new TypeError('Object.keys called on a non-object');
    }
    var k=[], p;
    for (p in o) {
      if (Object.prototype.hasOwnProperty.call(o,p)) {
        k.push(p);
      }
    }
    return k;
  }
}


var noop = function() {};
if (!window.console) {
  window.console = {
    log: noop
  , info: noop
  , debug: noop
  , warn: noop
  , error: noop
  }
}
},{}],46:[function(_dereq_,module,exports){
/**
 * 
 */

"use strict";

var scope = _dereq_('./scope')

var operators = {
  'unary': {
    '+': function(v) { return +v; }
  , '-': function(v) { return -v; }
  , '!': function(v) { return !v; }

  , '[': function(v){ return v; }
  , '{': function(v){
      var r = {};
      for(var i = 0, l = v.length; i < l; i++) {
        r[v[i][0]] = v[i][1];
      }
      return r;
    }
  , 'typeof': function(v){ return typeof v; }
  , 'new': function(v){ return new v }
  }

, 'binary': {
    '+': function(l, r) { return l + r; }
  , '-': function(l, r) { return l - r; }
  , '*': function(l, r) { return l * r; }
  , '/': function(l, r) { return l / r; }
  , '%': function(l, r) { return l % r; }
  , '<': function(l, r) { return l < r; }
  , '>': function(l, r) { return l > r; }
  , '<=': function(l, r) { return l <= r; }
  , '>=': function(l, r) { return l >= r; }
  , '==': function(l, r) { return l == r; }
  , '!=': function(l, r) { return l != r; }
  , '===': function(l, r) { return l === r; }
  , '!==': function(l, r) { return l !== r; }
  , '&&': function(l, r) { return l && r; }
  , '||': function(l, r) { return l || r; }
  , ',': function(l, r) { return l, r; }

  , '.': function(l, r) {
      var prev = this.first;
      // a[b].c 
      if(r && path && !(prev.arity === 'binary' && prev.value === '[')){
        path = path + '.' + r;
      }
      return l[r];
    }
  , '[': function(l, r) {
      if(typeof r !== 'undefined' && path){
        path = path + '.' + r;
      }
      return l[r];
    }

    //TODO  this  root
  , '(': function(l, r){ return l.apply(root, r) }
    //filter. name|filter
  , '|': function(l, r){ return callFilter(l, r, []) }
  , 'new': function(l, r){
      return l === Date ? new Function('return new Date(' + r.join(', ') + ')')() : new (Function.prototype.bind.apply(l, [null].concat(r)));
    }

  , 'in': function(l, r){
      if(this.repeat) {
        //repeat
        return r;
      }else{
        return l in r;
      }
    }
  , 'catchby': function(l, r) {
      if(l['catch']) {
        return l['catch'](r.bind(root))
      }else{
        summaryCall || console.error('catchby expect a promise')
        return l;
      }
    }
  }

, 'ternary': {
    '?': function(f, s, t) { return f ? s : t; }
  , '(': function(f, s, t) { return f[s].apply(f, t) }

    //filter. name | filter : arg2 : arg3
  , '|': function(f, s, t){ return callFilter(f, s, t) }
  }
};

function callFilter(arg, filter, args) {
  if(arg && arg.then) {
    return arg.then(function(data) {
      return filter.apply(root, [data].concat(args))
    });
  }else{
    return filter.apply(root, [arg].concat(args))
  }
}

var argName = ['first', 'second', 'third']
  , context, summary, summaryCall
  , path
  , self
  , root
  ;

// ast
var evaluate = function(tree) {
  var arity = tree.arity
    , value = tree.value
    , args = []
    , n = 0
    , arg
    , res
    ;

  //
  for(; n < 3; n++){
    arg = tree[argName[n]];
    if(arg){
      if(Array.isArray(arg)){
        args[n] = [];
        for(var i = 0, l = arg.length; i < l; i++){
          args[n].push(typeof arg[i].key === 'undefined' ?
            evaluate(arg[i]) : [arg[i].key, evaluate(arg[i])]);
        }
      }else{
        args[n] = evaluate(arg);
      }
    }
  }

  if(arity !== 'literal') {
    if(path && value !== '.' && value !== '[') {
      summary.paths[path] = true;
    }
    if(arity === 'name') {
      path = value;
    }
  }

  switch(arity){
    case 'unary':
    case 'binary':
    case 'ternary':
      try{
        res = getOperator(arity, value).apply(tree, args);
      }catch(e){
        !summaryCall && value == '(' && console.error(e);
      }
    break;
    case 'literal':
      res = value;
    break;
    case 'repeat':
      summary.assignments[value] = true;
    break;
    case 'name':
      res = getValue(value, context.locals);
    break;
    case 'filter':
      summary.filters[value] = true;
      res = context.filters[value];
    break;
    case 'this':
      res = context.locals;
    break;
  }
  return res;
};

function getOperator(arity, value){
  return operators[arity][value] || function() { return; }
}

function reset(scope, that) {
  summaryCall = true;
  if(scope) {
    root = scope.$root;
    summaryCall = false;
    context = {locals: scope || {}, filters: scope.constructor.filters || {}};
  }else{
    context = {filters: {}, locals: {}};
  }
  if(that){
    self = that;
  }

  summary = {filters: {}, paths: {}, assignments: {}};
  path = '';
}

//
var getValue = function(key, vm) {
  var reformed = scope.reformScope(vm, key)
  return reformed.vm[reformed.path]
}

//
//tree: parser  ast
//scope 
exports.eval = function(tree, scope, that) {
  reset(scope || {}, that);

  return evaluate(tree);
};

//
//return: {filters:[], paths: [], assignments: []}
exports.summary = function(tree) {
  reset();

  evaluate(tree);

  if(path) {
    summary.paths[path] = true;
  }
  for(var key in summary) {
    summary[key] = Object.keys(summary[key]);
  }
  return summary;
};

},{"./scope":49}],47:[function(_dereq_,module,exports){
"use strict";

exports.addEvent = function addEvent(el, event, handler) {
  if(el.addEventListener) {
    el.addEventListener(event, handler, false);
  }else{
    el.attachEvent('on' + event, handler);
  }
}

exports.removeEvent = function removeEvent(el, event, handler) {
  if(el.removeEventListener) {
    el.removeEventListener(event, handler);
  }else{
    el.detachEvent('on' + event, handler);
  }
}
},{}],48:[function(_dereq_,module,exports){
"use strict";
//Javascript expression parser modified form Crockford's TDOP parser
var create = Object.create || function (o) {
	function F() {}
	F.prototype = o;
	return new F();
};

var source;

var error = function (message, t) {
	t = t || this;
  var msg = message += " But found '" + t.value + "'" + (t.from ? " at " + t.from : "") + " in '" + source + "'";
  var e = new Error(msg);
	e.name = t.name = "SyntaxError";
	t.message = message;
  throw e;
};

var tokenize = function (code, prefix, suffix) {
	var c; // The current character.
	var from; // The index of the start of the token.
	var i = 0; // The index of the current character.
	var length = code.length;
	var n; // The number value.
	var q; // The quote character.
	var str; // The string value.

	var result = []; // An array to hold the results.

	// Make a token object.
	var make = function (type, value) {
		return {
			type : type,
			value : value,
			from : from,
			to : i
		};
	};

	// Begin tokenization. If the source string is empty, return nothing.
	if (!code) {
		return;
	}

	// Loop through code text, one character at a time.
	c = code.charAt(i);
	while (c) {
		from = i;

		if (c <= ' ') { // Ignore whitespace.
			i += 1;
			c = code.charAt(i);
		} else if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c === '$' || c === '_') { // name.
			str = c;
			i += 1;
			for (; ; ) {
				c = code.charAt(i);
				if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
					(c >= '0' && c <= '9') || c === '_') {
					str += c;
					i += 1;
				} else {
					break;
				}
			}
			result.push(make('name', str));
		} else if (c >= '0' && c <= '9') {
			// number.

			// A number cannot start with a decimal point. It must start with a digit,
			// possibly '0'.
			str = c;
			i += 1;

			// Look for more digits.
			for (; ; ) {
				c = code.charAt(i);
				if (c < '0' || c > '9') {
					break;
				}
				i += 1;
				str += c;
			}

			// Look for a decimal fraction part.
			if (c === '.') {
				i += 1;
				str += c;
				for (; ; ) {
					c = code.charAt(i);
					if (c < '0' || c > '9') {
						break;
					}
					i += 1;
					str += c;
				}
			}

			// Look for an exponent part.
			if (c === 'e' || c === 'E') {
				i += 1;
				str += c;
				c = code.charAt(i);
				if (c === '-' || c === '+') {
					i += 1;
					str += c;
					c = code.charAt(i);
				}
				if (c < '0' || c > '9') {
					error("Bad exponent", make('number', str));
				}
				do {
					i += 1;
					str += c;
					c = code.charAt(i);
				} while (c >= '0' && c <= '9');
			}

			// Make sure the next character is not a letter.

			if (c >= 'a' && c <= 'z') {
				str += c;
				i += 1;
				error("Bad number", make('number', str));
			}

			// Convert the string value to a number. If it is finite, then it is a good
			// token.

			n = +str;
			if (isFinite(n)) {
				result.push(make('number', n));
			} else {
				error("Bad number", make('number', str));
			}

			// string

		} else if (c === '\'' || c === '"') {
			str = '';
			q = c;
			i += 1;
			for (; ; ) {
				c = code.charAt(i);
				if (c < ' ') {
					make('string', str);
					error(c === '\n' || c === '\r' || c === '' ?
						"Unterminated string." :
						"Control character in string.", make('', str));
				}

				// Look for the closing quote.

				if (c === q) {
					break;
				}

				// Look for escapement.

				if (c === '\\') {
					i += 1;
					if (i >= length) {
						error("Unterminated string", make('string', str));
					}
					c = code.charAt(i);
					switch (c) {
					case 'b':
						c = '\b';
						break;
					case 'f':
						c = '\f';
						break;
					case 'n':
						c = '\n';
						break;
					case 'r':
						c = '\r';
						break;
					case 't':
						c = '\t';
						break;
					case 'u':
						if (i >= length) {
							error("Unterminated string", make('string', str));
						}
						c = parseInt(code.substr(i + 1, 4), 16);
						if (!isFinite(c) || c < 0) {
							error("Unterminated string", make('string', str));
						}
						c = String.fromCharCode(c);
						i += 4;
						break;
					}
				}
				str += c;
				i += 1;
			}
			i += 1;
			result.push(make('string', str));
			c = code.charAt(i);

			// combining

		} else if (prefix.indexOf(c) >= 0) {
			str = c;
			i += 1;
			while (true) {
				c = code.charAt(i);
				if (i >= length || suffix.indexOf(c) < 0) {
					break;
				}
				str += c;
				i += 1;
			}
			result.push(make('operator', str));

			// single-character operator

		} else {
			i += 1;
			result.push(make('operator', c));
			c = code.charAt(i);
		}
	}
	return result;
};

var make_parse = function (vars) {
	vars = vars || {};//
	var symbol_table = {};
	var token;
	var tokens;
	var token_nr;
	var context;

	var itself = function () {
		return this;
	};

	var find = function (n) {
		n.nud = itself;
		n.led = null;
		n.std = null;
		n.lbp = 0;
		return n;
	};

	var advance = function (id) {
		var a, o, t, v;
		if (id && token.id !== id) {
			error("Expected '" + id + "'.", token);
		}
		if (token_nr >= tokens.length) {
			token = symbol_table["(end)"];
			return;
		}
		t = tokens[token_nr];
		token_nr += 1;
		v = t.value;
		a = t.type;
		if ((a === "operator" || a !== 'string') && v in symbol_table) {
			//true, false 
			o = symbol_table[v];
			if (!o) {
				error("Unknown operator.", t);
			}
		} else if (a === "name") {
			o = find(t);
		} else if (a === "string" || a === "number" || a === "regexp") {
			o = symbol_table["(literal)"];
			a = "literal";
		} else {
			error("Unexpected token.", t);
		}
		token = create(o);
		token.from = t.from;
		token.to = t.to;
		token.value = v;
		token.arity = a;
		return token;
	};

  //
  //rbp: right binding power 
	var expression = function (rbp) {
		var left;
		var t = token;
		advance();
		left = t.nud();
		while (rbp < token.lbp) {
			t = token;
			advance();
			left = t.led(left);
		}
		return left;
	};

	var original_symbol = {
		nud : function () {
			error("Undefined.", this);
		},
		led : function (left) {
			error("Missing operator.", this);
		}
	};

	var symbol = function (id, bp) {
		var s = symbol_table[id];
		bp = bp || 0;
		if (s) {
			if (bp >= s.lbp) {
				s.lbp = bp;
			}
		} else {
			s = create(original_symbol);
			s.id = s.value = id;
			s.lbp = bp;
			symbol_table[id] = s;
		}
		return s;
	};

	var constant = function (s, v, a) {
		var x = symbol(s);
		x.nud = function () {
			this.value = symbol_table[this.id].value;
			this.arity = "literal";
			return this;
		};
		x.value = v;
		return x;
	};

	var infix = function (id, bp, led) {
		var s = symbol(id, bp);
		s.led = led || function (left) {
			this.first = left;
			this.second = expression(bp);
			this.arity = "binary";
			return this;
		};
		return s;
	};

	var infixr = function (id, bp, led) {
		var s = symbol(id, bp);
		s.led = led || function (left) {
			this.first = left;
			this.second = expression(bp - 1);
			this.arity = "binary";
			return this;
		};
		return s;
	};

	var prefix = function (id, nud) {
		var s = symbol(id);
		s.nud = nud || function () {
			this.first = expression(70);
			this.arity = "unary";
			return this;
		};
		return s;
	};

	symbol("(end)");
	symbol("(name)");
	symbol(":");
	symbol(")");
	symbol("]");
	symbol("}");
	symbol(",");

	constant("true", true);
	constant("false", false);
	constant("null", null);
	constant("undefined");

	constant("Math", Math);
	constant("Date", Date);
	for(var v in vars) {
		constant(v, vars[v]);
	}

	symbol("(literal)").nud = itself;

	symbol("this").nud = function () {
	  this.arity = "this";
	  return this;
	};

	//Operator Precedence:
	//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

  //infix(',', 1);
	infix("?", 20, function (left) {
		this.first = left;
		this.second = expression(0);
		advance(":");
		this.third = expression(0);
		this.arity = "ternary";
		return this;
	});

	infixr("&&", 31);
	infixr("||", 30);

	infixr("===", 40);
	infixr("!==", 40);

	infixr("==", 40);
	infixr("!=", 40);

	infixr("<", 40);
	infixr("<=", 40);
	infixr(">", 40);
	infixr(">=", 40);

	infix("in", 45, function (left) {
		this.first = left;
		this.second = expression(0);
		this.arity = "binary";
		if (context === 'repeat') {
			// `in` at repeat block
			left.arity = 'repeat';
			this.repeat = true;
		}
		return this;
	});

	infix("+", 50);
	infix("-", 50);

	infix("*", 60);
	infix("/", 60);
	infix("%", 60);

	infix("(", 75, function (left) {
		var a = [];
		if (left.id === "." || left.id === "[") {
			this.arity = "ternary";
			this.first = left.first;
			this.second = left.second;
			this.third = a;
		} else {
			this.arity = "binary";
			this.first = left;
			this.second = a;
			if ((left.arity !== "unary" || left.id !== "function") &&
				left.arity !== "name" && left.arity !== "literal" && left.id !== "(" &&
				left.id !== "&&" && left.id !== "||" && left.id !== "?") {
				error("Expected a variable name.", left);
			}
		}
		if (token.id !== ")") {
			while (true) {
				a.push(expression(1));
				if (token.id !== ",") {
					break;
				}
				advance(",");
			}
		}
		advance(")");
		return this;
	});

	infix(".", 80, function (left) {
		this.first = left;
		if (token.arity !== "name") {
			error("Expected a property name.", token);
		}
		token.arity = "literal";
		this.second = token;
		this.arity = "binary";
		advance();
		return this;
	});

	infix("[", 60, function (left) {
		this.first = left;
		this.second = expression(0);
		this.arity = "binary";
		advance("]");
		return this;
	});

	//filter
	infix("|", 10, function (left) {
		var a;
		this.first = left;
		token.arity = 'filter';
		this.second = expression(10);
		this.arity = 'binary';
		if (token.id === ':') {
			this.arity = 'ternary';
			this.third = a = [];
			while (true) {
				advance(':');
				a.push(expression(10));
				if (token.id !== ":") {
					break;
				}
			}
		}
		return this;
	});
  infix('catchby', 10);

	prefix("!");
	prefix("-");
	prefix("typeof");

	prefix("(", function () {
		var e = expression(0);
		advance(")");
		return e;
	});

	prefix("[", function () {
		var a = [];
		if (token.id !== "]") {
			while (true) {
				a.push(expression(1));
				if (token.id !== ",") {
					break;
				}
				advance(",");
			}
		}
		advance("]");
		this.first = a;
		this.arity = "unary";
		return this;
	});

	prefix("{", function () {
		var a = [],	n, v;
		if (token.id !== "}") {
			while (true) {
				n = token;
				if (n.arity !== "name" && n.arity !== "literal") {
					error("Bad property name: ", token);
				}
				advance();
				advance(":");
				v = expression(1);
				v.key = n.value;
				a.push(v);
				if (token.id !== ",") {
					break;
				}
				advance(",");
			}
		}
		advance("}");
		this.first = a;
		this.arity = "unary";
		return this;
	});

	prefix('new', function () {
		var a = [];
		this.first = expression(79);
		if(token.id === '(') {
			advance("(");
			this.arity = 'binary';
			this.second = a;
			while (true) {
				a.push(expression(1));
				if (token.id !== ",") {
					break;
				}
				advance(",");
			}
			advance(")");
		}else{
			this.arity = "unary";
		}
		return this;
	});

	//_source: 
	//_context: 
	return function (_source, _context) {
    source = _source;
		tokens = tokenize(_source, '=<>!+-*&|/%^', '=<>&|');
		token_nr = 0;
		context = _context;
		advance();
		var s = expression(0);
		advance("(end)");
		return s;
	};
};

exports.parse = make_parse();

},{}],49:[function(_dereq_,module,exports){
"use strict";

var utils = _dereq_('./utils');

// vm  vm
var reformScope = function (vm, path) {
  var paths = utils.parseKeyPath(path);
  var cur = vm, local = paths[0];
  var ass, curVm = cur;

  while(cur) {
    curVm = cur;
    ass = cur._assignments;
    if( cur.__repeat) {
      if (ass && ass.length) {
        //  repeat 
        if (local === '$index' || local === '$parent') {
          break;
        } else if (local === ass[0]) {
          //key
          if (paths.length === 1) {
            paths[0] = '$data';
          } else {
            paths.shift()
          }
          break;
        }
      } else {
        // repeat
        if (path in cur) {
          break;
        }
      }
    }
    cur = cur.$parent;
  }

  return { vm: curVm, path: paths.join('.') }
};


exports.reformScope = reformScope;

},{"./utils":51}],50:[function(_dereq_,module,exports){
var tokenReg = /{{({(.+?)}|.+?)}}/g;

//
function hasToken(str) {
  tokenReg.lastIndex = 0;
  return str && tokenReg.test(str);
}

function parseToken(value) {
  var tokens = []
    , textMap = []
    , start = 0
    , val, token
    ;

  tokenReg.lastIndex = 0;

  while((val = tokenReg.exec(value))){
    if(tokenReg.lastIndex - start > val[0].length){
      textMap.push(value.slice(start, tokenReg.lastIndex - val[0].length));
    }

    token = {
      escape: !val[2]
    , path: (val[2] || val[1]).trim()
    , position: textMap.length
    , textMap: textMap
    };

    tokens.push(token);

    //(), , 
    textMap.push(val[0]);

    start = tokenReg.lastIndex;
  }

  if(value.length > start){
    textMap.push(value.slice(start, value.length));
  }

  tokens.textMap = textMap;

  return tokens;
}

exports.hasToken = hasToken;

exports.parseToken = parseToken;

},{}],51:[function(_dereq_,module,exports){
"use strict";

//utils
//---

var doc = _dereq_('./env.js').document;

var keyPathReg = /(?:\.|\[)/g
  , bra = /\]/g
  ;

// keyPath 
//path.key, path[key] --> ['path', 'key']
function parseKeyPath(keyPath){
  return keyPath.replace(bra, '').split(keyPathReg);
}

/**
 * 
 * @static
 * @param {Boolean} [deep=false] 
 * @param {Object} target 
 * @param {Object} [object...] 
 * @returns {Object}  target 
 */
function extend(/* deep, target, object... */) {
  var options
    , name, src, copy, copyIsArray, clone
    , target = arguments[0] || {}
    , i = 1
    , length = arguments.length
    , deep = false, isArray
    ;

  // Handle a deep copy situation
  if (typeof target === "boolean") {
    deep = target;

    // skip the boolean and the target
    target = arguments[ i ] || {};
    i++;
  }

  // Handle case when target is a string or something (possible in deep copy)
  if (typeof target !== "object" && !utils.isFunction(target)) {
    target = {};
  }

  for ( ; i < length; i++ ) {
    // Only deal with non-null/undefined values
    if ( (options = arguments[ i ]) != null ) {
      isArray = utils.isArray(options)
      // Extend the base object
      for ( name in options ) {
        //android 2.3 browser can enum the prototype of constructor...
        if(name !== 'prototype' && !(isArray && !(name >= 0))){
          src = target[ name ];
          copy = options[ name ];


          // Recurse if we're merging plain objects or arrays
          if ( deep && copy && ( utils.isPlainObject(copy) || (copyIsArray = utils.isArray(copy)) ) ) {

            // Prevent never-ending loop
            if ( target === copy ) {
              continue;
            }
            if ( copyIsArray ) {
              copyIsArray = false;
              clone = src && utils.isArray(src) ? src : [];

            } else {
              clone = src && utils.isPlainObject(src) ? src : {};
            }

            // Never move original objects, clone them
            target[ name ] = extend( deep, clone, copy);

            // Don't bring in undefined values
          } else if ( !utils.isUndefined(copy) && typeof target !== 'string') {
            //,  firefox 
            target[name] = copy;
          }
        }
      }
    }
  }

  // Return the modified object
  return target;
}

var create = Object.create || function (o) {
  function F() {}
  F.prototype = o;
  return new F();
};

var deepGet = function (keyStr, obj) {
  var chain, cur = obj, key;
  if(keyStr){
    chain = parseKeyPath(keyStr);
    for(var i = 0, l = chain.length; i < l; i++) {
      key = chain[i];
      if(cur){
        cur = cur[key];
      }else{
        return;
      }
    }
  }
  return cur;
}

//html , .
//
//attr-name --> attrName
//attr--name --> attr-name
var hyphensReg = /-(-?)([a-z])/ig;
var hyphenToCamel = function(attrName) {
  return attrName.replace(hyphensReg, function(s, dash, char) {
    return dash ? dash + char : char.toUpperCase();
  })
}

//
var camelReg = /([A-Z])/g;
var camelToHyphen = function(key) {
  return key.replace(camelReg, function (upperChar) {
    return '-' + upperChar.toLowerCase();
  })
}

var utils = {
  noop: function (){}
, ie: (function(){
    var undef,
        v = 3,
        div = doc.createElement('div'),
        all = div.getElementsByTagName('i');

    while (
      div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->',
      all[0]
    );

    return v > 4 ? v : undef;

  }())

, isObject: function (val) {
    return typeof val === 'object' && val !== null;
  }

, isUndefined: function (val) {
    return typeof val === 'undefined';
  }

, isFunction: function (val){
    return typeof val === 'function';
  }

, isArray: function (val) {
    if(utils.ie){
      //IE 9  IE 
      return val && val.constructor + '' === Array + '';
    }else{
      return Array.isArray(val);
    }
  }
, isNumeric: function(val) {
    return !utils.isArray(val) && val - parseFloat(val) + 1 >= 0;
  }
  //
, isPlainObject: function (o){
    if (!o || ({}).toString.call(o) !== '[object Object]' || o.nodeType || o === o.window) {
      return false;
    }else{
      return true;
    }
  }

  //. oriFn , fn 
  // breakCheck , breakCheck 
, beforeFn: function (oriFn, fn, breakCheck) {
    return function() {
      var ret = fn.apply(this, arguments);
      if(breakCheck && breakCheck.call(this, ret, arguments)){
        return ret;
      }
      return oriFn.apply(this, arguments);
    };
  }

, afterFn: function (oriFn, fn, breakCheck) {
    return function() {
      var ret = oriFn.apply(this, arguments);
      if(breakCheck && breakCheck.call(this, ret, arguments)){
        return ret;
      }
      fn.apply(this, arguments);
      return ret;
    }
  }

, parseKeyPath: parseKeyPath

, deepSet: function (keyStr, value, obj) {
    if(keyStr){
      var chain = parseKeyPath(keyStr)
        , cur = obj
        ;
      chain.forEach(function(key, i) {
        if(i === chain.length - 1){
          cur[key] = value;
        }else{
          if(cur && cur.hasOwnProperty(key)){
            cur = cur[key];
          }else{
            cur[key] = {};
            cur = cur[key];
          }
        }
      });
    }else{
      extend(obj, value);
    }
    return obj;
  }
, extend: extend
, create: create
, toArray: function(arrLike) {
    var arr = [];

    try{
      //IE 8  dom 
      arr = Array.prototype.slice.call(arrLike)
    }catch (e){
      for(var i = 0, l = arrLike.length; i < l; i++) {
        arr[i] = arrLike[i]
      }
    }
    return arr;
  }
, hyphenToCamel: hyphenToCamel
, camelToHyphen: camelToHyphen
};

module.exports = utils;

},{"./env.js":44}],52:[function(_dereq_,module,exports){
"use strict";

var evaluate = _dereq_('./eval.js')
  , utils = _dereq_('./utils.js')
  , parse = _dereq_('./parse.js').parse
  , reformScope = _dereq_('./scope').reformScope
  ;

var summaryCache = {};

/**
 *  directive  watcher
 * @param {Bee} vm  directive 
 * @param {Directive} dir
 */
function Watcher(vm, dir) {
  var reformed, path, curVm = vm, watchers = [];
  var summary = summaryCache[dir.path]

  dir.watcher = this;

  this.state = 1;
  this.dir = dir;
  this.vm = vm;
  this.watchers = [];

  this.val = NaN;

  dir.parse();

  if(!summary || summary._type !== dir.type){
    summary = evaluate.summary(dir.ast);
    summary._type = dir.type;
    summaryCache[dir.path] = summary;
  }
  dir.summary = summary

  // watcher 
  for(var i = 0, l = dir.summary.paths.length; i < l; i++) {
    reformed = reformScope(vm, dir.summary.paths[i])
    curVm = reformed.vm
    path = reformed.path
    if(dir.watch) {
      curVm._watchers[path] = curVm._watchers[path] || [];
      curVm._watchers[path].push(this);
      watchers = curVm._watchers[path];
    }else{
      watchers = [this];
    }
    // key  watchers 
    this.watchers.push( watchers );
  }

  //
  dir.immediate !== false && this.update();
}

// vm  watcher
function unwatch (vm, exp, callback) {
  var summary;
  try {
    summary = evaluate.summary(parse(exp))
  }catch (e){
    e.message = 'SyntaxError in "' + exp + '" | ' + e.message;
    console.error(e);
  }
  summary.paths.forEach(function(path) {
    var watchers = vm._watchers[path] || [], update;

    for(var i = watchers.length - 1; i >= 0; i--){
      update = watchers[i].dir.update;
      if(update === callback || update._originFn === callback){
        watchers[i].unwatch()
      }
    }
  })
}

function addWatcher(dir) {
  if(dir.path) {
    return new Watcher(this, dir);
  }
}

Watcher.unwatch = unwatch;
Watcher.addWatcher = addWatcher;

// keyPath  watchers
Watcher.getWatchers = function getWatchers(vm, keyPath) {
  var _watchers = vm._watchers, watchers = [];
  var point;
  for(var key in _watchers) {
    point = key.charAt(keyPath.length);
    if(key.indexOf(keyPath) === 0 && (point === '.')) {
      watchers = watchers.concat(_watchers[key])
    }
  }
  return watchers
}

function watcherUpdate (val) {
  var oldValue = this.val;
  this.val = val;
  this.dir.update(val, oldValue);
}

utils.extend(Watcher.prototype, {
  // view
  update: function() {
    var that = this
      , newVal
      ;

    if(this._hide) {
      this._needUpdate = true;
      return;
    }
    newVal = this.dir.getValue(this.vm);

    //
    if(newVal !== this.val || utils.isObject(newVal)){
      if(newVal && newVal.then) {
        //a promise
        newVal.then(function(val) {
          watcherUpdate.call(that, val);
        });
      }else{
        watcherUpdate.call(this, newVal);
      }
    }
  },
  //
  unwatch: function() {
    this.watchers.forEach(function(watchers) {
      for(var i = watchers.length - 1; i >= 0; i--){
        if(watchers[i] === this){
          if(this.state){
            watchers[i].dir.unLink();
            this.state = 0;
          }
          watchers.splice(i, 1);
        }
      }
    }.bind(this))
    this.watchers = [];
  }
});

module.exports = Watcher

},{"./eval.js":46,"./parse.js":48,"./scope":49,"./utils.js":51}],53:[function(_dereq_,module,exports){

},{}],54:[function(_dereq_,module,exports){
var pSlice = Array.prototype.slice;
var objectKeys = _dereq_('./lib/keys.js');
var isArguments = _dereq_('./lib/is_arguments.js');

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}

},{"./lib/is_arguments.js":55,"./lib/keys.js":56}],55:[function(_dereq_,module,exports){
var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};

},{}],56:[function(_dereq_,module,exports){
exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}

},{}]},{},[22])(22)
});
})

//  \\
//  Raphal 2.1.2 - JavaScript Vector Library                           \\
//  \\
//  Copyright  2008-2012 Dmitry Baranovskiy (http://raphaeljs.com)     \\
//  Copyright  2008-2012 Sencha Labs (http://sencha.com)               \\
//  \\
//  Licensed under the MIT (http://raphaeljs.com/license.html) license. \\
//  \\
// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//  \\
//  Eve 0.4.2 - JavaScript Events Library                       \\
//  \\
//  Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/)  \\
//  \\

define('lib/raphael', function(require, exports, module) {
(function (glob) {
    var version = "0.4.2",
        has = "hasOwnProperty",
        separator = /[\.\/]/,
        wildcard = "*",
        fun = function () {},
        numsort = function (a, b) {
            return a - b;
        },
        current_event,
        stop,
        events = {n: {}},
    /*\
     * eve
     [ method ]

     * Fires event with given `name`, given scope and other parameters.

     > Arguments

     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
     - scope (object) context for the event handlers
     - varargs (...) the rest of arguments will be sent to event handlers

     = (object) array of returned values from the listeners
    \*/
        eve = function (name, scope) {
			name = String(name);
            var e = events,
                oldstop = stop,
                args = Array.prototype.slice.call(arguments, 2),
                listeners = eve.listeners(name),
                z = 0,
                f = false,
                l,
                indexed = [],
                queue = {},
                out = [],
                ce = current_event,
                errors = [];
            current_event = name;
            stop = 0;
            for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
                indexed.push(listeners[i].zIndex);
                if (listeners[i].zIndex < 0) {
                    queue[listeners[i].zIndex] = listeners[i];
                }
            }
            indexed.sort(numsort);
            while (indexed[z] < 0) {
                l = queue[indexed[z++]];
                out.push(l.apply(scope, args));
                if (stop) {
                    stop = oldstop;
                    return out;
                }
            }
            for (i = 0; i < ii; i++) {
                l = listeners[i];
                if ("zIndex" in l) {
                    if (l.zIndex == indexed[z]) {
                        out.push(l.apply(scope, args));
                        if (stop) {
                            break;
                        }
                        do {
                            z++;
                            l = queue[indexed[z]];
                            l && out.push(l.apply(scope, args));
                            if (stop) {
                                break;
                            }
                        } while (l)
                    } else {
                        queue[l.zIndex] = l;
                    }
                } else {
                    out.push(l.apply(scope, args));
                    if (stop) {
                        break;
                    }
                }
            }
            stop = oldstop;
            current_event = ce;
            return out.length ? out : null;
        };
		// Undocumented. Debug only.
		eve._events = events;
    /*\
     * eve.listeners
     [ method ]

     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

     > Arguments

     - name (string) name of the event, dot (`.`) or slash (`/`) separated

     = (array) array of event handlers
    \*/
    eve.listeners = function (name) {
        var names = name.split(separator),
            e = events,
            item,
            items,
            k,
            i,
            ii,
            j,
            jj,
            nes,
            es = [e],
            out = [];
        for (i = 0, ii = names.length; i < ii; i++) {
            nes = [];
            for (j = 0, jj = es.length; j < jj; j++) {
                e = es[j].n;
                items = [e[names[i]], e[wildcard]];
                k = 2;
                while (k--) {
                    item = items[k];
                    if (item) {
                        nes.push(item);
                        out = out.concat(item.f || []);
                    }
                }
            }
            es = nes;
        }
        return out;
    };
    
    /*\
     * eve.on
     [ method ]
     **
     * Binds given event handler with a given name. You can use wildcards `*` for the names:
     | eve.on("*.under.*", f);
     | eve("mouse.under.floor"); // triggers f
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. 
     > Example:
     | eve.on("mouse", eatIt)(2);
     | eve.on("mouse", scream);
     | eve.on("mouse", catchIt)(1);
     * This will ensure that `catchIt()` function will be called before `eatIt()`.
	 *
     * If you want to put your handler before non-indexed handlers, specify a negative value.
     * Note: I assume most of the time you dont need to worry about z-index, but its nice to have this feature just in case.
    \*/
    eve.on = function (name, f) {
		name = String(name);
		if (typeof f != "function") {
			return function () {};
		}
        var names = name.split(separator),
            e = events;
        for (var i = 0, ii = names.length; i < ii; i++) {
            e = e.n;
            e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});
        }
        e.f = e.f || [];
        for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
            return fun;
        }
        e.f.push(f);
        return function (zIndex) {
            if (+zIndex == +zIndex) {
                f.zIndex = +zIndex;
            }
        };
    };
    /*\
     * eve.f
     [ method ]
     **
     * Returns function that will fire given event with optional arguments.
	 * Arguments that will be passed to the result function will be also
	 * concated to the list of final arguments.
 	 | el.onclick = eve.f("click", 1, 2);
 	 | eve.on("click", function (a, b, c) {
 	 |     console.log(a, b, c); // 1, 2, [event object]
 	 | });
     > Arguments
	 - event (string) event name
	 - varargs () and any other arguments
	 = (function) possible event handler function
    \*/
	eve.f = function (event) {
		var attrs = [].slice.call(arguments, 1);
		return function () {
			eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
		};
	};
    /*\
     * eve.stop
     [ method ]
     **
     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
    \*/
    eve.stop = function () {
        stop = 1;
    };
    /*\
     * eve.nt
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     > Arguments
     **
     - subname (string) #optional subname of the event
     **
     = (string) name of the event, if `subname` is not specified
     * or
     = (boolean) `true`, if current events name contains `subname`
    \*/
    eve.nt = function (subname) {
        if (subname) {
            return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(current_event);
        }
        return current_event;
    };
    /*\
     * eve.nts
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     **
     = (array) names of the event
    \*/
    eve.nts = function () {
        return current_event.split(separator);
    };
    /*\
     * eve.off
     [ method ]
     **
     * Removes given function from the list of event listeners assigned to given name.
	 * If no arguments specified all the events will be cleared.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
    \*/
    /*\
     * eve.unbind
     [ method ]
     **
     * See @eve.off
    \*/
    eve.off = eve.unbind = function (name, f) {
		if (!name) {
		    eve._events = events = {n: {}};
			return;
		}
        var names = name.split(separator),
            e,
            key,
            splice,
            i, ii, j, jj,
            cur = [events];
        for (i = 0, ii = names.length; i < ii; i++) {
            for (j = 0; j < cur.length; j += splice.length - 2) {
                splice = [j, 1];
                e = cur[j].n;
                if (names[i] != wildcard) {
                    if (e[names[i]]) {
                        splice.push(e[names[i]]);
                    }
                } else {
                    for (key in e) if (e[has](key)) {
                        splice.push(e[key]);
                    }
                }
                cur.splice.apply(cur, splice);
            }
        }
        for (i = 0, ii = cur.length; i < ii; i++) {
            e = cur[i];
            while (e.n) {
                if (f) {
                    if (e.f) {
                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
                            e.f.splice(j, 1);
                            break;
                        }
                        !e.f.length && delete e.f;
                    }
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        var funcs = e.n[key].f;
                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
                            funcs.splice(j, 1);
                            break;
                        }
                        !funcs.length && delete e.n[key].f;
                    }
                } else {
                    delete e.f;
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        delete e.n[key].f;
                    }
                }
                e = e.n;
            }
        }
    };
    /*\
     * eve.once
     [ method ]
     **
     * Binds given event handler with a given name to only run once then unbind itself.
     | eve.once("login", f);
     | eve("login"); // triggers f
     | eve("login"); // no listeners
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) same return function as @eve.on
    \*/
    eve.once = function (name, f) {
        var f2 = function () {
            eve.unbind(name, f2);
            return f.apply(this, arguments);
        };
        return eve.on(name, f2);
    };
    /*\
     * eve.version
     [ property (string) ]
     **
     * Current version of the library.
    \*/
    eve.version = version;
    eve.toString = function () {
        return "You are running Eve " + version;
    };
    //(typeof module != "undefined" && module.exports) ? (module.exports = eve) : (typeof define != "undefined" ? (define("eve", [], function() { return eve; })) : (glob.eve = eve));
    glob.eve = eve
})(window || this);
//  \\
//  "Raphal 2.1.2" - JavaScript Vector Library                          \\
//  \\
//  Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)    \\
//  Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)              \\
//  Licensed under the MIT (http://raphaeljs.com/license.html) license.  \\
//  \\

(function (glob, factory) {
    // AMD support
    if (typeof define === "function" && define.amd) {
        // Define as an anonymous module
        define(["eve"], function( eve ) {
            return factory(glob, eve);
        });
    } else {
        // Browser globals (glob is window)
        // Raphael adds itself to window
        factory(glob, glob.eve);
    }
}(this, function (window, eve) {
    /*\
     * Raphael
     [ method ]
     **
     * Creates a canvas object on which to draw.
     * You must do this first, as all future calls to drawing methods
     * from this instance will be bound to this canvas.
     > Parameters
     **
     - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface
     - width (number)
     - height (number)
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - x (number)
     - y (number)
     - width (number)
     - height (number)
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eves DOMLoad event. In this case method returns `undefined`.
     = (object) @Paper
     > Usage
     | // Each of the following examples create a canvas
     | // that is 320px wide by 200px high.
     | // Canvas is created at the viewports 10,50 coordinate.
     | var paper = Raphael(10, 50, 320, 200);
     | // Canvas is created at the top left corner of the #notepad element
     | // (or its top right corner in dir="rtl" elements)
     | var paper = Raphael(document.getElementById("notepad"), 320, 200);
     | // Same as above
     | var paper = Raphael("notepad", 320, 200);
     | // Image dump
     | var set = Raphael(["notepad", 320, 200, {
     |     type: "rect",
     |     x: 10,
     |     y: 10,
     |     width: 25,
     |     height: 25,
     |     stroke: "#f00"
     | }, {
     |     type: "text",
     |     x: 30,
     |     y: 40,
     |     text: "Dump"
     | }]);
    \*/
    function R(first) {
        if (R.is(first, "function")) {
            return loaded ? first() : eve.on("raphael.DOMload", first);
        } else if (R.is(first, array)) {
            return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);
        } else {
            var args = Array.prototype.slice.call(arguments, 0);
            if (R.is(args[args.length - 1], "function")) {
                var f = args.pop();
                return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on("raphael.DOMload", function () {
                    f.call(R._engine.create[apply](R, args));
                });
            } else {
                return R._engine.create[apply](R, arguments);
            }
        }
    }
    R.version = "2.1.2";
    R.eve = eve;
    var loaded,
        separator = /[, ]+/,
        elements = {circle: 1, rect: 1, path: 1, ellipse: 1, text: 1, image: 1},
        formatrg = /\{(\d+)\}/g,
        proto = "prototype",
        has = "hasOwnProperty",
        g = {
            doc: document,
            win: window
        },
        oldRaphael = {
            was: Object.prototype[has].call(g.win, "Raphael"),
            is: g.win.Raphael
        },
        Paper = function () {
            /*\
             * Paper.ca
             [ property (object) ]
             **
             * Shortcut for @Paper.customAttributes
            \*/
            /*\
             * Paper.customAttributes
             [ property (object) ]
             **
             * If you have a set of attributes that you would like to represent
             * as a function of some number you can do it easily with custom attributes:
             > Usage
             | paper.customAttributes.hue = function (num) {
             |     num = num % 1;
             |     return {fill: "hsb(" + num + ", 0.75, 1)"};
             | };
             | // Custom attribute hue will change fill
             | // to be given hue with fixed saturation and brightness.
             | // Now you can use it like this:
             | var c = paper.circle(10, 10, 10).attr({hue: .45});
             | // or even like this:
             | c.animate({hue: 1}, 1e3);
             | 
             | // You could also create custom attribute
             | // with multiple parameters:
             | paper.customAttributes.hsb = function (h, s, b) {
             |     return {fill: "hsb(" + [h, s, b].join(",") + ")"};
             | };
             | c.attr({hsb: "0.5 .8 1"});
             | c.animate({hsb: [1, 0, 0.5]}, 1e3);
            \*/
            this.ca = this.customAttributes = {};
        },
        paperproto,
        appendChild = "appendChild",
        apply = "apply",
        concat = "concat",
        supportsTouch = ('ontouchstart' in g.win) || g.win.DocumentTouch && g.doc instanceof DocumentTouch, //taken from Modernizr touch test
        E = "",
        S = " ",
        Str = String,
        split = "split",
        events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[split](S),
        touchMap = {
            mousedown: "touchstart",
            mousemove: "touchmove",
            mouseup: "touchend"
        },
        lowerCase = Str.prototype.toLowerCase,
        math = Math,
        mmax = math.max,
        mmin = math.min,
        abs = math.abs,
        pow = math.pow,
        PI = math.PI,
        nu = "number",
        string = "string",
        array = "array",
        toString = "toString",
        fillString = "fill",
        objectToString = Object.prototype.toString,
        paper = {},
        push = "push",
        ISURL = R._ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
        colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,
        isnan = {"NaN": 1, "Infinity": 1, "-Infinity": 1},
        bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
        round = math.round,
        setAttribute = "setAttribute",
        toFloat = parseFloat,
        toInt = parseInt,
        upperCase = Str.prototype.toUpperCase,
        availableAttrs = R._availableAttrs = {
            "arrow-end": "none",
            "arrow-start": "none",
            blur: 0,
            "clip-rect": "0 0 1e9 1e9",
            cursor: "default",
            cx: 0,
            cy: 0,
            fill: "#fff",
            "fill-opacity": 1,
            font: '10px "Arial"',
            "font-family": '"Arial"',
            "font-size": "10",
            "font-style": "normal",
            "font-weight": 400,
            gradient: 0,
            height: 0,
            href: "http://raphaeljs.com/",
            "letter-spacing": 0,
            opacity: 1,
            path: "M0,0",
            r: 0,
            rx: 0,
            ry: 0,
            src: "",
            stroke: "#000",
            "stroke-dasharray": "",
            "stroke-linecap": "butt",
            "stroke-linejoin": "butt",
            "stroke-miterlimit": 0,
            "stroke-opacity": 1,
            "stroke-width": 1,
            target: "_blank",
            "text-anchor": "middle",
            title: "Raphael",
            transform: "",
            width: 0,
            x: 0,
            y: 0
        },
        availableAnimAttrs = R._availableAnimAttrs = {
            blur: nu,
            "clip-rect": "csv",
            cx: nu,
            cy: nu,
            fill: "colour",
            "fill-opacity": nu,
            "font-size": nu,
            height: nu,
            opacity: nu,
            path: "path",
            r: nu,
            rx: nu,
            ry: nu,
            stroke: "colour",
            "stroke-opacity": nu,
            "stroke-width": nu,
            transform: "transform",
            width: nu,
            x: nu,
            y: nu
        },
        whitespace = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g,
        commaSpaces = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/,
        hsrg = {hs: 1, rg: 1},
        p2s = /,?([achlmqrstvxz]),?/gi,
        pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
        tCommand = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
        pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig,
        radial_gradient = R._radial_gradient = /^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/,
        eldata = {},
        sortByKey = function (a, b) {
            return a.key - b.key;
        },
        sortByNumber = function (a, b) {
            return toFloat(a) - toFloat(b);
        },
        fun = function () {},
        pipe = function (x) {
            return x;
        },
        rectPath = R._rectPath = function (x, y, w, h, r) {
            if (r) {
                return [["M", x + r, y], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]];
            }
            return [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
        },
        ellipsePath = function (x, y, rx, ry) {
            if (ry == null) {
                ry = rx;
            }
            return [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
        },
        getPath = R._getPath = {
            path: function (el) {
                return el.attr("path");
            },
            circle: function (el) {
                var a = el.attrs;
                return ellipsePath(a.cx, a.cy, a.r);
            },
            ellipse: function (el) {
                var a = el.attrs;
                return ellipsePath(a.cx, a.cy, a.rx, a.ry);
            },
            rect: function (el) {
                var a = el.attrs;
                return rectPath(a.x, a.y, a.width, a.height, a.r);
            },
            image: function (el) {
                var a = el.attrs;
                return rectPath(a.x, a.y, a.width, a.height);
            },
            text: function (el) {
                var bbox = el._getBBox();
                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
            },
            set : function(el) {
                var bbox = el._getBBox();
                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
            }
        },
        /*\
         * Raphael.mapPath
         [ method ]
         **
         * Transform the path string with given matrix.
         > Parameters
         - path (string) path string
         - matrix (object) see @Matrix
         = (string) transformed path string
        \*/
        mapPath = R.mapPath = function (path, matrix) {
            if (!matrix) {
                return path;
            }
            var x, y, i, j, ii, jj, pathi;
            path = path2curve(path);
            for (i = 0, ii = path.length; i < ii; i++) {
                pathi = path[i];
                for (j = 1, jj = pathi.length; j < jj; j += 2) {
                    x = matrix.x(pathi[j], pathi[j + 1]);
                    y = matrix.y(pathi[j], pathi[j + 1]);
                    pathi[j] = x;
                    pathi[j + 1] = y;
                }
            }
            return path;
        };

    R._g = g;
    /*\
     * Raphael.type
     [ property (string) ]
     **
     * Can be SVG, VML or empty, depending on browser support.
    \*/
    R.type = (g.win.SVGAngle || g.doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML");
    if (R.type == "VML") {
        var d = g.doc.createElement("div"),
            b;
        d.innerHTML = '<v:shape adj="1"/>';
        b = d.firstChild;
        b.style.behavior = "url(#default#VML)";
        if (!(b && typeof b.adj == "object")) {
            return (R.type = E);
        }
        d = null;
    }
    /*\
     * Raphael.svg
     [ property (boolean) ]
     **
     * `true` if browser supports SVG.
    \*/
    /*\
     * Raphael.vml
     [ property (boolean) ]
     **
     * `true` if browser supports VML.
    \*/
    R.svg = !(R.vml = R.type == "VML");
    R._Paper = Paper;
    /*\
     * Raphael.fn
     [ property (object) ]
     **
     * You can add your own method to the canvas. For example if you want to draw a pie chart,
     * you can create your own pie chart function and ship it as a Raphal plugin. To do this
     * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a
     * Raphal instance is created, otherwise it will take no effect. Please note that the
     * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to
     * ensure any namespacing ensures proper context.
     > Usage
     | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {
     |     return this.path( ... );
     | };
     | // or create namespace
     | Raphael.fn.mystuff = {
     |     arrow: function () {},
     |     star: function () {},
     |     // etc
     | };
     | var paper = Raphael(10, 10, 630, 480);
     | // then use it
     | paper.arrow(10, 10, 30, 30, 5).attr({fill: "#f00"});
     | paper.mystuff.arrow();
     | paper.mystuff.star();
    \*/
    R.fn = paperproto = Paper.prototype = R.prototype;
    R._id = 0;
    R._oid = 0;
    /*\
     * Raphael.is
     [ method ]
     **
     * Handfull replacement for `typeof` operator.
     > Parameters
     - o () any object or primitive
     - type (string) name of the type, i.e. string, function, number, etc.
     = (boolean) is given value is of given type
    \*/
    R.is = function (o, type) {
        type = lowerCase.call(type);
        if (type == "finite") {
            return !isnan[has](+o);
        }
        if (type == "array") {
            return o instanceof Array;
        }
        return  (type == "null" && o === null) ||
                (type == typeof o && o !== null) ||
                (type == "object" && o === Object(o)) ||
                (type == "array" && Array.isArray && Array.isArray(o)) ||
                objectToString.call(o).slice(8, -1).toLowerCase() == type;
    };

    function clone(obj) {
        if (typeof obj == "function" || Object(obj) !== obj) {
            return obj;
        }
        var res = new obj.constructor;
        for (var key in obj) if (obj[has](key)) {
            res[key] = clone(obj[key]);
        }
        return res;
    }

    /*\
     * Raphael.angle
     [ method ]
     **
     * Returns angle between two or three points
     > Parameters
     - x1 (number) x coord of first point
     - y1 (number) y coord of first point
     - x2 (number) x coord of second point
     - y2 (number) y coord of second point
     - x3 (number) #optional x coord of third point
     - y3 (number) #optional y coord of third point
     = (number) angle in degrees.
    \*/
    R.angle = function (x1, y1, x2, y2, x3, y3) {
        if (x3 == null) {
            var x = x1 - x2,
                y = y1 - y2;
            if (!x && !y) {
                return 0;
            }
            return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
        } else {
            return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
        }
    };
    /*\
     * Raphael.rad
     [ method ]
     **
     * Transform angle to radians
     > Parameters
     - deg (number) angle in degrees
     = (number) angle in radians.
    \*/
    R.rad = function (deg) {
        return deg % 360 * PI / 180;
    };
    /*\
     * Raphael.deg
     [ method ]
     **
     * Transform angle to degrees
     > Parameters
     - deg (number) angle in radians
     = (number) angle in degrees.
    \*/
    R.deg = function (rad) {
        return rad * 180 / PI % 360;
    };
    /*\
     * Raphael.snapTo
     [ method ]
     **
     * Snaps given value to given grid.
     > Parameters
     - values (array|number) given array of values or step of the grid
     - value (number) value to adjust
     - tolerance (number) #optional tolerance for snapping. Default is `10`.
     = (number) adjusted value.
    \*/
    R.snapTo = function (values, value, tolerance) {
        tolerance = R.is(tolerance, "finite") ? tolerance : 10;
        if (R.is(values, array)) {
            var i = values.length;
            while (i--) if (abs(values[i] - value) <= tolerance) {
                return values[i];
            }
        } else {
            values = +values;
            var rem = value % values;
            if (rem < tolerance) {
                return value - rem;
            }
            if (rem > values - tolerance) {
                return value - rem + values;
            }
        }
        return value;
    };

    /*\
     * Raphael.createUUID
     [ method ]
     **
     * Returns RFC4122, version 4 ID
    \*/
    var createUUID = R.createUUID = (function (uuidRegEx, uuidReplacer) {
        return function () {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
        };
    })(/[xy]/g, function (c) {
        var r = math.random() * 16 | 0,
            v = c == "x" ? r : (r & 3 | 8);
        return v.toString(16);
    });

    /*\
     * Raphael.setWindow
     [ method ]
     **
     * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.
     > Parameters
     - newwin (window) new window object
    \*/
    R.setWindow = function (newwin) {
        eve("raphael.setWindow", R, g.win, newwin);
        g.win = newwin;
        g.doc = g.win.document;
        if (R._engine.initWin) {
            R._engine.initWin(g.win);
        }
    };
    var toHex = function (color) {
        if (R.vml) {
            // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/
            var trim = /^\s+|\s+$/g;
            var bod;
            try {
                var docum = new ActiveXObject("htmlfile");
                docum.write("<body>");
                docum.close();
                bod = docum.body;
            } catch(e) {
                bod = createPopup().document.body;
            }
            var range = bod.createTextRange();
            toHex = cacher(function (color) {
                try {
                    bod.style.color = Str(color).replace(trim, E);
                    var value = range.queryCommandValue("ForeColor");
                    value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);
                    return "#" + ("000000" + value.toString(16)).slice(-6);
                } catch(e) {
                    return "none";
                }
            });
        } else {
            var i = g.doc.createElement("i");
            i.title = "Rapha\xebl Colour Picker";
            i.style.display = "none";
            g.doc.body.appendChild(i);
            toHex = cacher(function (color) {
                i.style.color = color;
                return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
            });
        }
        return toHex(color);
    },
    hsbtoString = function () {
        return "hsb(" + [this.h, this.s, this.b] + ")";
    },
    hsltoString = function () {
        return "hsl(" + [this.h, this.s, this.l] + ")";
    },
    rgbtoString = function () {
        return this.hex;
    },
    prepareRGB = function (r, g, b) {
        if (g == null && R.is(r, "object") && "r" in r && "g" in r && "b" in r) {
            b = r.b;
            g = r.g;
            r = r.r;
        }
        if (g == null && R.is(r, string)) {
            var clr = R.getRGB(r);
            r = clr.r;
            g = clr.g;
            b = clr.b;
        }
        if (r > 1 || g > 1 || b > 1) {
            r /= 255;
            g /= 255;
            b /= 255;
        }

        return [r, g, b];
    },
    packageRGB = function (r, g, b, o) {
        r *= 255;
        g *= 255;
        b *= 255;
        var rgb = {
            r: r,
            g: g,
            b: b,
            hex: R.rgb(r, g, b),
            toString: rgbtoString
        };
        R.is(o, "finite") && (rgb.opacity = o);
        return rgb;
    };

    /*\
     * Raphael.color
     [ method ]
     **
     * Parses the color string and returns object with all values for the given color.
     > Parameters
     - clr (string) color string in one of the supported formats (see @Raphael.getRGB)
     = (object) Combined RGB & HSB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #,
     o     error (boolean) `true` if string cant be parsed,
     o     h (number) hue,
     o     s (number) saturation,
     o     v (number) value (brightness),
     o     l (number) lightness
     o }
    \*/
    R.color = function (clr) {
        var rgb;
        if (R.is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
            rgb = R.hsb2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else if (R.is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
            rgb = R.hsl2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else {
            if (R.is(clr, "string")) {
                clr = R.getRGB(clr);
            }
            if (R.is(clr, "object") && "r" in clr && "g" in clr && "b" in clr) {
                rgb = R.rgb2hsl(clr);
                clr.h = rgb.h;
                clr.s = rgb.s;
                clr.l = rgb.l;
                rgb = R.rgb2hsb(clr);
                clr.v = rgb.b;
            } else {
                clr = {hex: "none"};
                clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
            }
        }
        clr.toString = rgbtoString;
        return clr;
    };
    /*\
     * Raphael.hsb2rgb
     [ method ]
     **
     * Converts HSB values to RGB object.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - v (number) value or brightness
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #
     o }
    \*/
    R.hsb2rgb = function (h, s, v, o) {
        if (this.is(h, "object") && "h" in h && "s" in h && "b" in h) {
            v = h.b;
            s = h.s;
            h = h.h;
            o = h.o;
        }
        h *= 360;
        var R, G, B, X, C;
        h = (h % 360) / 60;
        C = v * s;
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = v - C;

        h = ~~h;
        R += [C, X, 0, 0, X, C][h];
        G += [X, C, C, X, 0, 0][h];
        B += [0, 0, X, C, C, X][h];
        return packageRGB(R, G, B, o);
    };
    /*\
     * Raphael.hsl2rgb
     [ method ]
     **
     * Converts HSL values to RGB object.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - l (number) luminosity
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #
     o }
    \*/
    R.hsl2rgb = function (h, s, l, o) {
        if (this.is(h, "object") && "h" in h && "s" in h && "l" in h) {
            l = h.l;
            s = h.s;
            h = h.h;
        }
        if (h > 1 || s > 1 || l > 1) {
            h /= 360;
            s /= 100;
            l /= 100;
        }
        h *= 360;
        var R, G, B, X, C;
        h = (h % 360) / 60;
        C = 2 * s * (l < .5 ? l : 1 - l);
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = l - C / 2;

        h = ~~h;
        R += [C, X, 0, 0, X, C][h];
        G += [X, C, C, X, 0, 0][h];
        B += [0, 0, X, C, C, X][h];
        return packageRGB(R, G, B, o);
    };
    /*\
     * Raphael.rgb2hsb
     [ method ]
     **
     * Converts RGB values to HSB object.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (object) HSB object in format:
     o {
     o     h (number) hue
     o     s (number) saturation
     o     b (number) brightness
     o }
    \*/
    R.rgb2hsb = function (r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];

        var H, S, V, C;
        V = mmax(r, g, b);
        C = V - mmin(r, g, b);
        H = (C == 0 ? null :
             V == r ? (g - b) / C :
             V == g ? (b - r) / C + 2 :
                      (r - g) / C + 4
            );
        H = ((H + 360) % 6) * 60 / 360;
        S = C == 0 ? 0 : C / V;
        return {h: H, s: S, b: V, toString: hsbtoString};
    };
    /*\
     * Raphael.rgb2hsl
     [ method ]
     **
     * Converts RGB values to HSL object.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (object) HSL object in format:
     o {
     o     h (number) hue
     o     s (number) saturation
     o     l (number) luminosity
     o }
    \*/
    R.rgb2hsl = function (r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];

        var H, S, L, M, m, C;
        M = mmax(r, g, b);
        m = mmin(r, g, b);
        C = M - m;
        H = (C == 0 ? null :
             M == r ? (g - b) / C :
             M == g ? (b - r) / C + 2 :
                      (r - g) / C + 4);
        H = ((H + 360) % 6) * 60 / 360;
        L = (M + m) / 2;
        S = (C == 0 ? 0 :
             L < .5 ? C / (2 * L) :
                      C / (2 - 2 * L));
        return {h: H, s: S, l: L, toString: hsltoString};
    };
    R._path2string = function () {
        return this.join(",").replace(p2s, "$1");
    };
    function repush(array, item) {
        for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
            return array.push(array.splice(i, 1)[0]);
        }
    }
    function cacher(f, scope, postprocessor) {
        function newf() {
            var arg = Array.prototype.slice.call(arguments, 0),
                args = arg.join("\u2400"),
                cache = newf.cache = newf.cache || {},
                count = newf.count = newf.count || [];
            if (cache[has](args)) {
                repush(count, args);
                return postprocessor ? postprocessor(cache[args]) : cache[args];
            }
            count.length >= 1e3 && delete cache[count.shift()];
            count.push(args);
            cache[args] = f[apply](scope, arg);
            return postprocessor ? postprocessor(cache[args]) : cache[args];
        }
        return newf;
    }

    var preload = R._preload = function (src, f) {
        var img = g.doc.createElement("img");
        img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
        img.onload = function () {
            f.call(this);
            this.onload = null;
            g.doc.body.removeChild(this);
        };
        img.onerror = function () {
            g.doc.body.removeChild(this);
        };
        g.doc.body.appendChild(img);
        img.src = src;
    };

    function clrToString() {
        return this.hex;
    }

    /*\
     * Raphael.getRGB
     [ method ]
     **
     * Parses colour string as RGB object
     > Parameters
     - colour (string) colour string in one of formats:
     # <ul>
     #     <li>Colour name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>
     #     <li>#  shortened HTML colour: (<code>#000</code>, <code>#fc0</code>, etc)</li>
     #     <li>#  full length HTML colour: (<code>#000000</code>, <code>#bd2300</code>)</li>
     #     <li>rgb(, , )  red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>
     #     <li>rgb(%, %, %)  same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>
     #     <li>hsb(, , )  hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>
     #     <li>hsb(%, %, %)  same as above, but in %</li>
     #     <li>hsl(, , )  same as hsb</li>
     #     <li>hsl(%, %, %)  same as hsb</li>
     # </ul>
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue
     o     hex (string) color in HTML/CSS format: #,
     o     error (boolean) true if string cant be parsed
     o }
    \*/
    R.getRGB = cacher(function (colour) {
        if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
            return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
        }
        if (colour == "none") {
            return {r: -1, g: -1, b: -1, hex: "none", toString: clrToString};
        }
        !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
        var res,
            red,
            green,
            blue,
            opacity,
            t,
            values,
            rgb = colour.match(colourRegExp);
        if (rgb) {
            if (rgb[2]) {
                blue = toInt(rgb[2].substring(5), 16);
                green = toInt(rgb[2].substring(3, 5), 16);
                red = toInt(rgb[2].substring(1, 3), 16);
            }
            if (rgb[3]) {
                blue = toInt((t = rgb[3].charAt(3)) + t, 16);
                green = toInt((t = rgb[3].charAt(2)) + t, 16);
                red = toInt((t = rgb[3].charAt(1)) + t, 16);
            }
            if (rgb[4]) {
                values = rgb[4][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
            }
            if (rgb[5]) {
                values = rgb[5][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return R.hsb2rgb(red, green, blue, opacity);
            }
            if (rgb[6]) {
                values = rgb[6][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return R.hsl2rgb(red, green, blue, opacity);
            }
            rgb = {r: red, g: green, b: blue, toString: clrToString};
            rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
            R.is(opacity, "finite") && (rgb.opacity = opacity);
            return rgb;
        }
        return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
    }, R);
    /*\
     * Raphael.hsb
     [ method ]
     **
     * Converts HSB values to hex representation of the colour.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - b (number) value or brightness
     = (string) hex representation of the colour.
    \*/
    R.hsb = cacher(function (h, s, b) {
        return R.hsb2rgb(h, s, b).hex;
    });
    /*\
     * Raphael.hsl
     [ method ]
     **
     * Converts HSL values to hex representation of the colour.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - l (number) luminosity
     = (string) hex representation of the colour.
    \*/
    R.hsl = cacher(function (h, s, l) {
        return R.hsl2rgb(h, s, l).hex;
    });
    /*\
     * Raphael.rgb
     [ method ]
     **
     * Converts RGB values to hex representation of the colour.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (string) hex representation of the colour.
    \*/
    R.rgb = cacher(function (r, g, b) {
        return "#" + (16777216 | b | (g << 8) | (r << 16)).toString(16).slice(1);
    });
    /*\
     * Raphael.getColor
     [ method ]
     **
     * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset
     > Parameters
     - value (number) #optional brightness, default is `0.75`
     = (string) hex representation of the colour.
    \*/
    R.getColor = function (value) {
        var start = this.getColor.start = this.getColor.start || {h: 0, s: 1, b: value || .75},
            rgb = this.hsb2rgb(start.h, start.s, start.b);
        start.h += .075;
        if (start.h > 1) {
            start.h = 0;
            start.s -= .2;
            start.s <= 0 && (this.getColor.start = {h: 0, s: 1, b: start.b});
        }
        return rgb.hex;
    };
    /*\
     * Raphael.getColor.reset
     [ method ]
     **
     * Resets spectrum position for @Raphael.getColor back to red.
    \*/
    R.getColor.reset = function () {
        delete this.start;
    };

    // http://schepers.cc/getting-to-the-point
    function catmullRom2bezier(crp, z) {
        var d = [];
        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
            var p = [
                        {x: +crp[i - 2], y: +crp[i - 1]},
                        {x: +crp[i],     y: +crp[i + 1]},
                        {x: +crp[i + 2], y: +crp[i + 3]},
                        {x: +crp[i + 4], y: +crp[i + 5]}
                    ];
            if (z) {
                if (!i) {
                    p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
                } else if (iLen - 4 == i) {
                    p[3] = {x: +crp[0], y: +crp[1]};
                } else if (iLen - 2 == i) {
                    p[2] = {x: +crp[0], y: +crp[1]};
                    p[3] = {x: +crp[2], y: +crp[3]};
                }
            } else {
                if (iLen - 4 == i) {
                    p[3] = p[2];
                } else if (!i) {
                    p[0] = {x: +crp[i], y: +crp[i + 1]};
                }
            }
            d.push(["C",
                  (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                  (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                  (p[1].x + 6 * p[2].x - p[3].x) / 6,
                  (p[1].y + 6*p[2].y - p[3].y) / 6,
                  p[2].x,
                  p[2].y
            ]);
        }

        return d;
    }
    /*\
     * Raphael.parsePathString
     [ method ]
     **
     * Utility method
     **
     * Parses given path string into an array of arrays of path segments.
     > Parameters
     - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)
     = (array) array of segments.
    \*/
    R.parsePathString = function (pathString) {
        if (!pathString) {
            return null;
        }
        var pth = paths(pathString);
        if (pth.arr) {
            return pathClone(pth.arr);
        }

        var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0},
            data = [];
        if (R.is(pathString, array) && R.is(pathString[0], array)) { // rough assumption
            data = pathClone(pathString);
        }
        if (!data.length) {
            Str(pathString).replace(pathCommand, function (a, b, c) {
                var params = [],
                    name = b.toLowerCase();
                c.replace(pathValues, function (a, b) {
                    b && params.push(+b);
                });
                if (name == "m" && params.length > 2) {
                    data.push([b][concat](params.splice(0, 2)));
                    name = "l";
                    b = b == "m" ? "l" : "L";
                }
                if (name == "r") {
                    data.push([b][concat](params));
                } else while (params.length >= paramCounts[name]) {
                    data.push([b][concat](params.splice(0, paramCounts[name])));
                    if (!paramCounts[name]) {
                        break;
                    }
                }
            });
        }
        data.toString = R._path2string;
        pth.arr = pathClone(data);
        return data;
    };
    /*\
     * Raphael.parseTransformString
     [ method ]
     **
     * Utility method
     **
     * Parses given path string into an array of transformations.
     > Parameters
     - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)
     = (array) array of transformations.
    \*/
    R.parseTransformString = cacher(function (TString) {
        if (!TString) {
            return null;
        }
        var paramCounts = {r: 3, s: 4, t: 2, m: 6},
            data = [];
        if (R.is(TString, array) && R.is(TString[0], array)) { // rough assumption
            data = pathClone(TString);
        }
        if (!data.length) {
            Str(TString).replace(tCommand, function (a, b, c) {
                var params = [],
                    name = lowerCase.call(b);
                c.replace(pathValues, function (a, b) {
                    b && params.push(+b);
                });
                data.push([b][concat](params));
            });
        }
        data.toString = R._path2string;
        return data;
    });
    // PATHS
    var paths = function (ps) {
        var p = paths.ps = paths.ps || {};
        if (p[ps]) {
            p[ps].sleep = 100;
        } else {
            p[ps] = {
                sleep: 100
            };
        }
        setTimeout(function () {
            for (var key in p) if (p[has](key) && key != ps) {
                p[key].sleep--;
                !p[key].sleep && delete p[key];
            }
        });
        return p[ps];
    };
    /*\
     * Raphael.findDotsAtSegment
     [ method ]
     **
     * Utility method
     **
     * Find dot coordinates on the given cubic bezier curve at the given t.
     > Parameters
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     - t (number) position on the curve (0..1)
     = (object) point information in format:
     o {
     o     x: (number) x coordinate of the point
     o     y: (number) y coordinate of the point
     o     m: {
     o         x: (number) x coordinate of the left anchor
     o         y: (number) y coordinate of the left anchor
     o     }
     o     n: {
     o         x: (number) x coordinate of the right anchor
     o         y: (number) y coordinate of the right anchor
     o     }
     o     start: {
     o         x: (number) x coordinate of the start of the curve
     o         y: (number) y coordinate of the start of the curve
     o     }
     o     end: {
     o         x: (number) x coordinate of the end of the curve
     o         y: (number) y coordinate of the end of the curve
     o     }
     o     alpha: (number) angle of the curve derivative at the point
     o }
    \*/
    R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t,
            t13 = pow(t1, 3),
            t12 = pow(t1, 2),
            t2 = t * t,
            t3 = t2 * t,
            x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
            y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
            mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
            my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
            nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
            ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
            ax = t1 * p1x + t * c1x,
            ay = t1 * p1y + t * c1y,
            cx = t1 * c2x + t * p2x,
            cy = t1 * c2y + t * p2y,
            alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);
        (mx > nx || my < ny) && (alpha += 180);
        return {
            x: x,
            y: y,
            m: {x: mx, y: my},
            n: {x: nx, y: ny},
            start: {x: ax, y: ay},
            end: {x: cx, y: cy},
            alpha: alpha
        };
    };
    /*\
     * Raphael.bezierBBox
     [ method ]
     **
     * Utility method
     **
     * Return bounding box of a given cubic bezier curve
     > Parameters
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     * or
     - bez (array) array of six points for bezier curve
     = (object) point information in format:
     o {
     o     min: {
     o         x: (number) x coordinate of the left point
     o         y: (number) y coordinate of the top point
     o     }
     o     max: {
     o         x: (number) x coordinate of the right point
     o         y: (number) y coordinate of the bottom point
     o     }
     o }
    \*/
    R.bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
        if (!R.is(p1x, "array")) {
            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
        }
        var bbox = curveDim.apply(null, p1x);
        return {
            x: bbox.min.x,
            y: bbox.min.y,
            x2: bbox.max.x,
            y2: bbox.max.y,
            width: bbox.max.x - bbox.min.x,
            height: bbox.max.y - bbox.min.y
        };
    };
    /*\
     * Raphael.isPointInsideBBox
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside bounding boxes.
     > Parameters
     - bbox (string) bounding box
     - x (string) x coordinate of the point
     - y (string) y coordinate of the point
     = (boolean) `true` if point inside
    \*/
    R.isPointInsideBBox = function (bbox, x, y) {
        return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;
    };
    /*\
     * Raphael.isBBoxIntersect
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if two bounding boxes intersect
     > Parameters
     - bbox1 (string) first bounding box
     - bbox2 (string) second bounding box
     = (boolean) `true` if they intersect
    \*/
    R.isBBoxIntersect = function (bbox1, bbox2) {
        var i = R.isPointInsideBBox;
        return i(bbox2, bbox1.x, bbox1.y)
            || i(bbox2, bbox1.x2, bbox1.y)
            || i(bbox2, bbox1.x, bbox1.y2)
            || i(bbox2, bbox1.x2, bbox1.y2)
            || i(bbox1, bbox2.x, bbox2.y)
            || i(bbox1, bbox2.x2, bbox2.y)
            || i(bbox1, bbox2.x, bbox2.y2)
            || i(bbox1, bbox2.x2, bbox2.y2)
            || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
            && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
    };
    function base3(t, p1, p2, p3, p4) {
        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
            t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
        return t * t2 - 3 * p1 + 3 * p2;
    }
    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
        if (z == null) {
            z = 1;
        }
        z = z > 1 ? 1 : z < 0 ? 0 : z;
        var z2 = z / 2,
            n = 12,
            Tvalues = [-0.1252,0.1252,-0.3678,0.3678,-0.5873,0.5873,-0.7699,0.7699,-0.9041,0.9041,-0.9816,0.9816],
            Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],
            sum = 0;
        for (var i = 0; i < n; i++) {
            var ct = z2 * Tvalues[i] + z2,
                xbase = base3(ct, x1, x2, x3, x4),
                ybase = base3(ct, y1, y2, y3, y4),
                comb = xbase * xbase + ybase * ybase;
            sum += Cvalues[i] * math.sqrt(comb);
        }
        return z2 * sum;
    }
    function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
            return;
        }
        var t = 1,
            step = t / 2,
            t2 = t - step,
            l,
            e = .01;
        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        while (abs(l - ll) > e) {
            step /= 2;
            t2 += (l < ll ? 1 : -1) * step;
            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        }
        return t2;
    }
    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        if (
            mmax(x1, x2) < mmin(x3, x4) ||
            mmin(x1, x2) > mmax(x3, x4) ||
            mmax(y1, y2) < mmin(y3, y4) ||
            mmin(y1, y2) > mmax(y3, y4)
        ) {
            return;
        }
        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
            ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

        if (!denominator) {
            return;
        }
        var px = nx / denominator,
            py = ny / denominator,
            px2 = +px.toFixed(2),
            py2 = +py.toFixed(2);
        if (
            px2 < +mmin(x1, x2).toFixed(2) ||
            px2 > +mmax(x1, x2).toFixed(2) ||
            px2 < +mmin(x3, x4).toFixed(2) ||
            px2 > +mmax(x3, x4).toFixed(2) ||
            py2 < +mmin(y1, y2).toFixed(2) ||
            py2 > +mmax(y1, y2).toFixed(2) ||
            py2 < +mmin(y3, y4).toFixed(2) ||
            py2 > +mmax(y3, y4).toFixed(2)
        ) {
            return;
        }
        return {x: px, y: py};
    }
    function inter(bez1, bez2) {
        return interHelper(bez1, bez2);
    }
    function interCount(bez1, bez2) {
        return interHelper(bez1, bez2, 1);
    }
    function interHelper(bez1, bez2, justCount) {
        var bbox1 = R.bezierBBox(bez1),
            bbox2 = R.bezierBBox(bez2);
        if (!R.isBBoxIntersect(bbox1, bbox2)) {
            return justCount ? 0 : [];
        }
        var l1 = bezlen.apply(0, bez1),
            l2 = bezlen.apply(0, bez2),
            n1 = mmax(~~(l1 / 5), 1),
            n2 = mmax(~~(l2 / 5), 1),
            dots1 = [],
            dots2 = [],
            xy = {},
            res = justCount ? 0 : [];
        for (var i = 0; i < n1 + 1; i++) {
            var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));
            dots1.push({x: p.x, y: p.y, t: i / n1});
        }
        for (i = 0; i < n2 + 1; i++) {
            p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));
            dots2.push({x: p.x, y: p.y, t: i / n2});
        }
        for (i = 0; i < n1; i++) {
            for (var j = 0; j < n2; j++) {
                var di = dots1[i],
                    di1 = dots1[i + 1],
                    dj = dots2[j],
                    dj1 = dots2[j + 1],
                    ci = abs(di1.x - di.x) < .001 ? "y" : "x",
                    cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
                    is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
                if (is) {
                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
                        continue;
                    }
                    xy[is.x.toFixed(4)] = is.y.toFixed(4);
                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                        t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                    if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {
                        if (justCount) {
                            res++;
                        } else {
                            res.push({
                                x: is.x,
                                y: is.y,
                                t1: mmin(t1, 1),
                                t2: mmin(t2, 1)
                            });
                        }
                    }
                }
            }
        }
        return res;
    }
    /*\
     * Raphael.pathIntersection
     [ method ]
     **
     * Utility method
     **
     * Finds intersections of two paths
     > Parameters
     - path1 (string) path string
     - path2 (string) path string
     = (array) dots of intersection
     o [
     o     {
     o         x: (number) x coordinate of the point
     o         y: (number) y coordinate of the point
     o         t1: (number) t value for segment of path1
     o         t2: (number) t value for segment of path2
     o         segment1: (number) order number for segment of path1
     o         segment2: (number) order number for segment of path2
     o         bez1: (array) eight coordinates representing bezir curve for the segment of path1
     o         bez2: (array) eight coordinates representing bezir curve for the segment of path2
     o     }
     o ]
    \*/
    R.pathIntersection = function (path1, path2) {
        return interPathHelper(path1, path2);
    };
    R.pathIntersectionNumber = function (path1, path2) {
        return interPathHelper(path1, path2, 1);
    };
    function interPathHelper(path1, path2, justCount) {
        path1 = R._path2curve(path1);
        path2 = R._path2curve(path2);
        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
            res = justCount ? 0 : [];
        for (var i = 0, ii = path1.length; i < ii; i++) {
            var pi = path1[i];
            if (pi[0] == "M") {
                x1 = x1m = pi[1];
                y1 = y1m = pi[2];
            } else {
                if (pi[0] == "C") {
                    bez1 = [x1, y1].concat(pi.slice(1));
                    x1 = bez1[6];
                    y1 = bez1[7];
                } else {
                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                    x1 = x1m;
                    y1 = y1m;
                }
                for (var j = 0, jj = path2.length; j < jj; j++) {
                    var pj = path2[j];
                    if (pj[0] == "M") {
                        x2 = x2m = pj[1];
                        y2 = y2m = pj[2];
                    } else {
                        if (pj[0] == "C") {
                            bez2 = [x2, y2].concat(pj.slice(1));
                            x2 = bez2[6];
                            y2 = bez2[7];
                        } else {
                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                            x2 = x2m;
                            y2 = y2m;
                        }
                        var intr = interHelper(bez1, bez2, justCount);
                        if (justCount) {
                            res += intr;
                        } else {
                            for (var k = 0, kk = intr.length; k < kk; k++) {
                                intr[k].segment1 = i;
                                intr[k].segment2 = j;
                                intr[k].bez1 = bez1;
                                intr[k].bez2 = bez2;
                            }
                            res = res.concat(intr);
                        }
                    }
                }
            }
        }
        return res;
    }
    /*\
     * Raphael.isPointInsidePath
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside a given closed path.
     > Parameters
     - path (string) path string
     - x (number) x of the point
     - y (number) y of the point
     = (boolean) true, if point is inside the path
    \*/
    R.isPointInsidePath = function (path, x, y) {
        var bbox = R.pathBBox(path);
        return R.isPointInsideBBox(bbox, x, y) &&
               interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
    };
    R._removedFactory = function (methodname) {
        return function () {
            eve("raphael.log", null, "Rapha\xebl: you are calling to method \u201c" + methodname + "\u201d of removed object", methodname);
        };
    };
    /*\
     * Raphael.pathBBox
     [ method ]
     **
     * Utility method
     **
     * Return bounding box of a given path
     > Parameters
     - path (string) path string
     = (object) bounding box
     o {
     o     x: (number) x coordinate of the left top point of the box
     o     y: (number) y coordinate of the left top point of the box
     o     x2: (number) x coordinate of the right bottom point of the box
     o     y2: (number) y coordinate of the right bottom point of the box
     o     width: (number) width of the box
     o     height: (number) height of the box
     o     cx: (number) x coordinate of the center of the box
     o     cy: (number) y coordinate of the center of the box
     o }
    \*/
    var pathDimensions = R.pathBBox = function (path) {
        var pth = paths(path);
        if (pth.bbox) {
            return clone(pth.bbox);
        }
        if (!path) {
            return {x: 0, y: 0, width: 0, height: 0, x2: 0, y2: 0};
        }
        path = path2curve(path);
        var x = 0,
            y = 0,
            X = [],
            Y = [],
            p;
        for (var i = 0, ii = path.length; i < ii; i++) {
            p = path[i];
            if (p[0] == "M") {
                x = p[1];
                y = p[2];
                X.push(x);
                Y.push(y);
            } else {
                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                X = X[concat](dim.min.x, dim.max.x);
                Y = Y[concat](dim.min.y, dim.max.y);
                x = p[5];
                y = p[6];
            }
        }
        var xmin = mmin[apply](0, X),
            ymin = mmin[apply](0, Y),
            xmax = mmax[apply](0, X),
            ymax = mmax[apply](0, Y),
            width = xmax - xmin,
            height = ymax - ymin,
                bb = {
                x: xmin,
                y: ymin,
                x2: xmax,
                y2: ymax,
                width: width,
                height: height,
                cx: xmin + width / 2,
                cy: ymin + height / 2
            };
        pth.bbox = clone(bb);
        return bb;
    },
        pathClone = function (pathArray) {
            var res = clone(pathArray);
            res.toString = R._path2string;
            return res;
        },
        pathToRelative = R._pathToRelative = function (pathArray) {
            var pth = paths(pathArray);
            if (pth.rel) {
                return pathClone(pth.rel);
            }
            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                pathArray = R.parsePathString(pathArray);
            }
            var res = [],
                x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0;
            if (pathArray[0][0] == "M") {
                x = pathArray[0][1];
                y = pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res.push(["M", x, y]);
            }
            for (var i = start, ii = pathArray.length; i < ii; i++) {
                var r = res[i] = [],
                    pa = pathArray[i];
                if (pa[0] != lowerCase.call(pa[0])) {
                    r[0] = lowerCase.call(pa[0]);
                    switch (r[0]) {
                        case "a":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +(pa[6] - x).toFixed(3);
                            r[7] = +(pa[7] - y).toFixed(3);
                            break;
                        case "v":
                            r[1] = +(pa[1] - y).toFixed(3);
                            break;
                        case "m":
                            mx = pa[1];
                            my = pa[2];
                        default:
                            for (var j = 1, jj = pa.length; j < jj; j++) {
                                r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
                            }
                    }
                } else {
                    r = res[i] = [];
                    if (pa[0] == "m") {
                        mx = pa[1] + x;
                        my = pa[2] + y;
                    }
                    for (var k = 0, kk = pa.length; k < kk; k++) {
                        res[i][k] = pa[k];
                    }
                }
                var len = res[i].length;
                switch (res[i][0]) {
                    case "z":
                        x = mx;
                        y = my;
                        break;
                    case "h":
                        x += +res[i][len - 1];
                        break;
                    case "v":
                        y += +res[i][len - 1];
                        break;
                    default:
                        x += +res[i][len - 2];
                        y += +res[i][len - 1];
                }
            }
            res.toString = R._path2string;
            pth.rel = pathClone(res);
            return res;
        },
        pathToAbsolute = R._pathToAbsolute = function (pathArray) {
            var pth = paths(pathArray);
            if (pth.abs) {
                return pathClone(pth.abs);
            }
            if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
                pathArray = R.parsePathString(pathArray);
            }
            if (!pathArray || !pathArray.length) {
                return [["M", 0, 0]];
            }
            var res = [],
                x = 0,
                y = 0,
                mx = 0,
                my = 0,
                start = 0;
            if (pathArray[0][0] == "M") {
                x = +pathArray[0][1];
                y = +pathArray[0][2];
                mx = x;
                my = y;
                start++;
                res[0] = ["M", x, y];
            }
            var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
            for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
                res.push(r = []);
                pa = pathArray[i];
                if (pa[0] != upperCase.call(pa[0])) {
                    r[0] = upperCase.call(pa[0]);
                    switch (r[0]) {
                        case "A":
                            r[1] = pa[1];
                            r[2] = pa[2];
                            r[3] = pa[3];
                            r[4] = pa[4];
                            r[5] = pa[5];
                            r[6] = +(pa[6] + x);
                            r[7] = +(pa[7] + y);
                            break;
                        case "V":
                            r[1] = +pa[1] + y;
                            break;
                        case "H":
                            r[1] = +pa[1] + x;
                            break;
                        case "R":
                            var dots = [x, y][concat](pa.slice(1));
                            for (var j = 2, jj = dots.length; j < jj; j++) {
                                dots[j] = +dots[j] + x;
                                dots[++j] = +dots[j] + y;
                            }
                            res.pop();
                            res = res[concat](catmullRom2bezier(dots, crz));
                            break;
                        case "M":
                            mx = +pa[1] + x;
                            my = +pa[2] + y;
                        default:
                            for (j = 1, jj = pa.length; j < jj; j++) {
                                r[j] = +pa[j] + ((j % 2) ? x : y);
                            }
                    }
                } else if (pa[0] == "R") {
                    dots = [x, y][concat](pa.slice(1));
                    res.pop();
                    res = res[concat](catmullRom2bezier(dots, crz));
                    r = ["R"][concat](pa.slice(-2));
                } else {
                    for (var k = 0, kk = pa.length; k < kk; k++) {
                        r[k] = pa[k];
                    }
                }
                switch (r[0]) {
                    case "Z":
                        x = mx;
                        y = my;
                        break;
                    case "H":
                        x = r[1];
                        break;
                    case "V":
                        y = r[1];
                        break;
                    case "M":
                        mx = r[r.length - 2];
                        my = r[r.length - 1];
                    default:
                        x = r[r.length - 2];
                        y = r[r.length - 1];
                }
            }
            res.toString = R._path2string;
            pth.abs = pathClone(res);
            return res;
        },
        l2c = function (x1, y1, x2, y2) {
            return [x1, y1, x2, y2, x2, y2];
        },
        q2c = function (x1, y1, ax, ay, x2, y2) {
            var _13 = 1 / 3,
                _23 = 2 / 3;
            return [
                    _13 * x1 + _23 * ax,
                    _13 * y1 + _23 * ay,
                    _13 * x2 + _23 * ax,
                    _13 * y2 + _23 * ay,
                    x2,
                    y2
                ];
        },
        a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
            // for more information of where this math came from visit:
            // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
            var _120 = PI * 120 / 180,
                rad = PI / 180 * (+angle || 0),
                res = [],
                xy,
                rotate = cacher(function (x, y, rad) {
                    var X = x * math.cos(rad) - y * math.sin(rad),
                        Y = x * math.sin(rad) + y * math.cos(rad);
                    return {x: X, y: Y};
                });
            if (!recursive) {
                xy = rotate(x1, y1, -rad);
                x1 = xy.x;
                y1 = xy.y;
                xy = rotate(x2, y2, -rad);
                x2 = xy.x;
                y2 = xy.y;
                var cos = math.cos(PI / 180 * angle),
                    sin = math.sin(PI / 180 * angle),
                    x = (x1 - x2) / 2,
                    y = (y1 - y2) / 2;
                var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
                if (h > 1) {
                    h = math.sqrt(h);
                    rx = h * rx;
                    ry = h * ry;
                }
                var rx2 = rx * rx,
                    ry2 = ry * ry,
                    k = (large_arc_flag == sweep_flag ? -1 : 1) *
                        math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                    cx = k * rx * y / ry + (x1 + x2) / 2,
                    cy = k * -ry * x / rx + (y1 + y2) / 2,
                    f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                    f2 = math.asin(((y2 - cy) / ry).toFixed(9));

                f1 = x1 < cx ? PI - f1 : f1;
                f2 = x2 < cx ? PI - f2 : f2;
                f1 < 0 && (f1 = PI * 2 + f1);
                f2 < 0 && (f2 = PI * 2 + f2);
                if (sweep_flag && f1 > f2) {
                    f1 = f1 - PI * 2;
                }
                if (!sweep_flag && f2 > f1) {
                    f2 = f2 - PI * 2;
                }
            } else {
                f1 = recursive[0];
                f2 = recursive[1];
                cx = recursive[2];
                cy = recursive[3];
            }
            var df = f2 - f1;
            if (abs(df) > _120) {
                var f2old = f2,
                    x2old = x2,
                    y2old = y2;
                f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
                x2 = cx + rx * math.cos(f2);
                y2 = cy + ry * math.sin(f2);
                res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
            }
            df = f2 - f1;
            var c1 = math.cos(f1),
                s1 = math.sin(f1),
                c2 = math.cos(f2),
                s2 = math.sin(f2),
                t = math.tan(df / 4),
                hx = 4 / 3 * rx * t,
                hy = 4 / 3 * ry * t,
                m1 = [x1, y1],
                m2 = [x1 + hx * s1, y1 - hy * c1],
                m3 = [x2 + hx * s2, y2 - hy * c2],
                m4 = [x2, y2];
            m2[0] = 2 * m1[0] - m2[0];
            m2[1] = 2 * m1[1] - m2[1];
            if (recursive) {
                return [m2, m3, m4][concat](res);
            } else {
                res = [m2, m3, m4][concat](res).join()[split](",");
                var newres = [];
                for (var i = 0, ii = res.length; i < ii; i++) {
                    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
                }
                return newres;
            }
        },
        findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
            var t1 = 1 - t;
            return {
                x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
                y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
            };
        },
        curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
            var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),
                b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
                c = p1x - c1x,
                t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,
                t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,
                y = [p1y, p2y],
                x = [p1x, p2x],
                dot;
            abs(t1) > "1e12" && (t1 = .5);
            abs(t2) > "1e12" && (t2 = .5);
            if (t1 > 0 && t1 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                x.push(dot.x);
                y.push(dot.y);
            }
            if (t2 > 0 && t2 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                x.push(dot.x);
                y.push(dot.y);
            }
            a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);
            b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
            c = p1y - c1y;
            t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
            t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
            abs(t1) > "1e12" && (t1 = .5);
            abs(t2) > "1e12" && (t2 = .5);
            if (t1 > 0 && t1 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
                x.push(dot.x);
                y.push(dot.y);
            }
            if (t2 > 0 && t2 < 1) {
                dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
                x.push(dot.x);
                y.push(dot.y);
            }
            return {
                min: {x: mmin[apply](0, x), y: mmin[apply](0, y)},
                max: {x: mmax[apply](0, x), y: mmax[apply](0, y)}
            };
        }),
        path2curve = R._path2curve = cacher(function (path, path2) {
            var pth = !path2 && paths(path);
            if (!path2 && pth.curve) {
                return pathClone(pth.curve);
            }
            var p = pathToAbsolute(path),
                p2 = path2 && pathToAbsolute(path2),
                attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
                attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
                processPath = function (path, d, pcom) {
                    var nx, ny, tq = {T:1, Q:1};
                    if (!path) {
                        return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                    }
                    !(path[0] in tq) && (d.qx = d.qy = null);
                    switch (path[0]) {
                        case "M":
                            d.X = path[1];
                            d.Y = path[2];
                            break;
                        case "A":
                            path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
                            break;
                        case "S":
                            if (pcom == "C" || pcom == "S") { // In "S" case we have to take into account, if the previous command is C/S.
                                nx = d.x * 2 - d.bx;          // And reflect the previous
                                ny = d.y * 2 - d.by;          // command's control point relative to the current point.
                            }
                            else {                            // or some else or nothing
                                nx = d.x;
                                ny = d.y;
                            }
                            path = ["C", nx, ny][concat](path.slice(1));
                            break;
                        case "T":
                            if (pcom == "Q" || pcom == "T") { // In "T" case we have to take into account, if the previous command is Q/T.
                                d.qx = d.x * 2 - d.qx;        // And make a reflection similar
                                d.qy = d.y * 2 - d.qy;        // to case "S".
                            }
                            else {                            // or something else or nothing
                                d.qx = d.x;
                                d.qy = d.y;
                            }
                            path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                            break;
                        case "Q":
                            d.qx = path[1];
                            d.qy = path[2];
                            path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                            break;
                        case "L":
                            path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
                            break;
                        case "H":
                            path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
                            break;
                        case "V":
                            path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
                            break;
                        case "Z":
                            path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
                            break;
                    }
                    return path;
                },
                fixArc = function (pp, i) {
                    if (pp[i].length > 7) {
                        pp[i].shift();
                        var pi = pp[i];
                        while (pi.length) {
                            pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
                        }
                        pp.splice(i, 1);
                        ii = mmax(p.length, p2 && p2.length || 0);
                    }
                },
                fixM = function (path1, path2, a1, a2, i) {
                    if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                        path2.splice(i, 0, ["M", a2.x, a2.y]);
                        a1.bx = 0;
                        a1.by = 0;
                        a1.x = path1[i][1];
                        a1.y = path1[i][2];
                        ii = mmax(p.length, p2 && p2.length || 0);
                    }
                };
            for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
                p[i] = processPath(p[i], attrs);
                fixArc(p, i);
                p2 && (p2[i] = processPath(p2[i], attrs2));
                p2 && fixArc(p2, i);
                fixM(p, p2, attrs, attrs2, i);
                fixM(p2, p, attrs2, attrs, i);
                var seg = p[i],
                    seg2 = p2 && p2[i],
                    seglen = seg.length,
                    seg2len = p2 && seg2.length;
                attrs.x = seg[seglen - 2];
                attrs.y = seg[seglen - 1];
                attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
                attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
                attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
                attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
                attrs2.x = p2 && seg2[seg2len - 2];
                attrs2.y = p2 && seg2[seg2len - 1];
            }
            if (!p2) {
                pth.curve = pathClone(p);
            }
            return p2 ? [p, p2] : p;
        }, null, pathClone),
        parseDots = R._parseDots = cacher(function (gradient) {
            var dots = [];
            for (var i = 0, ii = gradient.length; i < ii; i++) {
                var dot = {},
                    par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
                dot.color = R.getRGB(par[1]);
                if (dot.color.error) {
                    return null;
                }
                dot.color = dot.color.hex;
                par[2] && (dot.offset = par[2] + "%");
                dots.push(dot);
            }
            for (i = 1, ii = dots.length - 1; i < ii; i++) {
                if (!dots[i].offset) {
                    var start = toFloat(dots[i - 1].offset || 0),
                        end = 0;
                    for (var j = i + 1; j < ii; j++) {
                        if (dots[j].offset) {
                            end = dots[j].offset;
                            break;
                        }
                    }
                    if (!end) {
                        end = 100;
                        j = ii;
                    }
                    end = toFloat(end);
                    var d = (end - start) / (j - i + 1);
                    for (; i < j; i++) {
                        start += d;
                        dots[i].offset = start + "%";
                    }
                }
            }
            return dots;
        }),
        tear = R._tear = function (el, paper) {
            el == paper.top && (paper.top = el.prev);
            el == paper.bottom && (paper.bottom = el.next);
            el.next && (el.next.prev = el.prev);
            el.prev && (el.prev.next = el.next);
        },
        tofront = R._tofront = function (el, paper) {
            if (paper.top === el) {
                return;
            }
            tear(el, paper);
            el.next = null;
            el.prev = paper.top;
            paper.top.next = el;
            paper.top = el;
        },
        toback = R._toback = function (el, paper) {
            if (paper.bottom === el) {
                return;
            }
            tear(el, paper);
            el.next = paper.bottom;
            el.prev = null;
            paper.bottom.prev = el;
            paper.bottom = el;
        },
        insertafter = R._insertafter = function (el, el2, paper) {
            tear(el, paper);
            el2 == paper.top && (paper.top = el);
            el2.next && (el2.next.prev = el);
            el.next = el2.next;
            el.prev = el2;
            el2.next = el;
        },
        insertbefore = R._insertbefore = function (el, el2, paper) {
            tear(el, paper);
            el2 == paper.bottom && (paper.bottom = el);
            el2.prev && (el2.prev.next = el);
            el.prev = el2.prev;
            el2.prev = el;
            el.next = el2;
        },
        /*\
         * Raphael.toMatrix
         [ method ]
         **
         * Utility method
         **
         * Returns matrix of transformations applied to a given path
         > Parameters
         - path (string) path string
         - transform (string|array) transformation string
         = (object) @Matrix
        \*/
        toMatrix = R.toMatrix = function (path, transform) {
            var bb = pathDimensions(path),
                el = {
                    _: {
                        transform: E
                    },
                    getBBox: function () {
                        return bb;
                    }
                };
            extractTransform(el, transform);
            return el.matrix;
        },
        /*\
         * Raphael.transformPath
         [ method ]
         **
         * Utility method
         **
         * Returns path transformed by a given transformation
         > Parameters
         - path (string) path string
         - transform (string|array) transformation string
         = (string) path
        \*/
        transformPath = R.transformPath = function (path, transform) {
            return mapPath(path, toMatrix(path, transform));
        },
        extractTransform = R._extractTransform = function (el, tstr) {
            if (tstr == null) {
                return el._.transform;
            }
            tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
            var tdata = R.parseTransformString(tstr),
                deg = 0,
                dx = 0,
                dy = 0,
                sx = 1,
                sy = 1,
                _ = el._,
                m = new Matrix;
            _.transform = tdata || [];
            if (tdata) {
                for (var i = 0, ii = tdata.length; i < ii; i++) {
                    var t = tdata[i],
                        tlen = t.length,
                        command = Str(t[0]).toLowerCase(),
                        absolute = t[0] != command,
                        inver = absolute ? m.invert() : 0,
                        x1,
                        y1,
                        x2,
                        y2,
                        bb;
                    if (command == "t" && tlen == 3) {
                        if (absolute) {
                            x1 = inver.x(0, 0);
                            y1 = inver.y(0, 0);
                            x2 = inver.x(t[1], t[2]);
                            y2 = inver.y(t[1], t[2]);
                            m.translate(x2 - x1, y2 - y1);
                        } else {
                            m.translate(t[1], t[2]);
                        }
                    } else if (command == "r") {
                        if (tlen == 2) {
                            bb = bb || el.getBBox(1);
                            m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                            deg += t[1];
                        } else if (tlen == 4) {
                            if (absolute) {
                                x2 = inver.x(t[2], t[3]);
                                y2 = inver.y(t[2], t[3]);
                                m.rotate(t[1], x2, y2);
                            } else {
                                m.rotate(t[1], t[2], t[3]);
                            }
                            deg += t[1];
                        }
                    } else if (command == "s") {
                        if (tlen == 2 || tlen == 3) {
                            bb = bb || el.getBBox(1);
                            m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                            sx *= t[1];
                            sy *= t[tlen - 1];
                        } else if (tlen == 5) {
                            if (absolute) {
                                x2 = inver.x(t[3], t[4]);
                                y2 = inver.y(t[3], t[4]);
                                m.scale(t[1], t[2], x2, y2);
                            } else {
                                m.scale(t[1], t[2], t[3], t[4]);
                            }
                            sx *= t[1];
                            sy *= t[2];
                        }
                    } else if (command == "m" && tlen == 7) {
                        m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
                    }
                    _.dirtyT = 1;
                    el.matrix = m;
                }
            }

            /*\
             * Element.matrix
             [ property (object) ]
             **
             * Keeps @Matrix object, which represents element transformation
            \*/
            el.matrix = m;

            _.sx = sx;
            _.sy = sy;
            _.deg = deg;
            _.dx = dx = m.e;
            _.dy = dy = m.f;

            if (sx == 1 && sy == 1 && !deg && _.bbox) {
                _.bbox.x += +dx;
                _.bbox.y += +dy;
            } else {
                _.dirtyT = 1;
            }
        },
        getEmpty = function (item) {
            var l = item[0];
            switch (l.toLowerCase()) {
                case "t": return [l, 0, 0];
                case "m": return [l, 1, 0, 0, 1, 0, 0];
                case "r": if (item.length == 4) {
                    return [l, 0, item[2], item[3]];
                } else {
                    return [l, 0];
                }
                case "s": if (item.length == 5) {
                    return [l, 1, 1, item[3], item[4]];
                } else if (item.length == 3) {
                    return [l, 1, 1];
                } else {
                    return [l, 1];
                }
            }
        },
        equaliseTransform = R._equaliseTransform = function (t1, t2) {
            t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
            t1 = R.parseTransformString(t1) || [];
            t2 = R.parseTransformString(t2) || [];
            var maxlength = mmax(t1.length, t2.length),
                from = [],
                to = [],
                i = 0, j, jj,
                tt1, tt2;
            for (; i < maxlength; i++) {
                tt1 = t1[i] || getEmpty(t2[i]);
                tt2 = t2[i] || getEmpty(tt1);
                if ((tt1[0] != tt2[0]) ||
                    (tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||
                    (tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))
                    ) {
                    return;
                }
                from[i] = [];
                to[i] = [];
                for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {
                    j in tt1 && (from[i][j] = tt1[j]);
                    j in tt2 && (to[i][j] = tt2[j]);
                }
            }
            return {
                from: from,
                to: to
            };
        };
    R._getContainer = function (x, y, w, h) {
        var container;
        container = h == null && !R.is(x, "object") ? g.doc.getElementById(x) : x;
        if (container == null) {
            return;
        }
        if (container.tagName) {
            if (y == null) {
                return {
                    container: container,
                    width: container.style.pixelWidth || container.offsetWidth,
                    height: container.style.pixelHeight || container.offsetHeight
                };
            } else {
                return {
                    container: container,
                    width: y,
                    height: w
                };
            }
        }
        return {
            container: 1,
            x: x,
            y: y,
            width: w,
            height: h
        };
    };
    /*\
     * Raphael.pathToRelative
     [ method ]
     **
     * Utility method
     **
     * Converts path to relative form
     > Parameters
     - pathString (string|array) path string or array of segments
     = (array) array of segments.
    \*/
    R.pathToRelative = pathToRelative;
    R._engine = {};
    /*\
     * Raphael.path2curve
     [ method ]
     **
     * Utility method
     **
     * Converts path to a new path where all segments are cubic bezier curves.
     > Parameters
     - pathString (string|array) path string or array of segments
     = (array) array of segments.
    \*/
    R.path2curve = path2curve;
    /*\
     * Raphael.matrix
     [ method ]
     **
     * Utility method
     **
     * Returns matrix based on given parameters.
     > Parameters
     - a (number)
     - b (number)
     - c (number)
     - d (number)
     - e (number)
     - f (number)
     = (object) @Matrix
    \*/
    R.matrix = function (a, b, c, d, e, f) {
        return new Matrix(a, b, c, d, e, f);
    };
    function Matrix(a, b, c, d, e, f) {
        if (a != null) {
            this.a = +a;
            this.b = +b;
            this.c = +c;
            this.d = +d;
            this.e = +e;
            this.f = +f;
        } else {
            this.a = 1;
            this.b = 0;
            this.c = 0;
            this.d = 1;
            this.e = 0;
            this.f = 0;
        }
    }
    (function (matrixproto) {
        /*\
         * Matrix.add
         [ method ]
         **
         * Adds given matrix to existing one.
         > Parameters
         - a (number)
         - b (number)
         - c (number)
         - d (number)
         - e (number)
         - f (number)
         or
         - matrix (object) @Matrix
        \*/
        matrixproto.add = function (a, b, c, d, e, f) {
            var out = [[], [], []],
                m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
                matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
                x, y, z, res;

            if (a && a instanceof Matrix) {
                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
            }

            for (x = 0; x < 3; x++) {
                for (y = 0; y < 3; y++) {
                    res = 0;
                    for (z = 0; z < 3; z++) {
                        res += m[x][z] * matrix[z][y];
                    }
                    out[x][y] = res;
                }
            }
            this.a = out[0][0];
            this.b = out[1][0];
            this.c = out[0][1];
            this.d = out[1][1];
            this.e = out[0][2];
            this.f = out[1][2];
        };
        /*\
         * Matrix.invert
         [ method ]
         **
         * Returns inverted version of the matrix
         = (object) @Matrix
        \*/
        matrixproto.invert = function () {
            var me = this,
                x = me.a * me.d - me.b * me.c;
            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
        };
        /*\
         * Matrix.clone
         [ method ]
         **
         * Returns copy of the matrix
         = (object) @Matrix
        \*/
        matrixproto.clone = function () {
            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
        };
        /*\
         * Matrix.translate
         [ method ]
         **
         * Translate the matrix
         > Parameters
         - x (number)
         - y (number)
        \*/
        matrixproto.translate = function (x, y) {
            this.add(1, 0, 0, 1, x, y);
        };
        /*\
         * Matrix.scale
         [ method ]
         **
         * Scales the matrix
         > Parameters
         - x (number)
         - y (number) #optional
         - cx (number) #optional
         - cy (number) #optional
        \*/
        matrixproto.scale = function (x, y, cx, cy) {
            y == null && (y = x);
            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
            this.add(x, 0, 0, y, 0, 0);
            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
        };
        /*\
         * Matrix.rotate
         [ method ]
         **
         * Rotates the matrix
         > Parameters
         - a (number)
         - x (number)
         - y (number)
        \*/
        matrixproto.rotate = function (a, x, y) {
            a = R.rad(a);
            x = x || 0;
            y = y || 0;
            var cos = +math.cos(a).toFixed(9),
                sin = +math.sin(a).toFixed(9);
            this.add(cos, sin, -sin, cos, x, y);
            this.add(1, 0, 0, 1, -x, -y);
        };
        /*\
         * Matrix.x
         [ method ]
         **
         * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y
         > Parameters
         - x (number)
         - y (number)
         = (number) x
        \*/
        matrixproto.x = function (x, y) {
            return x * this.a + y * this.c + this.e;
        };
        /*\
         * Matrix.y
         [ method ]
         **
         * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x
         > Parameters
         - x (number)
         - y (number)
         = (number) y
        \*/
        matrixproto.y = function (x, y) {
            return x * this.b + y * this.d + this.f;
        };
        matrixproto.get = function (i) {
            return +this[Str.fromCharCode(97 + i)].toFixed(4);
        };
        matrixproto.toString = function () {
            return R.svg ?
                "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" :
                [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();
        };
        matrixproto.toFilter = function () {
            return "progid:DXImageTransform.Microsoft.Matrix(M11=" + this.get(0) +
                ", M12=" + this.get(2) + ", M21=" + this.get(1) + ", M22=" + this.get(3) +
                ", Dx=" + this.get(4) + ", Dy=" + this.get(5) + ", sizingmethod='auto expand')";
        };
        matrixproto.offset = function () {
            return [this.e.toFixed(4), this.f.toFixed(4)];
        };
        function norm(a) {
            return a[0] * a[0] + a[1] * a[1];
        }
        function normalize(a) {
            var mag = math.sqrt(norm(a));
            a[0] && (a[0] /= mag);
            a[1] && (a[1] /= mag);
        }
        /*\
         * Matrix.split
         [ method ]
         **
         * Splits matrix into primitive transformations
         = (object) in format:
         o dx (number) translation by x
         o dy (number) translation by y
         o scalex (number) scale by x
         o scaley (number) scale by y
         o shear (number) shear
         o rotate (number) rotation in deg
         o isSimple (boolean) could it be represented via simple transformations
        \*/
        matrixproto.split = function () {
            var out = {};
            // translation
            out.dx = this.e;
            out.dy = this.f;

            // scale and shear
            var row = [[this.a, this.c], [this.b, this.d]];
            out.scalex = math.sqrt(norm(row[0]));
            normalize(row[0]);

            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

            out.scaley = math.sqrt(norm(row[1]));
            normalize(row[1]);
            out.shear /= out.scaley;

            // rotation
            var sin = -row[0][1],
                cos = row[1][1];
            if (cos < 0) {
                out.rotate = R.deg(math.acos(cos));
                if (sin < 0) {
                    out.rotate = 360 - out.rotate;
                }
            } else {
                out.rotate = R.deg(math.asin(sin));
            }

            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
            return out;
        };
        /*\
         * Matrix.toTransformString
         [ method ]
         **
         * Return transform string that represents given matrix
         = (string) transform string
        \*/
        matrixproto.toTransformString = function (shorter) {
            var s = shorter || this[split]();
            if (s.isSimple) {
                s.scalex = +s.scalex.toFixed(4);
                s.scaley = +s.scaley.toFixed(4);
                s.rotate = +s.rotate.toFixed(4);
                return  (s.dx || s.dy ? "t" + [s.dx, s.dy] : E) +
                        (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) +
                        (s.rotate ? "r" + [s.rotate, 0, 0] : E);
            } else {
                return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
            }
        };
    })(Matrix.prototype);

    // WebKit rendering bug workaround method
    var version = navigator.userAgent.match(/Version\/(.*?)\s/) || navigator.userAgent.match(/Chrome\/(\d+)/);
    if ((navigator.vendor == "Apple Computer, Inc.") && (version && version[1] < 4 || navigator.platform.slice(0, 2) == "iP") ||
        (navigator.vendor == "Google Inc." && version && version[1] < 8)) {
        /*\
         * Paper.safari
         [ method ]
         **
         * There is an inconvenient rendering bug in Safari (WebKit):
         * sometimes the rendering should be forced.
         * This method should help with dealing with this bug.
        \*/
        paperproto.safari = function () {
            var rect = this.rect(-99, -99, this.width + 99, this.height + 99).attr({stroke: "none"});
            setTimeout(function () {rect.remove();});
        };
    } else {
        paperproto.safari = fun;
    }

    var preventDefault = function () {
        this.returnValue = false;
    },
    preventTouch = function () {
        return this.originalEvent.preventDefault();
    },
    stopPropagation = function () {
        this.cancelBubble = true;
    },
    stopTouch = function () {
        return this.originalEvent.stopPropagation();
    },
    getEventPosition = function (e) {
        var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;

        return {
            x: e.clientX + scrollX,
            y: e.clientY + scrollY
        };
    },
    addEvent = (function () {
        if (g.doc.addEventListener) {
            return function (obj, type, fn, element) {
                var f = function (e) {
                    var pos = getEventPosition(e);
                    return fn.call(element, e, pos.x, pos.y);
                };
                obj.addEventListener(type, f, false);

                if (supportsTouch && touchMap[type]) {
                    var _f = function (e) {
                        var pos = getEventPosition(e),
                            olde = e;

                        for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                            if (e.targetTouches[i].target == obj) {
                                e = e.targetTouches[i];
                                e.originalEvent = olde;
                                e.preventDefault = preventTouch;
                                e.stopPropagation = stopTouch;
                                break;
                            }
                        }

                        return fn.call(element, e, pos.x, pos.y);
                    };
                    obj.addEventListener(touchMap[type], _f, false);
                }

                return function () {
                    obj.removeEventListener(type, f, false);

                    if (supportsTouch && touchMap[type])
                        obj.removeEventListener(touchMap[type], f, false);

                    return true;
                };
            };
        } else if (g.doc.attachEvent) {
            return function (obj, type, fn, element) {
                var f = function (e) {
                    e = e || g.win.event;
                    var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                        scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                        x = e.clientX + scrollX,
                        y = e.clientY + scrollY;
                    e.preventDefault = e.preventDefault || preventDefault;
                    e.stopPropagation = e.stopPropagation || stopPropagation;
                    return fn.call(element, e, x, y);
                };
                obj.attachEvent("on" + type, f);
                var detacher = function () {
                    obj.detachEvent("on" + type, f);
                    return true;
                };
                return detacher;
            };
        }
    })(),
    drag = [],
    dragMove = function (e) {
        var x = e.clientX,
            y = e.clientY,
            scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
            dragi,
            j = drag.length;
        while (j--) {
            dragi = drag[j];
            if (supportsTouch && e.touches) {
                var i = e.touches.length,
                    touch;
                while (i--) {
                    touch = e.touches[i];
                    if (touch.identifier == dragi.el._drag.id) {
                        x = touch.clientX;
                        y = touch.clientY;
                        (e.originalEvent ? e.originalEvent : e).preventDefault();
                        break;
                    }
                }
            } else {
                e.preventDefault();
            }
            var node = dragi.el.node,
                o,
                next = node.nextSibling,
                parent = node.parentNode,
                display = node.style.display;
            g.win.opera && parent.removeChild(node);
            node.style.display = "none";
            o = dragi.el.paper.getElementByPoint(x, y);
            node.style.display = display;
            g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
            o && eve("raphael.drag.over." + dragi.el.id, dragi.el, o);
            x += scrollX;
            y += scrollY;
            eve("raphael.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
        }
    },
    dragUp = function (e) {
        R.unmousemove(dragMove).unmouseup(dragUp);
        var i = drag.length,
            dragi;
        while (i--) {
            dragi = drag[i];
            dragi.el._drag = {};
            eve("raphael.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
        }
        drag = [];
    },
    /*\
     * Raphael.el
     [ property (object) ]
     **
     * You can add your own method to elements. This is usefull when you want to hack default functionality or
     * want to wrap some common transformation or attributes in one method. In difference to canvas methods,
     * you can redefine element method at any time. Expending element methods wouldnt affect set.
     > Usage
     | Raphael.el.red = function () {
     |     this.attr({fill: "#f00"});
     | };
     | // then use it
     | paper.circle(100, 100, 20).red();
    \*/
    elproto = R.el = {};
    /*\
     * Element.click
     [ method ]
     **
     * Adds event handler for click for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unclick
     [ method ]
     **
     * Removes event handler for click for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.dblclick
     [ method ]
     **
     * Adds event handler for double click for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.undblclick
     [ method ]
     **
     * Removes event handler for double click for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mousedown
     [ method ]
     **
     * Adds event handler for mousedown for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmousedown
     [ method ]
     **
     * Removes event handler for mousedown for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mousemove
     [ method ]
     **
     * Adds event handler for mousemove for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmousemove
     [ method ]
     **
     * Removes event handler for mousemove for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mouseout
     [ method ]
     **
     * Adds event handler for mouseout for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseout
     [ method ]
     **
     * Removes event handler for mouseout for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mouseover
     [ method ]
     **
     * Adds event handler for mouseover for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseover
     [ method ]
     **
     * Removes event handler for mouseover for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mouseup
     [ method ]
     **
     * Adds event handler for mouseup for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseup
     [ method ]
     **
     * Removes event handler for mouseup for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchstart
     [ method ]
     **
     * Adds event handler for touchstart for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchstart
     [ method ]
     **
     * Removes event handler for touchstart for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchmove
     [ method ]
     **
     * Adds event handler for touchmove for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchmove
     [ method ]
     **
     * Removes event handler for touchmove for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchend
     [ method ]
     **
     * Adds event handler for touchend for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchend
     [ method ]
     **
     * Removes event handler for touchend for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchcancel
     [ method ]
     **
     * Adds event handler for touchcancel for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchcancel
     [ method ]
     **
     * Removes event handler for touchcancel for the element.
     > Parameters
     - handler (function) #optional handler for the event
     = (object) @Element
    \*/
    for (var i = events.length; i--;) {
        (function (eventName) {
            R[eventName] = elproto[eventName] = function (fn, scope) {
                if (R.is(fn, "function")) {
                    this.events = this.events || [];
                    this.events.push({name: eventName, f: fn, unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)});
                }
                return this;
            };
            R["un" + eventName] = elproto["un" + eventName] = function (fn) {
                var events = this.events || [],
                    l = events.length;
                while (l--){
                    if (events[l].name == eventName && (R.is(fn, "undefined") || events[l].f == fn)) {
                        events[l].unbind();
                        events.splice(l, 1);
                        !events.length && delete this.events;
                    }
                }
                return this;
            };
        })(events[i]);
    }

    /*\
     * Element.data
     [ method ]
     **
     * Adds or retrieves given value asociated with given key.
     ** 
     * See also @Element.removeData
     > Parameters
     - key (string) key to store data
     - value (any) #optional value to store
     = (object) @Element
     * or, if value is not specified:
     = (any) value
     * or, if key and value are not specified:
     = (object) Key/value pairs for all the data associated with the element.
     > Usage
     | for (var i = 0, i < 5, i++) {
     |     paper.circle(10 + 15 * i, 10, 10)
     |          .attr({fill: "#000"})
     |          .data("i", i)
     |          .click(function () {
     |             alert(this.data("i"));
     |          });
     | }
    \*/
    elproto.data = function (key, value) {
        var data = eldata[this.id] = eldata[this.id] || {};
        if (arguments.length == 0) {
            return data;
        }
        if (arguments.length == 1) {
            if (R.is(key, "object")) {
                for (var i in key) if (key[has](i)) {
                    this.data(i, key[i]);
                }
                return this;
            }
            eve("raphael.data.get." + this.id, this, data[key], key);
            return data[key];
        }
        data[key] = value;
        eve("raphael.data.set." + this.id, this, value, key);
        return this;
    };
    /*\
     * Element.removeData
     [ method ]
     **
     * Removes value associated with an element by given key.
     * If key is not provided, removes all the data of the element.
     > Parameters
     - key (string) #optional key
     = (object) @Element
    \*/
    elproto.removeData = function (key) {
        if (key == null) {
            eldata[this.id] = {};
        } else {
            eldata[this.id] && delete eldata[this.id][key];
        }
        return this;
    };
     /*\
     * Element.getData
     [ method ]
     **
     * Retrieves the element data
     = (object) data
    \*/
    elproto.getData = function () {
        return clone(eldata[this.id] || {});
    };
    /*\
     * Element.hover
     [ method ]
     **
     * Adds event handlers for hover for the element.
     > Parameters
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     - icontext (object) #optional context for hover in handler
     - ocontext (object) #optional context for hover out handler
     = (object) @Element
    \*/
    elproto.hover = function (f_in, f_out, scope_in, scope_out) {
        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
    };
    /*\
     * Element.unhover
     [ method ]
     **
     * Removes event handlers for hover for the element.
     > Parameters
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     = (object) @Element
    \*/
    elproto.unhover = function (f_in, f_out) {
        return this.unmouseover(f_in).unmouseout(f_out);
    };
    var draggable = [];
    /*\
     * Element.drag
     [ method ]
     **
     * Adds event handlers for drag of the element.
     > Parameters
     - onmove (function) handler for moving
     - onstart (function) handler for drag start
     - onend (function) handler for drag end
     - mcontext (object) #optional context for moving handler
     - scontext (object) #optional context for drag start handler
     - econtext (object) #optional context for drag end handler
     * Additionaly following `drag` events will be triggered: `drag.start.<id>` on start, 
     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element 
     * `drag.over.<id>` will be fired as well.
     *
     * Start event and start handler will be called in specified context or in context of the element with following parameters:
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * Move event and move handler will be called in specified context or in context of the element with following parameters:
     o dx (number) shift by x from the start point
     o dy (number) shift by y from the start point
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * End event and end handler will be called in specified context or in context of the element with following parameters:
     o event (object) DOM event object
     = (object) @Element
    \*/
    elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
        function start(e) {
            (e.originalEvent || e).preventDefault();
            var x = e.clientX,
                y = e.clientY,
                scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
            this._drag.id = e.identifier;
            if (supportsTouch && e.touches) {
                var i = e.touches.length, touch;
                while (i--) {
                    touch = e.touches[i];
                    this._drag.id = touch.identifier;
                    if (touch.identifier == this._drag.id) {
                        x = touch.clientX;
                        y = touch.clientY;
                        break;
                    }
                }
            }
            this._drag.x = x + scrollX;
            this._drag.y = y + scrollY;
            !drag.length && R.mousemove(dragMove).mouseup(dragUp);
            drag.push({el: this, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
            onstart && eve.on("raphael.drag.start." + this.id, onstart);
            onmove && eve.on("raphael.drag.move." + this.id, onmove);
            onend && eve.on("raphael.drag.end." + this.id, onend);
            eve("raphael.drag.start." + this.id, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
        }
        this._drag = {};
        draggable.push({el: this, start: start});
        this.mousedown(start);
        return this;
    };
    /*\
     * Element.onDragOver
     [ method ]
     **
     * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).
     > Parameters
     - f (function) handler for event, first argument would be the element you are dragging over
    \*/
    elproto.onDragOver = function (f) {
        f ? eve.on("raphael.drag.over." + this.id, f) : eve.unbind("raphael.drag.over." + this.id);
    };
    /*\
     * Element.undrag
     [ method ]
     **
     * Removes all drag event handlers from given element.
    \*/
    elproto.undrag = function () {
        var i = draggable.length;
        while (i--) if (draggable[i].el == this) {
            this.unmousedown(draggable[i].start);
            draggable.splice(i, 1);
            eve.unbind("raphael.drag.*." + this.id);
        }
        !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);
        drag = [];
    };
    /*\
     * Paper.circle
     [ method ]
     **
     * Draws a circle.
     **
     > Parameters
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - r (number) radius
     = (object) Raphal element object with type circle
     **
     > Usage
     | var c = paper.circle(50, 50, 40);
    \*/
    paperproto.circle = function (x, y, r) {
        var out = R._engine.circle(this, x || 0, y || 0, r || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.rect
     [ method ]
     *
     * Draws a rectangle.
     **
     > Parameters
     **
     - x (number) x coordinate of the top left corner
     - y (number) y coordinate of the top left corner
     - width (number) width
     - height (number) height
     - r (number) #optional radius for rounded corners, default is 0
     = (object) Raphal element object with type rect
     **
     > Usage
     | // regular rectangle
     | var c = paper.rect(10, 10, 50, 50);
     | // rectangle with rounded corners
     | var c = paper.rect(40, 40, 50, 50, 10);
    \*/
    paperproto.rect = function (x, y, w, h, r) {
        var out = R._engine.rect(this, x || 0, y || 0, w || 0, h || 0, r || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.ellipse
     [ method ]
     **
     * Draws an ellipse.
     **
     > Parameters
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - rx (number) horizontal radius
     - ry (number) vertical radius
     = (object) Raphal element object with type ellipse
     **
     > Usage
     | var c = paper.ellipse(50, 50, 40, 20);
    \*/
    paperproto.ellipse = function (x, y, rx, ry) {
        var out = R._engine.ellipse(this, x || 0, y || 0, rx || 0, ry || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.path
     [ method ]
     **
     * Creates a path element by given path data string.
     > Parameters
     - pathString (string) #optional path string in SVG format.
     * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:
     | "M10,20L30,40"
     * Here we can see two commands: M, with arguments `(10, 20)` and L with arguments `(30, 40)`. Upper case letter mean command is absolute, lower caserelative.
     *
     # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a>.</p>
     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
     # <tr><td>Q</td><td>quadratic Bzier curveto</td><td>(x1 y1 x y)+</td></tr>
     # <tr><td>T</td><td>smooth quadratic Bzier curveto</td><td>(x y)+</td></tr>
     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
     # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/CatmullRom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
     * * Catmull-Rom curveto is a not standard SVG command and added in 2.0 to make life easier.
     * Note: there is a special case when path consist of just three commands: M10,10Rz. In this case path will smoothly connects to its beginning.
     > Usage
     | var c = paper.path("M10 10L90 90");
     | // draw a diagonal line:
     | // move to 10,10, line to 90,90
     * For example of path strings, check out these icons: http://raphaeljs.com/icons/
    \*/
    paperproto.path = function (pathString) {
        pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);
        var out = R._engine.path(R.format[apply](R, arguments), this);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.image
     [ method ]
     **
     * Embeds an image into the surface.
     **
     > Parameters
     **
     - src (string) URI of the source image
     - x (number) x coordinate position
     - y (number) y coordinate position
     - width (number) width of the image
     - height (number) height of the image
     = (object) Raphal element object with type image
     **
     > Usage
     | var c = paper.image("apple.png", 10, 10, 80, 80);
    \*/
    paperproto.image = function (src, x, y, w, h) {
        var out = R._engine.image(this, src || "about:blank", x || 0, y || 0, w || 0, h || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.text
     [ method ]
     **
     * Draws a text string. If you need line breaks, put \n in the string.
     **
     > Parameters
     **
     - x (number) x coordinate position
     - y (number) y coordinate position
     - text (string) The text string to draw
     = (object) Raphal element object with type text
     **
     > Usage
     | var t = paper.text(50, 50, "Raphal\nkicks\nbutt!");
    \*/
    paperproto.text = function (x, y, text) {
        var out = R._engine.text(this, x || 0, y || 0, Str(text));
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Paper.set
     [ method ]
     **
     * Creates array-like object to keep and operate several elements at once.
     * Warning: it doesnt create any elements for itself in the page, it just groups existing elements.
     * Sets act as pseudo elements  all methods available to an element can be used on a set.
     = (object) array-like object that represents set of elements
     **
     > Usage
     | var st = paper.set();
     | st.push(
     |     paper.circle(10, 10, 5),
     |     paper.circle(30, 10, 5)
     | );
     | st.attr({fill: "red"}); // changes the fill of both circles
    \*/
    paperproto.set = function (itemsArray) {
        !R.is(itemsArray, "array") && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));
        var out = new Set(itemsArray);
        this.__set__ && this.__set__.push(out);
        out["paper"] = this;
        out["type"] = "set";
        return out;
    };
    /*\
     * Paper.setStart
     [ method ]
     **
     * Creates @Paper.set. All elements that will be created after calling this method and before calling
     * @Paper.setFinish will be added to the set.
     **
     > Usage
     | paper.setStart();
     | paper.circle(10, 10, 5),
     | paper.circle(30, 10, 5)
     | var st = paper.setFinish();
     | st.attr({fill: "red"}); // changes the fill of both circles
    \*/
    paperproto.setStart = function (set) {
        this.__set__ = set || this.set();
    };
    /*\
     * Paper.setFinish
     [ method ]
     **
     * See @Paper.setStart. This method finishes catching and returns resulting set.
     **
     = (object) set
    \*/
    paperproto.setFinish = function (set) {
        var out = this.__set__;
        delete this.__set__;
        return out;
    };
    /*\
     * Paper.setSize
     [ method ]
     **
     * If you need to change dimensions of the canvas call this method
     **
     > Parameters
     **
     - width (number) new width of the canvas
     - height (number) new height of the canvas
    \*/
    paperproto.setSize = function (width, height) {
        return R._engine.setSize.call(this, width, height);
    };
    /*\
     * Paper.setViewBox
     [ method ]
     **
     * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by 
     * specifying new boundaries.
     **
     > Parameters
     **
     - x (number) new x position, default is `0`
     - y (number) new y position, default is `0`
     - w (number) new width of the canvas
     - h (number) new height of the canvas
     - fit (boolean) `true` if you want graphics to fit into new boundary box
    \*/
    paperproto.setViewBox = function (x, y, w, h, fit) {
        return R._engine.setViewBox.call(this, x, y, w, h, fit);
    };
    /*\
     * Paper.top
     [ property ]
     **
     * Points to the topmost element on the paper
    \*/
    /*\
     * Paper.bottom
     [ property ]
     **
     * Points to the bottom element on the paper
    \*/
    paperproto.top = paperproto.bottom = null;
    /*\
     * Paper.raphael
     [ property ]
     **
     * Points to the @Raphael object/function
    \*/
    paperproto.raphael = R;
    var getOffset = function (elem) {
        var box = elem.getBoundingClientRect(),
            doc = elem.ownerDocument,
            body = doc.body,
            docElem = doc.documentElement,
            clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
            top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,
            left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
        return {
            y: top,
            x: left
        };
    };
    /*\
     * Paper.getElementByPoint
     [ method ]
     **
     * Returns you topmost element under given point.
     **
     = (object) Raphal element object
     > Parameters
     **
     - x (number) x coordinate from the top left corner of the window
     - y (number) y coordinate from the top left corner of the window
     > Usage
     | paper.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
    \*/
    paperproto.getElementByPoint = function (x, y) {
        var paper = this,
            svg = paper.canvas,
            target = g.doc.elementFromPoint(x, y);
        if (g.win.opera && target.tagName == "svg") {
            var so = getOffset(svg),
                sr = svg.createSVGRect();
            sr.x = x - so.x;
            sr.y = y - so.y;
            sr.width = sr.height = 1;
            var hits = svg.getIntersectionList(sr, null);
            if (hits.length) {
                target = hits[hits.length - 1];
            }
        }
        if (!target) {
            return null;
        }
        while (target.parentNode && target != svg.parentNode && !target.raphael) {
            target = target.parentNode;
        }
        target == paper.canvas.parentNode && (target = svg);
        target = target && target.raphael ? paper.getById(target.raphaelid) : null;
        return target;
    };

    /*\
     * Paper.getElementsByBBox
     [ method ]
     **
     * Returns set of elements that have an intersecting bounding box
     **
     > Parameters
     **
     - bbox (object) bbox to check with
     = (object) @Set
     \*/
    paperproto.getElementsByBBox = function (bbox) {
        var set = this.set();
        this.forEach(function (el) {
            if (R.isBBoxIntersect(el.getBBox(), bbox)) {
                set.push(el);
            }
        });
        return set;
    };

    /*\
     * Paper.getById
     [ method ]
     **
     * Returns you element by its internal ID.
     **
     > Parameters
     **
     - id (number) id
     = (object) Raphal element object
    \*/
    paperproto.getById = function (id) {
        var bot = this.bottom;
        while (bot) {
            if (bot.id == id) {
                return bot;
            }
            bot = bot.next;
        }
        return null;
    };
    /*\
     * Paper.forEach
     [ method ]
     **
     * Executes given function for each element on the paper
     *
     * If callback function returns `false` it will stop loop running.
     **
     > Parameters
     **
     - callback (function) function to run
     - thisArg (object) context object for the callback
     = (object) Paper object
     > Usage
     | paper.forEach(function (el) {
     |     el.attr({ stroke: "blue" });
     | });
    \*/
    paperproto.forEach = function (callback, thisArg) {
        var bot = this.bottom;
        while (bot) {
            if (callback.call(thisArg, bot) === false) {
                return this;
            }
            bot = bot.next;
        }
        return this;
    };
    /*\
     * Paper.getElementsByPoint
     [ method ]
     **
     * Returns set of elements that have common point inside
     **
     > Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (object) @Set
    \*/
    paperproto.getElementsByPoint = function (x, y) {
        var set = this.set();
        this.forEach(function (el) {
            if (el.isPointInside(x, y)) {
                set.push(el);
            }
        });
        return set;
    };
    function x_y() {
        return this.x + S + this.y;
    }
    function x_y_w_h() {
        return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
    }
    /*\
     * Element.isPointInside
     [ method ]
     **
     * Determine if given point is inside this elements shape
     **
     > Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (boolean) `true` if point inside the shape
    \*/
    elproto.isPointInside = function (x, y) {
        var rp = this.realPath = getPath[this.type](this);
        if (this.attr('transform') && this.attr('transform').length) {
            rp = R.transformPath(rp, this.attr('transform'));
        }
        return R.isPointInsidePath(rp, x, y);
    };
    /*\
     * Element.getBBox
     [ method ]
     **
     * Return bounding box for a given element
     **
     > Parameters
     **
     - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.
     = (object) Bounding box object:
     o {
     o     x: (number) top left corner x
     o     y: (number) top left corner y
     o     x2: (number) bottom right corner x
     o     y2: (number) bottom right corner y
     o     width: (number) width
     o     height: (number) height
     o }
    \*/
    elproto.getBBox = function (isWithoutTransform) {
        if (this.removed) {
            return {};
        }
        var _ = this._;
        if (isWithoutTransform) {
            if (_.dirty || !_.bboxwt) {
                this.realPath = getPath[this.type](this);
                _.bboxwt = pathDimensions(this.realPath);
                _.bboxwt.toString = x_y_w_h;
                _.dirty = 0;
            }
            return _.bboxwt;
        }
        if (_.dirty || _.dirtyT || !_.bbox) {
            if (_.dirty || !this.realPath) {
                _.bboxwt = 0;
                this.realPath = getPath[this.type](this);
            }
            _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));
            _.bbox.toString = x_y_w_h;
            _.dirty = _.dirtyT = 0;
        }
        return _.bbox;
    };
    /*\
     * Element.clone
     [ method ]
     **
     = (object) clone of a given element
     **
    \*/
    elproto.clone = function () {
        if (this.removed) {
            return null;
        }
        var out = this.paper[this.type]().attr(this.attr());
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /*\
     * Element.glow
     [ method ]
     **
     * Return set of elements that create glow-like effect around given element. See @Paper.set.
     *
     * Note: Glow is not connected to the element. If you change element attributes it wont adjust itself.
     **
     > Parameters
     **
     - glow (object) #optional parameters object with all properties optional:
     o {
     o     width (number) size of the glow, default is `10`
     o     fill (boolean) will it be filled, default is `false`
     o     opacity (number) opacity, default is `0.5`
     o     offsetx (number) horizontal offset, default is `0`
     o     offsety (number) vertical offset, default is `0`
     o     color (string) glow colour, default is `black`
     o }
     = (object) @Paper.set of elements that represents glow
    \*/
    elproto.glow = function (glow) {
        if (this.type == "text") {
            return null;
        }
        glow = glow || {};
        var s = {
            width: (glow.width || 10) + (+this.attr("stroke-width") || 1),
            fill: glow.fill || false,
            opacity: glow.opacity || .5,
            offsetx: glow.offsetx || 0,
            offsety: glow.offsety || 0,
            color: glow.color || "#000"
        },
            c = s.width / 2,
            r = this.paper,
            out = r.set(),
            path = this.realPath || getPath[this.type](this);
        path = this.matrix ? mapPath(path, this.matrix) : path;
        for (var i = 1; i < c + 1; i++) {
            out.push(r.path(path).attr({
                stroke: s.color,
                fill: s.fill ? s.color : "none",
                "stroke-linejoin": "round",
                "stroke-linecap": "round",
                "stroke-width": +(s.width / c * i).toFixed(3),
                opacity: +(s.opacity / c).toFixed(3)
            }));
        }
        return out.insertBefore(this).translate(s.offsetx, s.offsety);
    };
    var curveslengths = {},
    getPointAtSegmentLength = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
        if (length == null) {
            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
        } else {
            return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
        }
    },
    getLengthFactory = function (istotal, subpath) {
        return function (path, length, onlystart) {
            path = path2curve(path);
            var x, y, p, l, sp = "", subpaths = {}, point,
                len = 0;
            for (var i = 0, ii = path.length; i < ii; i++) {
                p = path[i];
                if (p[0] == "M") {
                    x = +p[1];
                    y = +p[2];
                } else {
                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                    if (len + l > length) {
                        if (subpath && !subpaths.start) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            sp += ["C" + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];
                            if (onlystart) {return sp;}
                            subpaths.start = sp;
                            sp = ["M" + point.x, point.y + "C" + point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]].join();
                            len += l;
                            x = +p[5];
                            y = +p[6];
                            continue;
                        }
                        if (!istotal && !subpath) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            return {x: point.x, y: point.y, alpha: point.alpha};
                        }
                    }
                    len += l;
                    x = +p[5];
                    y = +p[6];
                }
                sp += p.shift() + p;
            }
            subpaths.end = sp;
            point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
            point.alpha && (point = {x: point.x, y: point.y, alpha: point.alpha});
            return point;
        };
    };
    var getTotalLength = getLengthFactory(1),
        getPointAtLength = getLengthFactory(),
        getSubpathsAtLength = getLengthFactory(0, 1);
    /*\
     * Raphael.getTotalLength
     [ method ]
     **
     * Returns length of the given path in pixels.
     **
     > Parameters
     **
     - path (string) SVG path string.
     **
     = (number) length.
    \*/
    R.getTotalLength = getTotalLength;
    /*\
     * Raphael.getPointAtLength
     [ method ]
     **
     * Return coordinates of the point located at the given length on the given path.
     **
     > Parameters
     **
     - path (string) SVG path string
     - length (number)
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate
     o     y: (number) y coordinate
     o     alpha: (number) angle of derivative
     o }
    \*/
    R.getPointAtLength = getPointAtLength;
    /*\
     * Raphael.getSubpath
     [ method ]
     **
     * Return subpath of a given path from given length to given length.
     **
     > Parameters
     **
     - path (string) SVG path string
     - from (number) position of the start of the segment
     - to (number) position of the end of the segment
     **
     = (string) pathstring for the segment
    \*/
    R.getSubpath = function (path, from, to) {
        if (this.getTotalLength(path) - to < 1e-6) {
            return getSubpathsAtLength(path, from).end;
        }
        var a = getSubpathsAtLength(path, to, 1);
        return from ? getSubpathsAtLength(a, from).end : a;
    };
    /*\
     * Element.getTotalLength
     [ method ]
     **
     * Returns length of the path in pixels. Only works for element of path type.
     = (number) length.
    \*/
    elproto.getTotalLength = function () {
        var path = this.getPath();
        if (!path) {
            return;
        }

        if (this.node.getTotalLength) {
            return this.node.getTotalLength();
        }

        return getTotalLength(path);
    };
    /*\
     * Element.getPointAtLength
     [ method ]
     **
     * Return coordinates of the point located at the given length on the given path. Only works for element of path type.
     **
     > Parameters
     **
     - length (number)
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate
     o     y: (number) y coordinate
     o     alpha: (number) angle of derivative
     o }
    \*/
    elproto.getPointAtLength = function (length) {
        var path = this.getPath();
        if (!path) {
            return;
        }

        return getPointAtLength(path, length);
    };
    /*\
     * Element.getPath
     [ method ]
     **
     * Returns path of the element. Only works for elements of path type and simple elements like circle.
     = (object) path
     **
    \*/
    elproto.getPath = function () {
        var path,
            getPath = R._getPath[this.type];
        
        if (this.type == "text" || this.type == "set") {
            return;
        }

        if (getPath) {
            path = getPath(this);
        }

        return path;
    };
    /*\
     * Element.getSubpath
     [ method ]
     **
     * Return subpath of a given element from given length to given length. Only works for element of path type.
     **
     > Parameters
     **
     - from (number) position of the start of the segment
     - to (number) position of the end of the segment
     **
     = (string) pathstring for the segment
    \*/
    elproto.getSubpath = function (from, to) {
        var path = this.getPath();
        if (!path) {
            return;
        }

        return R.getSubpath(path, from, to);
    };
    /*\
     * Raphael.easing_formulas
     [ property ]
     **
     * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:
     # <ul>
     #     <li>linear</li>
     #     <li>&lt; or easeIn or ease-in</li>
     #     <li>> or easeOut or ease-out</li>
     #     <li>&lt;> or easeInOut or ease-in-out</li>
     #     <li>backIn or back-in</li>
     #     <li>backOut or back-out</li>
     #     <li>elastic</li>
     #     <li>bounce</li>
     # </ul>
     # <p>See also <a href="http://raphaeljs.com/easing.html">Easing demo</a>.</p>
    \*/
    var ef = R.easing_formulas = {
        linear: function (n) {
            return n;
        },
        "<": function (n) {
            return pow(n, 1.7);
        },
        ">": function (n) {
            return pow(n, .48);
        },
        "<>": function (n) {
            var q = .48 - n / 1.04,
                Q = math.sqrt(.1734 + q * q),
                x = Q - q,
                X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),
                y = -Q - q,
                Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),
                t = X + Y + .5;
            return (1 - t) * 3 * t * t + t * t * t;
        },
        backIn: function (n) {
            var s = 1.70158;
            return n * n * ((s + 1) * n - s);
        },
        backOut: function (n) {
            n = n - 1;
            var s = 1.70158;
            return n * n * ((s + 1) * n + s) + 1;
        },
        elastic: function (n) {
            if (n == !!n) {
                return n;
            }
            return pow(2, -10 * n) * math.sin((n - .075) * (2 * PI) / .3) + 1;
        },
        bounce: function (n) {
            var s = 7.5625,
                p = 2.75,
                l;
            if (n < (1 / p)) {
                l = s * n * n;
            } else {
                if (n < (2 / p)) {
                    n -= (1.5 / p);
                    l = s * n * n + .75;
                } else {
                    if (n < (2.5 / p)) {
                        n -= (2.25 / p);
                        l = s * n * n + .9375;
                    } else {
                        n -= (2.625 / p);
                        l = s * n * n + .984375;
                    }
                }
            }
            return l;
        }
    };
    ef.easeIn = ef["ease-in"] = ef["<"];
    ef.easeOut = ef["ease-out"] = ef[">"];
    ef.easeInOut = ef["ease-in-out"] = ef["<>"];
    ef["back-in"] = ef.backIn;
    ef["back-out"] = ef.backOut;

    var animationElements = [],
        requestAnimFrame = window.requestAnimationFrame       ||
                           window.webkitRequestAnimationFrame ||
                           window.mozRequestAnimationFrame    ||
                           window.oRequestAnimationFrame      ||
                           window.msRequestAnimationFrame     ||
                           function (callback) {
                               setTimeout(callback, 16);
                           },
        animation = function () {
            var Now = +new Date,
                l = 0;
            for (; l < animationElements.length; l++) {
                var e = animationElements[l];
                if (e.el.removed || e.paused) {
                    continue;
                }
                var time = Now - e.start,
                    ms = e.ms,
                    easing = e.easing,
                    from = e.from,
                    diff = e.diff,
                    to = e.to,
                    t = e.t,
                    that = e.el,
                    set = {},
                    now,
                    init = {},
                    key;
                if (e.initstatus) {
                    time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;
                    e.status = e.initstatus;
                    delete e.initstatus;
                    e.stop && animationElements.splice(l--, 1);
                } else {
                    e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;
                }
                if (time < 0) {
                    continue;
                }
                if (time < ms) {
                    var pos = easing(time / ms);
                    for (var attr in from) if (from[has](attr)) {
                        switch (availableAnimAttrs[attr]) {
                            case nu:
                                now = +from[attr] + pos * ms * diff[attr];
                                break;
                            case "colour":
                                now = "rgb(" + [
                                    upto255(round(from[attr].r + pos * ms * diff[attr].r)),
                                    upto255(round(from[attr].g + pos * ms * diff[attr].g)),
                                    upto255(round(from[attr].b + pos * ms * diff[attr].b))
                                ].join(",") + ")";
                                break;
                            case "path":
                                now = [];
                                for (var i = 0, ii = from[attr].length; i < ii; i++) {
                                    now[i] = [from[attr][i][0]];
                                    for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                        now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
                                    }
                                    now[i] = now[i].join(S);
                                }
                                now = now.join(S);
                                break;
                            case "transform":
                                if (diff[attr].real) {
                                    now = [];
                                    for (i = 0, ii = from[attr].length; i < ii; i++) {
                                        now[i] = [from[attr][i][0]];
                                        for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                            now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];
                                        }
                                    }
                                } else {
                                    var get = function (i) {
                                        return +from[attr][i] + pos * ms * diff[attr][i];
                                    };
                                    // now = [["r", get(2), 0, 0], ["t", get(3), get(4)], ["s", get(0), get(1), 0, 0]];
                                    now = [["m", get(0), get(1), get(2), get(3), get(4), get(5)]];
                                }
                                break;
                            case "csv":
                                if (attr == "clip-rect") {
                                    now = [];
                                    i = 4;
                                    while (i--) {
                                        now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                                    }
                                }
                                break;
                            default:
                                var from2 = [][concat](from[attr]);
                                now = [];
                                i = that.paper.customAttributes[attr].length;
                                while (i--) {
                                    now[i] = +from2[i] + pos * ms * diff[attr][i];
                                }
                                break;
                        }
                        set[attr] = now;
                    }
                    that.attr(set);
                    (function (id, that, anim) {
                        setTimeout(function () {
                            eve("raphael.anim.frame." + id, that, anim);
                        });
                    })(that.id, that, e.anim);
                } else {
                    (function(f, el, a) {
                        setTimeout(function() {
                            eve("raphael.anim.frame." + el.id, el, a);
                            eve("raphael.anim.finish." + el.id, el, a);
                            R.is(f, "function") && f.call(el);
                        });
                    })(e.callback, that, e.anim);
                    that.attr(to);
                    animationElements.splice(l--, 1);
                    if (e.repeat > 1 && !e.next) {
                        for (key in to) if (to[has](key)) {
                            init[key] = e.totalOrigin[key];
                        }
                        e.el.attr(init);
                        runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);
                    }
                    if (e.next && !e.stop) {
                        runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);
                    }
                }
            }
            R.svg && that && that.paper && that.paper.safari();
            animationElements.length && requestAnimFrame(animation);
        },
        upto255 = function (color) {
            return color > 255 ? 255 : color < 0 ? 0 : color;
        };
    /*\
     * Element.animateWith
     [ method ]
     **
     * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.
     **
     > Parameters
     **
     - el (object) element to sync with
     - anim (object) animation to sync with
     - params (object) #optional final attributes for the element, see also @Element.attr
     - ms (number) #optional number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     * or
     - element (object) element to sync with
     - anim (object) animation to sync with
     - animation (object) #optional animation object, see @Raphael.animation
     **
     = (object) original element
    \*/
    elproto.animateWith = function (el, anim, params, ms, easing, callback) {
        var element = this;
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback),
            x, y;
        runAnimation(a, element, a.percents[0], null, element.attr());
        for (var i = 0, ii = animationElements.length; i < ii; i++) {
            if (animationElements[i].anim == anim && animationElements[i].el == el) {
                animationElements[ii - 1].start = animationElements[i].start;
                break;
            }
        }
        return element;
        // 
        // 
        // var a = params ? R.animation(params, ms, easing, callback) : anim,
        //     status = element.status(anim);
        // return this.animate(a).status(a, status * anim.ms / a.ms);
    };
    function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
        var cx = 3 * p1x,
            bx = 3 * (p2x - p1x) - cx,
            ax = 1 - cx - bx,
            cy = 3 * p1y,
            by = 3 * (p2y - p1y) - cy,
            ay = 1 - cy - by;
        function sampleCurveX(t) {
            return ((ax * t + bx) * t + cx) * t;
        }
        function solve(x, epsilon) {
            var t = solveCurveX(x, epsilon);
            return ((ay * t + by) * t + cy) * t;
        }
        function solveCurveX(x, epsilon) {
            var t0, t1, t2, x2, d2, i;
            for(t2 = x, i = 0; i < 8; i++) {
                x2 = sampleCurveX(t2) - x;
                if (abs(x2) < epsilon) {
                    return t2;
                }
                d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
                if (abs(d2) < 1e-6) {
                    break;
                }
                t2 = t2 - x2 / d2;
            }
            t0 = 0;
            t1 = 1;
            t2 = x;
            if (t2 < t0) {
                return t0;
            }
            if (t2 > t1) {
                return t1;
            }
            while (t0 < t1) {
                x2 = sampleCurveX(t2);
                if (abs(x2 - x) < epsilon) {
                    return t2;
                }
                if (x > x2) {
                    t0 = t2;
                } else {
                    t1 = t2;
                }
                t2 = (t1 - t0) / 2 + t0;
            }
            return t2;
        }
        return solve(t, 1 / (200 * duration));
    }
    elproto.onAnimation = function (f) {
        f ? eve.on("raphael.anim.frame." + this.id, f) : eve.unbind("raphael.anim.frame." + this.id);
        return this;
    };
    function Animation(anim, ms) {
        var percents = [],
            newAnim = {};
        this.ms = ms;
        this.times = 1;
        if (anim) {
            for (var attr in anim) if (anim[has](attr)) {
                newAnim[toFloat(attr)] = anim[attr];
                percents.push(toFloat(attr));
            }
            percents.sort(sortByNumber);
        }
        this.anim = newAnim;
        this.top = percents[percents.length - 1];
        this.percents = percents;
    }
    /*\
     * Animation.delay
     [ method ]
     **
     * Creates a copy of existing animation object with given delay.
     **
     > Parameters
     **
     - delay (number) number of ms to pass between animation start and actual animation
     **
     = (object) new altered Animation object
     | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);
     | circle1.animate(anim); // run the given animation immediately
     | circle2.animate(anim.delay(500)); // run the given animation after 500 ms
    \*/
    Animation.prototype.delay = function (delay) {
        var a = new Animation(this.anim, this.ms);
        a.times = this.times;
        a.del = +delay || 0;
        return a;
    };
    /*\
     * Animation.repeat
     [ method ]
     **
     * Creates a copy of existing animation object with given repetition.
     **
     > Parameters
     **
     - repeat (number) number iterations of animation. For infinite animation pass `Infinity`
     **
     = (object) new altered Animation object
    \*/
    Animation.prototype.repeat = function (times) {
        var a = new Animation(this.anim, this.ms);
        a.del = this.del;
        a.times = math.floor(mmax(times, 0)) || 1;
        return a;
    };
    function runAnimation(anim, element, percent, status, totalOrigin, times) {
        percent = toFloat(percent);
        var params,
            isInAnim,
            isInAnimSet,
            percents = [],
            next,
            prev,
            timestamp,
            ms = anim.ms,
            from = {},
            to = {},
            diff = {};
        if (status) {
            for (i = 0, ii = animationElements.length; i < ii; i++) {
                var e = animationElements[i];
                if (e.el.id == element.id && e.anim == anim) {
                    if (e.percent != percent) {
                        animationElements.splice(i, 1);
                        isInAnimSet = 1;
                    } else {
                        isInAnim = e;
                    }
                    element.attr(e.totalOrigin);
                    break;
                }
            }
        } else {
            status = +to; // NaN
        }
        for (var i = 0, ii = anim.percents.length; i < ii; i++) {
            if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {
                percent = anim.percents[i];
                prev = anim.percents[i - 1] || 0;
                ms = ms / anim.top * (percent - prev);
                next = anim.percents[i + 1];
                params = anim.anim[percent];
                break;
            } else if (status) {
                element.attr(anim.anim[anim.percents[i]]);
            }
        }
        if (!params) {
            return;
        }
        if (!isInAnim) {
            for (var attr in params) if (params[has](attr)) {
                if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
                    from[attr] = element.attr(attr);
                    (from[attr] == null) && (from[attr] = availableAttrs[attr]);
                    to[attr] = params[attr];
                    switch (availableAnimAttrs[attr]) {
                        case nu:
                            diff[attr] = (to[attr] - from[attr]) / ms;
                            break;
                        case "colour":
                            from[attr] = R.getRGB(from[attr]);
                            var toColour = R.getRGB(to[attr]);
                            diff[attr] = {
                                r: (toColour.r - from[attr].r) / ms,
                                g: (toColour.g - from[attr].g) / ms,
                                b: (toColour.b - from[attr].b) / ms
                            };
                            break;
                        case "path":
                            var pathes = path2curve(from[attr], to[attr]),
                                toPath = pathes[1];
                            from[attr] = pathes[0];
                            diff[attr] = [];
                            for (i = 0, ii = from[attr].length; i < ii; i++) {
                                diff[attr][i] = [0];
                                for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                    diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
                                }
                            }
                            break;
                        case "transform":
                            var _ = element._,
                                eq = equaliseTransform(_[attr], to[attr]);
                            if (eq) {
                                from[attr] = eq.from;
                                to[attr] = eq.to;
                                diff[attr] = [];
                                diff[attr].real = true;
                                for (i = 0, ii = from[attr].length; i < ii; i++) {
                                    diff[attr][i] = [from[attr][i][0]];
                                    for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                        diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;
                                    }
                                }
                            } else {
                                var m = (element.matrix || new Matrix),
                                    to2 = {
                                        _: {transform: _.transform},
                                        getBBox: function () {
                                            return element.getBBox(1);
                                        }
                                    };
                                from[attr] = [
                                    m.a,
                                    m.b,
                                    m.c,
                                    m.d,
                                    m.e,
                                    m.f
                                ];
                                extractTransform(to2, to[attr]);
                                to[attr] = to2._.transform;
                                diff[attr] = [
                                    (to2.matrix.a - m.a) / ms,
                                    (to2.matrix.b - m.b) / ms,
                                    (to2.matrix.c - m.c) / ms,
                                    (to2.matrix.d - m.d) / ms,
                                    (to2.matrix.e - m.e) / ms,
                                    (to2.matrix.f - m.f) / ms
                                ];
                                // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];
                                // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};
                                // extractTransform(to2, to[attr]);
                                // diff[attr] = [
                                //     (to2._.sx - _.sx) / ms,
                                //     (to2._.sy - _.sy) / ms,
                                //     (to2._.deg - _.deg) / ms,
                                //     (to2._.dx - _.dx) / ms,
                                //     (to2._.dy - _.dy) / ms
                                // ];
                            }
                            break;
                        case "csv":
                            var values = Str(params[attr])[split](separator),
                                from2 = Str(from[attr])[split](separator);
                            if (attr == "clip-rect") {
                                from[attr] = from2;
                                diff[attr] = [];
                                i = from2.length;
                                while (i--) {
                                    diff[attr][i] = (values[i] - from[attr][i]) / ms;
                                }
                            }
                            to[attr] = values;
                            break;
                        default:
                            values = [][concat](params[attr]);
                            from2 = [][concat](from[attr]);
                            diff[attr] = [];
                            i = element.paper.customAttributes[attr].length;
                            while (i--) {
                                diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
                            }
                            break;
                    }
                }
            }
            var easing = params.easing,
                easyeasy = R.easing_formulas[easing];
            if (!easyeasy) {
                easyeasy = Str(easing).match(bezierrg);
                if (easyeasy && easyeasy.length == 5) {
                    var curve = easyeasy;
                    easyeasy = function (t) {
                        return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
                    };
                } else {
                    easyeasy = pipe;
                }
            }
            timestamp = params.start || anim.start || +new Date;
            e = {
                anim: anim,
                percent: percent,
                timestamp: timestamp,
                start: timestamp + (anim.del || 0),
                status: 0,
                initstatus: status || 0,
                stop: false,
                ms: ms,
                easing: easyeasy,
                from: from,
                diff: diff,
                to: to,
                el: element,
                callback: params.callback,
                prev: prev,
                next: next,
                repeat: times || anim.times,
                origin: element.attr(),
                totalOrigin: totalOrigin
            };
            animationElements.push(e);
            if (status && !isInAnim && !isInAnimSet) {
                e.stop = true;
                e.start = new Date - ms * status;
                if (animationElements.length == 1) {
                    return animation();
                }
            }
            if (isInAnimSet) {
                e.start = new Date - e.ms * status;
            }
            animationElements.length == 1 && requestAnimFrame(animation);
        } else {
            isInAnim.initstatus = status;
            isInAnim.start = new Date - isInAnim.ms * status;
        }
        eve("raphael.anim.start." + element.id, element, anim);
    }
    /*\
     * Raphael.animation
     [ method ]
     **
     * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.
     * See also @Animation.delay and @Animation.repeat methods.
     **
     > Parameters
     **
     - params (object) final attributes for the element, see also @Element.attr
     - ms (number) number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     **
     = (object) @Animation
    \*/
    R.animation = function (params, ms, easing, callback) {
        if (params instanceof Animation) {
            return params;
        }
        if (R.is(easing, "function") || !easing) {
            callback = callback || easing || null;
            easing = null;
        }
        params = Object(params);
        ms = +ms || 0;
        var p = {},
            json,
            attr;
        for (attr in params) if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + "%" != attr) {
            json = true;
            p[attr] = params[attr];
        }
        if (!json) {
            return new Animation(params, ms);
        } else {
            easing && (p.easing = easing);
            callback && (p.callback = callback);
            return new Animation({100: p}, ms);
        }
    };
    /*\
     * Element.animate
     [ method ]
     **
     * Creates and starts animation for given element.
     **
     > Parameters
     **
     - params (object) final attributes for the element, see also @Element.attr
     - ms (number) number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     * or
     - animation (object) animation object, see @Raphael.animation
     **
     = (object) original element
    \*/
    elproto.animate = function (params, ms, easing, callback) {
        var element = this;
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);
        runAnimation(anim, element, anim.percents[0], null, element.attr());
        return element;
    };
    /*\
     * Element.setTime
     [ method ]
     **
     * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.
     **
     > Parameters
     **
     - anim (object) animation object
     - value (number) number of milliseconds from the beginning of the animation
     **
     = (object) original element if `value` is specified
     * Note, that during animation following events are triggered:
     *
     * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.
    \*/
    elproto.setTime = function (anim, value) {
        if (anim && value != null) {
            this.status(anim, mmin(value, anim.ms) / anim.ms);
        }
        return this;
    };
    /*\
     * Element.status
     [ method ]
     **
     * Gets or sets the status of animation of the element.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     - value (number) #optional 0  1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.
     **
     = (number) status
     * or
     = (array) status if `anim` is not specified. Array of objects in format:
     o {
     o     anim: (object) animation object
     o     status: (number) status
     o }
     * or
     = (object) original element if `value` is specified
    \*/
    elproto.status = function (anim, value) {
        var out = [],
            i = 0,
            len,
            e;
        if (value != null) {
            runAnimation(anim, this, -1, mmin(value, 1));
            return this;
        } else {
            len = animationElements.length;
            for (; i < len; i++) {
                e = animationElements[i];
                if (e.el.id == this.id && (!anim || e.anim == anim)) {
                    if (anim) {
                        return e.status;
                    }
                    out.push({
                        anim: e.anim,
                        status: e.status
                    });
                }
            }
            if (anim) {
                return 0;
            }
            return out;
        }
    };
    /*\
     * Element.pause
     [ method ]
     **
     * Stops animation of the element with ability to resume it later on.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
    \*/
    elproto.pause = function (anim) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            if (eve("raphael.anim.pause." + this.id, this, animationElements[i].anim) !== false) {
                animationElements[i].paused = true;
            }
        }
        return this;
    };
    /*\
     * Element.resume
     [ method ]
     **
     * Resumes animation if it was paused with @Element.pause method.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
    \*/
    elproto.resume = function (anim) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            var e = animationElements[i];
            if (eve("raphael.anim.resume." + this.id, this, e.anim) !== false) {
                delete e.paused;
                this.status(e.anim, e.status);
            }
        }
        return this;
    };
    /*\
     * Element.stop
     [ method ]
     **
     * Stops animation of the element.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
    \*/
    elproto.stop = function (anim) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            if (eve("raphael.anim.stop." + this.id, this, animationElements[i].anim) !== false) {
                animationElements.splice(i--, 1);
            }
        }
        return this;
    };
    function stopAnimation(paper) {
        for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.paper == paper) {
            animationElements.splice(i--, 1);
        }
    }
    eve.on("raphael.remove", stopAnimation);
    eve.on("raphael.clear", stopAnimation);
    elproto.toString = function () {
        return "Rapha\xebl\u2019s object";
    };

    // Set
    var Set = function (items) {
        this.items = [];
        this.length = 0;
        this.type = "set";
        if (items) {
            for (var i = 0, ii = items.length; i < ii; i++) {
                if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {
                    this[this.items.length] = this.items[this.items.length] = items[i];
                    this.length++;
                }
            }
        }
    },
    setproto = Set.prototype;
    /*\
     * Set.push
     [ method ]
     **
     * Adds each argument to the current set.
     = (object) original element
    \*/
    setproto.push = function () {
        var item,
            len;
        for (var i = 0, ii = arguments.length; i < ii; i++) {
            item = arguments[i];
            if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {
                len = this.items.length;
                this[len] = this.items[len] = item;
                this.length++;
            }
        }
        return this;
    };
    /*\
     * Set.pop
     [ method ]
     **
     * Removes last element and returns it.
     = (object) element
    \*/
    setproto.pop = function () {
        this.length && delete this[this.length--];
        return this.items.pop();
    };
    /*\
     * Set.forEach
     [ method ]
     **
     * Executes given function for each element in the set.
     *
     * If function returns `false` it will stop loop running.
     **
     > Parameters
     **
     - callback (function) function to run
     - thisArg (object) context object for the callback
     = (object) Set object
    \*/
    setproto.forEach = function (callback, thisArg) {
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            if (callback.call(thisArg, this.items[i], i) === false) {
                return this;
            }
        }
        return this;
    };
    for (var method in elproto) if (elproto[has](method)) {
        setproto[method] = (function (methodname) {
            return function () {
                var arg = arguments;
                return this.forEach(function (el) {
                    el[methodname][apply](el, arg);
                });
            };
        })(method);
    }
    setproto.attr = function (name, value) {
        if (name && R.is(name, array) && R.is(name[0], "object")) {
            for (var j = 0, jj = name.length; j < jj; j++) {
                this.items[j].attr(name[j]);
            }
        } else {
            for (var i = 0, ii = this.items.length; i < ii; i++) {
                this.items[i].attr(name, value);
            }
        }
        return this;
    };
    /*\
     * Set.clear
     [ method ]
     **
     * Removeds all elements from the set
    \*/
    setproto.clear = function () {
        while (this.length) {
            this.pop();
        }
    };
    /*\
     * Set.splice
     [ method ]
     **
     * Removes given element from the set
     **
     > Parameters
     **
     - index (number) position of the deletion
     - count (number) number of element to remove
     - insertion (object) #optional elements to insert
     = (object) set elements that were deleted
    \*/
    setproto.splice = function (index, count, insertion) {
        index = index < 0 ? mmax(this.length + index, 0) : index;
        count = mmax(0, mmin(this.length - index, count));
        var tail = [],
            todel = [],
            args = [],
            i;
        for (i = 2; i < arguments.length; i++) {
            args.push(arguments[i]);
        }
        for (i = 0; i < count; i++) {
            todel.push(this[index + i]);
        }
        for (; i < this.length - index; i++) {
            tail.push(this[index + i]);
        }
        var arglen = args.length;
        for (i = 0; i < arglen + tail.length; i++) {
            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
        }
        i = this.items.length = this.length -= count - arglen;
        while (this[i]) {
            delete this[i++];
        }
        return new Set(todel);
    };
    /*\
     * Set.exclude
     [ method ]
     **
     * Removes given element from the set
     **
     > Parameters
     **
     - element (object) element to remove
     = (boolean) `true` if object was found & removed from the set
    \*/
    setproto.exclude = function (el) {
        for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {
            this.splice(i, 1);
            return true;
        }
    };
    setproto.animate = function (params, ms, easing, callback) {
        (R.is(easing, "function") || !easing) && (callback = easing || null);
        var len = this.items.length,
            i = len,
            item,
            set = this,
            collector;
        if (!len) {
            return this;
        }
        callback && (collector = function () {
            !--len && callback.call(set);
        });
        easing = R.is(easing, string) ? easing : collector;
        var anim = R.animation(params, ms, easing, collector);
        item = this.items[--i].animate(anim);
        while (i--) {
            this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);
            (this.items[i] && !this.items[i].removed) || len--;
        }
        return this;
    };
    setproto.insertAfter = function (el) {
        var i = this.items.length;
        while (i--) {
            this.items[i].insertAfter(el);
        }
        return this;
    };
    setproto.getBBox = function () {
        var x = [],
            y = [],
            x2 = [],
            y2 = [];
        for (var i = this.items.length; i--;) if (!this.items[i].removed) {
            var box = this.items[i].getBBox();
            x.push(box.x);
            y.push(box.y);
            x2.push(box.x + box.width);
            y2.push(box.y + box.height);
        }
        x = mmin[apply](0, x);
        y = mmin[apply](0, y);
        x2 = mmax[apply](0, x2);
        y2 = mmax[apply](0, y2);
        return {
            x: x,
            y: y,
            x2: x2,
            y2: y2,
            width: x2 - x,
            height: y2 - y
        };
    };
    setproto.clone = function (s) {
        s = this.paper.set();
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            s.push(this.items[i].clone());
        }
        return s;
    };
    setproto.toString = function () {
        return "Rapha\xebl\u2018s set";
    };

    setproto.glow = function(glowConfig) {
        var ret = this.paper.set();
        this.forEach(function(shape, index){
            var g = shape.glow(glowConfig);
            if(g != null){
                g.forEach(function(shape2, index2){
                    ret.push(shape2);
                });
            }
        });
        return ret;
    };


    /*\
     * Set.isPointInside
     [ method ]
     **
     * Determine if given point is inside this sets elements
     **
     > Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (boolean) `true` if point is inside any of the set's elements
     \*/
    setproto.isPointInside = function (x, y) {
        var isPointInside = false;
        this.forEach(function (el) {
            if (el.isPointInside(x, y)) {
                isPointInside = true;
                return false; // stop loop
            }
        });
        return isPointInside;
    };

    /*\
     * Raphael.registerFont
     [ method ]
     **
     * Adds given font to the registered set of fonts for Raphal. Should be used as an internal call from within Cufns font file.
     * Returns original parameter, so it could be used with chaining.
     # <a href="http://wiki.github.com/sorccu/cufon/about">More about Cufn and how to convert your font form TTF, OTF, etc to JavaScript file.</a>
     **
     > Parameters
     **
     - font (object) the font to register
     = (object) the font you passed in
     > Usage
     | Cufon.registerFont(Raphael.registerFont({}));
    \*/
    R.registerFont = function (font) {
        if (!font.face) {
            return font;
        }
        this.fonts = this.fonts || {};
        var fontcopy = {
                w: font.w,
                face: {},
                glyphs: {}
            },
            family = font.face["font-family"];
        for (var prop in font.face) if (font.face[has](prop)) {
            fontcopy.face[prop] = font.face[prop];
        }
        if (this.fonts[family]) {
            this.fonts[family].push(fontcopy);
        } else {
            this.fonts[family] = [fontcopy];
        }
        if (!font.svg) {
            fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);
            for (var glyph in font.glyphs) if (font.glyphs[has](glyph)) {
                var path = font.glyphs[glyph];
                fontcopy.glyphs[glyph] = {
                    w: path.w,
                    k: {},
                    d: path.d && "M" + path.d.replace(/[mlcxtrv]/g, function (command) {
                            return {l: "L", c: "C", x: "z", t: "m", r: "l", v: "c"}[command] || "M";
                        }) + "z"
                };
                if (path.k) {
                    for (var k in path.k) if (path[has](k)) {
                        fontcopy.glyphs[glyph].k[k] = path.k[k];
                    }
                }
            }
        }
        return font;
    };
    /*\
     * Paper.getFont
     [ method ]
     **
     * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like Myriad for Myriad Pro.
     **
     > Parameters
     **
     - family (string) font family name or any word from it
     - weight (string) #optional font weight
     - style (string) #optional font style
     - stretch (string) #optional font stretch
     = (object) the font object
     > Usage
     | paper.print(100, 100, "Test string", paper.getFont("Times", 800), 30);
    \*/
    paperproto.getFont = function (family, weight, style, stretch) {
        stretch = stretch || "normal";
        style = style || "normal";
        weight = +weight || {normal: 400, bold: 700, lighter: 300, bolder: 800}[weight] || 400;
        if (!R.fonts) {
            return;
        }
        var font = R.fonts[family];
        if (!font) {
            var name = new RegExp("(^|\\s)" + family.replace(/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");
            for (var fontName in R.fonts) if (R.fonts[has](fontName)) {
                if (name.test(fontName)) {
                    font = R.fonts[fontName];
                    break;
                }
            }
        }
        var thefont;
        if (font) {
            for (var i = 0, ii = font.length; i < ii; i++) {
                thefont = font[i];
                if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) {
                    break;
                }
            }
        }
        return thefont;
    };
    /*\
     * Paper.print
     [ method ]
     **
     * Creates path that represent given text written using given font at given position with given size.
     * Result of the method is path element that contains whole text as a separate path.
     **
     > Parameters
     **
     - x (number) x position of the text
     - y (number) y position of the text
     - string (string) text to print
     - font (object) font object, see @Paper.getFont
     - size (number) #optional size of the font, default is `16`
     - origin (string) #optional could be `"baseline"` or `"middle"`, default is `"middle"`
     - letter_spacing (number) #optional number in range `-1..1`, default is `0`
     - line_spacing (number) #optional number in range `1..3`, default is `1`
     = (object) resulting path element, which consist of all letters
     > Usage
     | var txt = r.print(10, 50, "print", r.getFont("Museo"), 30).attr({fill: "#fff"});
    \*/
    paperproto.print = function (x, y, string, font, size, origin, letter_spacing, line_spacing) {
        origin = origin || "middle"; // baseline|middle
        letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
        line_spacing = mmax(mmin(line_spacing || 1, 3), 1);
        var letters = Str(string)[split](E),
            shift = 0,
            notfirst = 0,
            path = E,
            scale;
        R.is(font, "string") && (font = this.getFont(font));
        if (font) {
            scale = (size || 16) / font.face["units-per-em"];
            var bb = font.face.bbox[split](separator),
                top = +bb[0],
                lineHeight = bb[3] - bb[1],
                shifty = 0,
                height = +bb[1] + (origin == "baseline" ? lineHeight + (+font.face.descent) : lineHeight / 2);
            for (var i = 0, ii = letters.length; i < ii; i++) {
                if (letters[i] == "\n") {
                    shift = 0;
                    curr = 0;
                    notfirst = 0;
                    shifty += lineHeight * line_spacing;
                } else {
                    var prev = notfirst && font.glyphs[letters[i - 1]] || {},
                        curr = font.glyphs[letters[i]];
                    shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + (font.w * letter_spacing) : 0;
                    notfirst = 1;
                }
                if (curr && curr.d) {
                    path += R.transformPath(curr.d, ["t", shift * scale, shifty * scale, "s", scale, scale, top, height, "t", (x - top) / scale, (y - height) / scale]);
                }
            }
        }
        return this.path(path).attr({
            fill: "#000",
            stroke: "none"
        });
    };

    /*\
     * Paper.add
     [ method ]
     **
     * Imports elements in JSON array in format `{type: type, <attributes>}`
     **
     > Parameters
     **
     - json (array)
     = (object) resulting set of imported elements
     > Usage
     | paper.add([
     |     {
     |         type: "circle",
     |         cx: 10,
     |         cy: 10,
     |         r: 5
     |     },
     |     {
     |         type: "rect",
     |         x: 10,
     |         y: 10,
     |         width: 10,
     |         height: 10,
     |         fill: "#fc0"
     |     }
     | ]);
    \*/
    paperproto.add = function (json) {
        if (R.is(json, "array")) {
            var res = this.set(),
                i = 0,
                ii = json.length,
                j;
            for (; i < ii; i++) {
                j = json[i] || {};
                elements[has](j.type) && res.push(this[j.type]().attr(j));
            }
        }
        return res;
    };

    /*\
     * Raphael.format
     [ method ]
     **
     * Simple format function. Replaces construction of type `{<number>}` to the corresponding argument.
     **
     > Parameters
     **
     - token (string) string to format
     -  (string) rest of arguments will be treated as parameters for replacement
     = (string) formated string
     > Usage
     | var x = 10,
     |     y = 20,
     |     width = 40,
     |     height = 50;
     | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
     | paper.path(Raphael.format("M{0},{1}h{2}v{3}h{4}z", x, y, width, height, -width));
    \*/
    R.format = function (token, params) {
        var args = R.is(params, array) ? [0][concat](params) : arguments;
        token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function (str, i) {
            return args[++i] == null ? E : args[i];
        }));
        return token || E;
    };
    /*\
     * Raphael.fullfill
     [ method ]
     **
     * A little bit more advanced format function than @Raphael.format. Replaces construction of type `{<name>}` to the corresponding argument.
     **
     > Parameters
     **
     - token (string) string to format
     - json (object) object which properties will be used as a replacement
     = (string) formated string
     > Usage
     | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
     | paper.path(Raphael.fullfill("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
     |     x: 10,
     |     y: 20,
     |     dim: {
     |         width: 40,
     |         height: 50,
     |         "negative width": -40
     |     }
     | }));
    \*/
    R.fullfill = (function () {
        var tokenRegex = /\{([^\}]+)\}/g,
            objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
            replacer = function (all, key, obj) {
                var res = obj;
                key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
                    name = name || quotedName;
                    if (res) {
                        if (name in res) {
                            res = res[name];
                        }
                        typeof res == "function" && isFunc && (res = res());
                    }
                });
                res = (res == null || res == obj ? all : res) + "";
                return res;
            };
        return function (str, obj) {
            return String(str).replace(tokenRegex, function (all, key) {
                return replacer(all, key, obj);
            });
        };
    })();
    /*\
     * Raphael.ninja
     [ method ]
     **
     * If you want to leave no trace of Raphal (Well, Raphal creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.
     * Beware, that in this case plugins could stop working, because they are depending on global variable existance.
     **
     = (object) Raphael object
     > Usage
     | (function (local_raphael) {
     |     var paper = local_raphael(10, 10, 320, 200);
     |     
     | })(Raphael.ninja());
    \*/
    R.ninja = function () {
        oldRaphael.was ? (g.win.Raphael = oldRaphael.is) : delete Raphael;
        return R;
    };
    /*\
     * Raphael.st
     [ property (object) ]
     **
     * You can add your own method to elements and sets. It is wise to add a set method for each element method
     * you added, so you will be able to call the same method on sets too.
     **
     * See also @Raphael.el.
     > Usage
     | Raphael.el.red = function () {
     |     this.attr({fill: "#f00"});
     | };
     | Raphael.st.red = function () {
     |     this.forEach(function (el) {
     |         el.red();
     |     });
     | };
     | // then use it
     | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();
    \*/
    R.st = setproto;
    // Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html
    (function (doc, loaded, f) {
        if (doc.readyState == null && doc.addEventListener){
            doc.addEventListener(loaded, f = function () {
                doc.removeEventListener(loaded, f, false);
                doc.readyState = "complete";
            }, false);
            doc.readyState = "loading";
        }
        function isLoaded() {
            (/in/).test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve("raphael.DOMload");
        }
        isLoaded();
    })(document, "DOMContentLoaded");

    eve.on("raphael.DOMload", function () {
        loaded = true;
    });

//  \\
//  Raphal - JavaScript Vector Library                                  \\
//  \\
//  SVG Module                                                           \\
//  \\
//  Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)    \\
//  Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)              \\
//  Licensed under the MIT (http://raphaeljs.com/license.html) license.  \\
//  \\

(function(){
    if (!R.svg) {
        return;
    }
    var has = "hasOwnProperty",
        Str = String,
        toFloat = parseFloat,
        toInt = parseInt,
        math = Math,
        mmax = math.max,
        abs = math.abs,
        pow = math.pow,
        separator = /[, ]+/,
        eve = R.eve,
        E = "",
        S = " ";
    var xlink = "http://www.w3.org/1999/xlink",
        markers = {
            block: "M5,0 0,2.5 5,5z",
            classic: "M5,0 0,2.5 5,5 3.5,3 3.5,2z",
            diamond: "M2.5,0 5,2.5 2.5,5 0,2.5z",
            open: "M6,1 1,3.5 6,6",
            oval: "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"
        },
        markerCounter = {};
    R.toString = function () {
        return  "Your browser supports SVG.\nYou are running Rapha\xebl " + this.version;
    };
    var $ = function (el, attr) {
        if (attr) {
            if (typeof el == "string") {
                el = $(el);
            }
            for (var key in attr) if (attr[has](key)) {
                if (key.substring(0, 6) == "xlink:") {
                    el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));
                } else {
                    el.setAttribute(key, Str(attr[key]));
                }
            }
        } else {
            el = R._g.doc.createElementNS("http://www.w3.org/2000/svg", el);
            el.style && (el.style.webkitTapHighlightColor = "rgba(0,0,0,0)");
        }
        return el;
    },
    addGradientFill = function (element, gradient) {
        var type = "linear",
            id = element.id + gradient,
            fx = .5, fy = .5,
            o = element.node,
            SVG = element.paper,
            s = o.style,
            el = R._g.doc.getElementById(id);
        if (!el) {
            gradient = Str(gradient).replace(R._radial_gradient, function (all, _fx, _fy) {
                type = "radial";
                if (_fx && _fy) {
                    fx = toFloat(_fx);
                    fy = toFloat(_fy);
                    var dir = ((fy > .5) * 2 - 1);
                    pow(fx - .5, 2) + pow(fy - .5, 2) > .25 &&
                        (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) &&
                        fy != .5 &&
                        (fy = fy.toFixed(5) - 1e-5 * dir);
                }
                return E;
            });
            gradient = gradient.split(/\s*\-\s*/);
            if (type == "linear") {
                var angle = gradient.shift();
                angle = -toFloat(angle);
                if (isNaN(angle)) {
                    return null;
                }
                var vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))],
                    max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
                vector[2] *= max;
                vector[3] *= max;
                if (vector[2] < 0) {
                    vector[0] = -vector[2];
                    vector[2] = 0;
                }
                if (vector[3] < 0) {
                    vector[1] = -vector[3];
                    vector[3] = 0;
                }
            }
            var dots = R._parseDots(gradient);
            if (!dots) {
                return null;
            }
            id = id.replace(/[\(\)\s,\xb0#]/g, "_");
            
            if (element.gradient && id != element.gradient.id) {
                SVG.defs.removeChild(element.gradient);
                delete element.gradient;
            }

            if (!element.gradient) {
                el = $(type + "Gradient", {id: id});
                element.gradient = el;
                $(el, type == "radial" ? {
                    fx: fx,
                    fy: fy
                } : {
                    x1: vector[0],
                    y1: vector[1],
                    x2: vector[2],
                    y2: vector[3],
                    gradientTransform: element.matrix.invert()
                });
                SVG.defs.appendChild(el);
                for (var i = 0, ii = dots.length; i < ii; i++) {
                    el.appendChild($("stop", {
                        offset: dots[i].offset ? dots[i].offset : i ? "100%" : "0%",
                        "stop-color": dots[i].color || "#fff"
                    }));
                }
            }
        }
        $(o, {
            fill: "url(#" + id + ")",
            opacity: 1,
            "fill-opacity": 1
        });
        s.fill = E;
        s.opacity = 1;
        s.fillOpacity = 1;
        return 1;
    },
    updatePosition = function (o) {
        var bbox = o.getBBox(1);
        $(o.pattern, {patternTransform: o.matrix.invert() + " translate(" + bbox.x + "," + bbox.y + ")"});
    },
    addArrow = function (o, value, isEnd) {
        if (o.type == "path") {
            var values = Str(value).toLowerCase().split("-"),
                p = o.paper,
                se = isEnd ? "end" : "start",
                node = o.node,
                attrs = o.attrs,
                stroke = attrs["stroke-width"],
                i = values.length,
                type = "classic",
                from,
                to,
                dx,
                refX,
                attr,
                w = 3,
                h = 3,
                t = 5;
            while (i--) {
                switch (values[i]) {
                    case "block":
                    case "classic":
                    case "oval":
                    case "diamond":
                    case "open":
                    case "none":
                        type = values[i];
                        break;
                    case "wide": h = 5; break;
                    case "narrow": h = 2; break;
                    case "long": w = 5; break;
                    case "short": w = 2; break;
                }
            }
            if (type == "open") {
                w += 2;
                h += 2;
                t += 2;
                dx = 1;
                refX = isEnd ? 4 : 1;
                attr = {
                    fill: "none",
                    stroke: attrs.stroke
                };
            } else {
                refX = dx = w / 2;
                attr = {
                    fill: attrs.stroke,
                    stroke: "none"
                };
            }
            if (o._.arrows) {
                if (isEnd) {
                    o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;
                    o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;
                } else {
                    o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;
                    o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;
                }
            } else {
                o._.arrows = {};
            }
            if (type != "none") {
                var pathId = "raphael-marker-" + type,
                    markerId = "raphael-marker-" + se + type + w + h;
                if (!R._g.doc.getElementById(pathId)) {
                    p.defs.appendChild($($("path"), {
                        "stroke-linecap": "round",
                        d: markers[type],
                        id: pathId
                    }));
                    markerCounter[pathId] = 1;
                } else {
                    markerCounter[pathId]++;
                }
                var marker = R._g.doc.getElementById(markerId),
                    use;
                if (!marker) {
                    marker = $($("marker"), {
                        id: markerId,
                        markerHeight: h,
                        markerWidth: w,
                        orient: "auto",
                        refX: refX,
                        refY: h / 2
                    });
                    use = $($("use"), {
                        "xlink:href": "#" + pathId,
                        transform: (isEnd ? "rotate(180 " + w / 2 + " " + h / 2 + ") " : E) + "scale(" + w / t + "," + h / t + ")",
                        "stroke-width": (1 / ((w / t + h / t) / 2)).toFixed(4)
                    });
                    marker.appendChild(use);
                    p.defs.appendChild(marker);
                    markerCounter[markerId] = 1;
                } else {
                    markerCounter[markerId]++;
                    use = marker.getElementsByTagName("use")[0];
                }
                $(use, attr);
                var delta = dx * (type != "diamond" && type != "oval");
                if (isEnd) {
                    from = o._.arrows.startdx * stroke || 0;
                    to = R.getTotalLength(attrs.path) - delta * stroke;
                } else {
                    from = delta * stroke;
                    to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                }
                attr = {};
                attr["marker-" + se] = "url(#" + markerId + ")";
                if (to || from) {
                    attr.d = R.getSubpath(attrs.path, from, to);
                }
                $(node, attr);
                o._.arrows[se + "Path"] = pathId;
                o._.arrows[se + "Marker"] = markerId;
                o._.arrows[se + "dx"] = delta;
                o._.arrows[se + "Type"] = type;
                o._.arrows[se + "String"] = value;
            } else {
                if (isEnd) {
                    from = o._.arrows.startdx * stroke || 0;
                    to = R.getTotalLength(attrs.path) - from;
                } else {
                    from = 0;
                    to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                }
                o._.arrows[se + "Path"] && $(node, {d: R.getSubpath(attrs.path, from, to)});
                delete o._.arrows[se + "Path"];
                delete o._.arrows[se + "Marker"];
                delete o._.arrows[se + "dx"];
                delete o._.arrows[se + "Type"];
                delete o._.arrows[se + "String"];
            }
            for (attr in markerCounter) if (markerCounter[has](attr) && !markerCounter[attr]) {
                var item = R._g.doc.getElementById(attr);
                item && item.parentNode.removeChild(item);
            }
        }
    },
    dasharray = {
        "": [0],
        "none": [0],
        "-": [3, 1],
        ".": [1, 1],
        "-.": [3, 1, 1, 1],
        "-..": [3, 1, 1, 1, 1, 1],
        ". ": [1, 3],
        "- ": [4, 3],
        "--": [8, 3],
        "- .": [4, 3, 1, 3],
        "--.": [8, 3, 1, 3],
        "--..": [8, 3, 1, 3, 1, 3]
    },
    addDashes = function (o, value, params) {
        value = dasharray[Str(value).toLowerCase()];
        if (value) {
            var width = o.attrs["stroke-width"] || "1",
                butt = {round: width, square: width, butt: 0}[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0,
                dashes = [],
                i = value.length;
            while (i--) {
                dashes[i] = value[i] * width + ((i % 2) ? 1 : -1) * butt;
            }
            $(o.node, {"stroke-dasharray": dashes.join(",")});
        }
    },
    setFillAndStroke = function (o, params) {
        var node = o.node,
            attrs = o.attrs,
            vis = node.style.visibility;
        node.style.visibility = "hidden";
        for (var att in params) {
            if (params[has](att)) {
                if (!R._availableAttrs[has](att)) {
                    continue;
                }
                var value = params[att];
                attrs[att] = value;
                switch (att) {
                    case "blur":
                        o.blur(value);
                        break;
                    case "title":
                        var title = node.getElementsByTagName("title");

                        // Use the existing <title>.
                        if (title.length && (title = title[0])) {
                          title.firstChild.nodeValue = value;
                        } else {
                          title = $("title");
                          var val = R._g.doc.createTextNode(value);
                          title.appendChild(val);
                          node.appendChild(title);
                        }
                        break;
                    case "href":
                    case "target":
                        var pn = node.parentNode;
                        if (pn.tagName.toLowerCase() != "a") {
                            var hl = $("a");
                            pn.insertBefore(hl, node);
                            hl.appendChild(node);
                            pn = hl;
                        }
                        if (att == "target") {
                            pn.setAttributeNS(xlink, "show", value == "blank" ? "new" : value);
                        } else {
                            pn.setAttributeNS(xlink, att, value);
                        }
                        break;
                    case "cursor":
                        node.style.cursor = value;
                        break;
                    case "transform":
                        o.transform(value);
                        break;
                    case "arrow-start":
                        addArrow(o, value);
                        break;
                    case "arrow-end":
                        addArrow(o, value, 1);
                        break;
                    case "clip-rect":
                        var rect = Str(value).split(separator);
                        if (rect.length == 4) {
                            o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                            var el = $("clipPath"),
                                rc = $("rect");
                            el.id = R.createUUID();
                            $(rc, {
                                x: rect[0],
                                y: rect[1],
                                width: rect[2],
                                height: rect[3]
                            });
                            el.appendChild(rc);
                            o.paper.defs.appendChild(el);
                            $(node, {"clip-path": "url(#" + el.id + ")"});
                            o.clip = rc;
                        }
                        if (!value) {
                            var path = node.getAttribute("clip-path");
                            if (path) {
                                var clip = R._g.doc.getElementById(path.replace(/(^url\(#|\)$)/g, E));
                                clip && clip.parentNode.removeChild(clip);
                                $(node, {"clip-path": E});
                                delete o.clip;
                            }
                        }
                    break;
                    case "path":
                        if (o.type == "path") {
                            $(node, {d: value ? attrs.path = R._pathToAbsolute(value) : "M0,0"});
                            o._.dirty = 1;
                            if (o._.arrows) {
                                "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                            }
                        }
                        break;
                    case "width":
                        node.setAttribute(att, value);
                        o._.dirty = 1;
                        if (attrs.fx) {
                            att = "x";
                            value = attrs.x;
                        } else {
                            break;
                        }
                    case "x":
                        if (attrs.fx) {
                            value = -attrs.x - (attrs.width || 0);
                        }
                    case "rx":
                        if (att == "rx" && o.type == "rect") {
                            break;
                        }
                    case "cx":
                        node.setAttribute(att, value);
                        o.pattern && updatePosition(o);
                        o._.dirty = 1;
                        break;
                    case "height":
                        node.setAttribute(att, value);
                        o._.dirty = 1;
                        if (attrs.fy) {
                            att = "y";
                            value = attrs.y;
                        } else {
                            break;
                        }
                    case "y":
                        if (attrs.fy) {
                            value = -attrs.y - (attrs.height || 0);
                        }
                    case "ry":
                        if (att == "ry" && o.type == "rect") {
                            break;
                        }
                    case "cy":
                        node.setAttribute(att, value);
                        o.pattern && updatePosition(o);
                        o._.dirty = 1;
                        break;
                    case "r":
                        if (o.type == "rect") {
                            $(node, {rx: value, ry: value});
                        } else {
                            node.setAttribute(att, value);
                        }
                        o._.dirty = 1;
                        break;
                    case "src":
                        if (o.type == "image") {
                            node.setAttributeNS(xlink, "href", value);
                        }
                        break;
                    case "stroke-width":
                        if (o._.sx != 1 || o._.sy != 1) {
                            value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;
                        }
                        if (o.paper._vbSize) {
                            value *= o.paper._vbSize;
                        }
                        node.setAttribute(att, value);
                        if (attrs["stroke-dasharray"]) {
                            addDashes(o, attrs["stroke-dasharray"], params);
                        }
                        if (o._.arrows) {
                            "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                            "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                        }
                        break;
                    case "stroke-dasharray":
                        addDashes(o, value, params);
                        break;
                    case "fill":
                        var isURL = Str(value).match(R._ISURL);
                        if (isURL) {
                            el = $("pattern");
                            var ig = $("image");
                            el.id = R.createUUID();
                            $(el, {x: 0, y: 0, patternUnits: "userSpaceOnUse", height: 1, width: 1});
                            $(ig, {x: 0, y: 0, "xlink:href": isURL[1]});
                            el.appendChild(ig);

                            (function (el) {
                                R._preload(isURL[1], function () {
                                    var w = this.offsetWidth,
                                        h = this.offsetHeight;
                                    $(el, {width: w, height: h});
                                    $(ig, {width: w, height: h});
                                    o.paper.safari();
                                });
                            })(el);
                            o.paper.defs.appendChild(el);
                            $(node, {fill: "url(#" + el.id + ")"});
                            o.pattern = el;
                            o.pattern && updatePosition(o);
                            break;
                        }
                        var clr = R.getRGB(value);
                        if (!clr.error) {
                            delete params.gradient;
                            delete attrs.gradient;
                            !R.is(attrs.opacity, "undefined") &&
                                R.is(params.opacity, "undefined") &&
                                $(node, {opacity: attrs.opacity});
                            !R.is(attrs["fill-opacity"], "undefined") &&
                                R.is(params["fill-opacity"], "undefined") &&
                                $(node, {"fill-opacity": attrs["fill-opacity"]});
                        } else if ((o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value)) {
                            if ("opacity" in attrs || "fill-opacity" in attrs) {
                                var gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                                if (gradient) {
                                    var stops = gradient.getElementsByTagName("stop");
                                    $(stops[stops.length - 1], {"stop-opacity": ("opacity" in attrs ? attrs.opacity : 1) * ("fill-opacity" in attrs ? attrs["fill-opacity"] : 1)});
                                }
                            }
                            attrs.gradient = value;
                            attrs.fill = "none";
                            break;
                        }
                        clr[has]("opacity") && $(node, {"fill-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
                    case "stroke":
                        clr = R.getRGB(value);
                        node.setAttribute(att, clr.hex);
                        att == "stroke" && clr[has]("opacity") && $(node, {"stroke-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
                        if (att == "stroke" && o._.arrows) {
                            "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                            "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                        }
                        break;
                    case "gradient":
                        (o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value);
                        break;
                    case "opacity":
                        if (attrs.gradient && !attrs[has]("stroke-opacity")) {
                            $(node, {"stroke-opacity": value > 1 ? value / 100 : value});
                        }
                        // fall
                    case "fill-opacity":
                        if (attrs.gradient) {
                            gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                            if (gradient) {
                                stops = gradient.getElementsByTagName("stop");
                                $(stops[stops.length - 1], {"stop-opacity": value});
                            }
                            break;
                        }
                    default:
                        att == "font-size" && (value = toInt(value, 10) + "px");
                        var cssrule = att.replace(/(\-.)/g, function (w) {
                            return w.substring(1).toUpperCase();
                        });
                        node.style[cssrule] = value;
                        o._.dirty = 1;
                        node.setAttribute(att, value);
                        break;
                }
            }
        }

        tuneText(o, params);
        node.style.visibility = vis;
    },
    leading = 1.2,
    tuneText = function (el, params) {
        if (el.type != "text" || !(params[has]("text") || params[has]("font") || params[has]("font-size") || params[has]("x") || params[has]("y"))) {
            return;
        }
        var a = el.attrs,
            node = el.node,
            fontSize = node.firstChild ? toInt(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue("font-size"), 10) : 10;

        if (params[has]("text")) {
            a.text = params.text;
            while (node.firstChild) {
                node.removeChild(node.firstChild);
            }
            var texts = Str(params.text).split("\n"),
                tspans = [],
                tspan;
            for (var i = 0, ii = texts.length; i < ii; i++) {
                tspan = $("tspan");
                i && $(tspan, {dy: fontSize * leading, x: a.x});
                tspan.appendChild(R._g.doc.createTextNode(texts[i]));
                node.appendChild(tspan);
                tspans[i] = tspan;
            }
        } else {
            tspans = node.getElementsByTagName("tspan");
            for (i = 0, ii = tspans.length; i < ii; i++) if (i) {
                $(tspans[i], {dy: fontSize * leading, x: a.x});
            } else {
                $(tspans[0], {dy: 0});
            }
        }
        $(node, {x: a.x, y: a.y});
        el._.dirty = 1;
        var bb = el._getBBox(),
            dif = a.y - (bb.y + bb.height / 2);
        dif && R.is(dif, "finite") && $(tspans[0], {dy: dif});
    },
    Element = function (node, svg) {
        var X = 0,
            Y = 0;
        /*\
         * Element.node
         [ property (object) ]
         **
         * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
         **
         * Note: Dont mess with it.
         > Usage
         | // draw a circle at coordinate 10,10 with radius of 10
         | var c = paper.circle(10, 10, 10);
         | c.node.onclick = function () {
         |     c.attr("fill", "red");
         | };
        \*/
        this[0] = this.node = node;
        /*\
         * Element.raphael
         [ property (object) ]
         **
         * Internal reference to @Raphael object. In case it is not available.
         > Usage
         | Raphael.el.red = function () {
         |     var hsb = this.paper.raphael.rgb2hsb(this.attr("fill"));
         |     hsb.h = 1;
         |     this.attr({fill: this.paper.raphael.hsb2rgb(hsb).hex});
         | }
        \*/
        node.raphael = true;
        /*\
         * Element.id
         [ property (number) ]
         **
         * Unique id of the element. Especially usesful when you want to listen to events of the element, 
         * because all events are fired in format `<module>.<action>.<id>`. Also useful for @Paper.getById method.
        \*/
        this.id = R._oid++;
        node.raphaelid = this.id;
        this.matrix = R.matrix();
        this.realPath = null;
        /*\
         * Element.paper
         [ property (object) ]
         **
         * Internal reference to paper where object drawn. Mainly for use in plugins and element extensions.
         > Usage
         | Raphael.el.cross = function () {
         |     this.attr({fill: "red"});
         |     this.paper.path("M10,10L50,50M50,10L10,50")
         |         .attr({stroke: "red"});
         | }
        \*/
        this.paper = svg;
        this.attrs = this.attrs || {};
        this._ = {
            transform: [],
            sx: 1,
            sy: 1,
            deg: 0,
            dx: 0,
            dy: 0,
            dirty: 1
        };
        !svg.bottom && (svg.bottom = this);
        /*\
         * Element.prev
         [ property (object) ]
         **
         * Reference to the previous element in the hierarchy.
        \*/
        this.prev = svg.top;
        svg.top && (svg.top.next = this);
        svg.top = this;
        /*\
         * Element.next
         [ property (object) ]
         **
         * Reference to the next element in the hierarchy.
        \*/
        this.next = null;
    },
    elproto = R.el;

    Element.prototype = elproto;
    elproto.constructor = Element;

    R._engine.path = function (pathString, SVG) {
        var el = $("path");
        SVG.canvas && SVG.canvas.appendChild(el);
        var p = new Element(el, SVG);
        p.type = "path";
        setFillAndStroke(p, {
            fill: "none",
            stroke: "#000",
            path: pathString
        });
        return p;
    };
    /*\
     * Element.rotate
     [ method ]
     **
     * Deprecated! Use @Element.transform instead.
     * Adds rotation by given angle around given point to the list of
     * transformations of the element.
     > Parameters
     - deg (number) angle in degrees
     - cx (number) #optional x coordinate of the centre of rotation
     - cy (number) #optional y coordinate of the centre of rotation
     * If cx & cy arent specified centre of the shape is used as a point of rotation.
     = (object) @Element
    \*/
    elproto.rotate = function (deg, cx, cy) {
        if (this.removed) {
            return this;
        }
        deg = Str(deg).split(separator);
        if (deg.length - 1) {
            cx = toFloat(deg[1]);
            cy = toFloat(deg[2]);
        }
        deg = toFloat(deg[0]);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = this.getBBox(1);
            cx = bbox.x + bbox.width / 2;
            cy = bbox.y + bbox.height / 2;
        }
        this.transform(this._.transform.concat([["r", deg, cx, cy]]));
        return this;
    };
    /*\
     * Element.scale
     [ method ]
     **
     * Deprecated! Use @Element.transform instead.
     * Adds scale by given amount relative to given point to the list of
     * transformations of the element.
     > Parameters
     - sx (number) horisontal scale amount
     - sy (number) vertical scale amount
     - cx (number) #optional x coordinate of the centre of scale
     - cy (number) #optional y coordinate of the centre of scale
     * If cx & cy arent specified centre of the shape is used instead.
     = (object) @Element
    \*/
    elproto.scale = function (sx, sy, cx, cy) {
        if (this.removed) {
            return this;
        }
        sx = Str(sx).split(separator);
        if (sx.length - 1) {
            sy = toFloat(sx[1]);
            cx = toFloat(sx[2]);
            cy = toFloat(sx[3]);
        }
        sx = toFloat(sx[0]);
        (sy == null) && (sy = sx);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = this.getBBox(1);
        }
        cx = cx == null ? bbox.x + bbox.width / 2 : cx;
        cy = cy == null ? bbox.y + bbox.height / 2 : cy;
        this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
        return this;
    };
    /*\
     * Element.translate
     [ method ]
     **
     * Deprecated! Use @Element.transform instead.
     * Adds translation by given amount to the list of transformations of the element.
     > Parameters
     - dx (number) horisontal shift
     - dy (number) vertical shift
     = (object) @Element
    \*/
    elproto.translate = function (dx, dy) {
        if (this.removed) {
            return this;
        }
        dx = Str(dx).split(separator);
        if (dx.length - 1) {
            dy = toFloat(dx[1]);
        }
        dx = toFloat(dx[0]) || 0;
        dy = +dy || 0;
        this.transform(this._.transform.concat([["t", dx, dy]]));
        return this;
    };
    /*\
     * Element.transform
     [ method ]
     **
     * Adds transformation to the element which is separate to other attributes,
     * i.e. translation doesnt change `x` or `y` of the rectange. The format
     * of transformation string is similar to the path string syntax:
     | "t100,100r30,100,100s2,2,100,100r45s1.5"
     * Each letter is a command. There are four commands: `t` is for translate, `r` is for rotate, `s` is for
     * scale and `m` is for matrix.
     *
     * There are also alternative absolute translation, rotation and scale: `T`, `R` and `S`. They will not take previous transformation into account. For example, `...T100,0` will always move element 100 px horisontally, while `...t100,0` could move it vertically if there is `r90` before. Just compare results of `r90t100,0` and `r90T100,0`.
     *
     * So, the example line above could be read like translate by 100, 100; rotate 30 around 100, 100; scale twice around 100, 100;
     * rotate 45 around centre; scale 1.5 times relative to centre. As you can see rotate and scale commands have origin
     * coordinates as optional parameters, the default is the centre point of the element.
     * Matrix accepts six parameters.
     > Usage
     | var el = paper.rect(10, 20, 300, 200);
     | // translate 100, 100, rotate 45, translate -100, 0
     | el.transform("t100,100r45t-100,0");
     | // if you want you can append or prepend transformations
     | el.transform("...t50,50");
     | el.transform("s2...");
     | // or even wrap
     | el.transform("t50,50...t-50-50");
     | // to reset transformation call method with empty string
     | el.transform("");
     | // to get current value call it without parameters
     | console.log(el.transform());
     > Parameters
     - tstr (string) #optional transformation string
     * If tstr isnt specified
     = (string) current transformation string
     * else
     = (object) @Element
    \*/
    elproto.transform = function (tstr) {
        var _ = this._;
        if (tstr == null) {
            return _.transform;
        }
        R._extractTransform(this, tstr);

        this.clip && $(this.clip, {transform: this.matrix.invert()});
        this.pattern && updatePosition(this);
        this.node && $(this.node, {transform: this.matrix});
    
        if (_.sx != 1 || _.sy != 1) {
            var sw = this.attrs[has]("stroke-width") ? this.attrs["stroke-width"] : 1;
            this.attr({"stroke-width": sw});
        }

        return this;
    };
    /*\
     * Element.hide
     [ method ]
     **
     * Makes element invisible. See @Element.show.
     = (object) @Element
    \*/
    elproto.hide = function () {
        !this.removed && this.paper.safari(this.node.style.display = "none");
        return this;
    };
    /*\
     * Element.show
     [ method ]
     **
     * Makes element visible. See @Element.hide.
     = (object) @Element
    \*/
    elproto.show = function () {
        !this.removed && this.paper.safari(this.node.style.display = "");
        return this;
    };
    /*\
     * Element.remove
     [ method ]
     **
     * Removes element from the paper.
    \*/
    elproto.remove = function () {
        if (this.removed || !this.node.parentNode) {
            return;
        }
        var paper = this.paper;
        paper.__set__ && paper.__set__.exclude(this);
        eve.unbind("raphael.*.*." + this.id);
        if (this.gradient) {
            paper.defs.removeChild(this.gradient);
        }
        R._tear(this, paper);
        if (this.node.parentNode.tagName.toLowerCase() == "a") {
            this.node.parentNode.parentNode.removeChild(this.node.parentNode);
        } else {
            this.node.parentNode.removeChild(this.node);
        }
        for (var i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
        this.removed = true;
    };
    elproto._getBBox = function () {
        if (this.node.style.display == "none") {
            this.show();
            var hide = true;
        }
        var bbox = {};
        try {
            bbox = this.node.getBBox();
        } catch(e) {
            // Firefox 3.0.x plays badly here
        } finally {
            bbox = bbox || {};
        }
        hide && this.hide();
        return bbox;
    };
    /*\
     * Element.attr
     [ method ]
     **
     * Sets the attributes of the element.
     > Parameters
     - attrName (string) attributes name
     - value (string) value
     * or
     - params (object) object of name/value pairs
     * or
     - attrName (string) attributes name
     * or
     - attrNames (array) in this case method returns array of current values for given attribute names
     = (object) @Element if attrsName & value or params are passed in.
     = (...) value of the attribute if only attrsName is passed in.
     = (array) array of values of the attribute if attrsNames is passed in.
     = (object) object of attributes if nothing is passed in.
     > Possible parameters
     # <p>Please refer to the <a href="http://www.w3.org/TR/SVG/" title="The W3C Recommendation for the SVG language describes these properties in detail.">SVG specification</a> for an explanation of these parameters.</p>
     o arrow-end (string) arrowhead on the end of the path. The format for string is `<type>[-<width>[-<length>]]`. Possible types: `classic`, `block`, `open`, `oval`, `diamond`, `none`, width: `wide`, `narrow`, `medium`, length: `long`, `short`, `midium`.
     o clip-rect (string) comma or space separated values: x, y, width and height
     o cursor (string) CSS type of the cursor
     o cx (number) the x-axis coordinate of the center of the circle, or ellipse
     o cy (number) the y-axis coordinate of the center of the circle, or ellipse
     o fill (string) colour, gradient or image
     o fill-opacity (number)
     o font (string)
     o font-family (string)
     o font-size (number) font size in pixels
     o font-weight (string)
     o height (number)
     o href (string) URL, if specified element behaves as hyperlink
     o opacity (number)
     o path (string) SVG path string format
     o r (number) radius of the circle, ellipse or rounded corner on the rect
     o rx (number) horisontal radius of the ellipse
     o ry (number) vertical radius of the ellipse
     o src (string) image URL, only works for @Element.image element
     o stroke (string) stroke colour
     o stroke-dasharray (string) [, `-`, `.`, `-.`, `-..`, `. `, `- `, `--`, `- .`, `--.`, `--..`]
     o stroke-linecap (string) [`butt`, `square`, `round`]
     o stroke-linejoin (string) [`bevel`, `round`, `miter`]
     o stroke-miterlimit (number)
     o stroke-opacity (number)
     o stroke-width (number) stroke width in pixels, default is '1'
     o target (string) used with href
     o text (string) contents of the text element. Use `\n` for multiline text
     o text-anchor (string) [`start`, `middle`, `end`], default is `middle`
     o title (string) will create tooltip with a given text
     o transform (string) see @Element.transform
     o width (number)
     o x (number)
     o y (number)
     > Gradients
     * Linear gradient format: `angle-colour[-colour[:offset]]*-colour`, example: `90-#fff-#000`  90
     * gradient from white to black or `0-#fff-#f00:20-#000`  0 gradient from white via red (at 20%) to black.
     *
     * radial gradient: `r[(fx, fy)]colour[-colour[:offset]]*-colour`, example: `r#fff-#000` 
     * gradient from white to black or `r(0.25, 0.75)#fff-#000`  gradient from white to black with focus point
     * at 0.25, 0.75. Focus point coordinates are in 0..1 range. Radial gradients can only be applied to circles and ellipses.
     > Path String
     # <p>Please refer to <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a paths data attributes format are described in the SVG specification.">SVG documentation regarding path string</a>. Raphal fully supports it.</p>
     > Colour Parsing
     # <ul>
     #     <li>Colour name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>
     #     <li>#  shortened HTML colour: (<code>#000</code>, <code>#fc0</code>, etc)</li>
     #     <li>#  full length HTML colour: (<code>#000000</code>, <code>#bd2300</code>)</li>
     #     <li>rgb(, , )  red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>
     #     <li>rgb(%, %, %)  same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>
     #     <li>rgba(, , , )  red, green and blue channels values: (<code>rgba(200,&nbsp;100,&nbsp;0, .5)</code>)</li>
     #     <li>rgba(%, %, %, %)  same as above, but in %: (<code>rgba(100%,&nbsp;175%,&nbsp;0%, 50%)</code>)</li>
     #     <li>hsb(, , )  hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>
     #     <li>hsb(%, %, %)  same as above, but in %</li>
     #     <li>hsba(, , , )  same as above, but with opacity</li>
     #     <li>hsl(, , )  almost the same as hsb, see <a href="http://en.wikipedia.org/wiki/HSL_and_HSV" title="HSL and HSV - Wikipedia, the free encyclopedia">Wikipedia page</a></li>
     #     <li>hsl(%, %, %)  same as above, but in %</li>
     #     <li>hsla(, , , )  same as above, but with opacity</li>
     #     <li>Optionally for hsb and hsl you could specify hue as a degree: <code>hsl(240deg,&nbsp;1,&nbsp;.5)</code> or, if you want to go fancy, <code>hsl(240,&nbsp;1,&nbsp;.5)</code></li>
     # </ul>
    \*/
    elproto.attr = function (name, value) {
        if (this.removed) {
            return this;
        }
        if (name == null) {
            var res = {};
            for (var a in this.attrs) if (this.attrs[has](a)) {
                res[a] = this.attrs[a];
            }
            res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
            res.transform = this._.transform;
            return res;
        }
        if (value == null && R.is(name, "string")) {
            if (name == "fill" && this.attrs.fill == "none" && this.attrs.gradient) {
                return this.attrs.gradient;
            }
            if (name == "transform") {
                return this._.transform;
            }
            var names = name.split(separator),
                out = {};
            for (var i = 0, ii = names.length; i < ii; i++) {
                name = names[i];
                if (name in this.attrs) {
                    out[name] = this.attrs[name];
                } else if (R.is(this.paper.customAttributes[name], "function")) {
                    out[name] = this.paper.customAttributes[name].def;
                } else {
                    out[name] = R._availableAttrs[name];
                }
            }
            return ii - 1 ? out : out[names[0]];
        }
        if (value == null && R.is(name, "array")) {
            out = {};
            for (i = 0, ii = name.length; i < ii; i++) {
                out[name[i]] = this.attr(name[i]);
            }
            return out;
        }
        if (value != null) {
            var params = {};
            params[name] = value;
        } else if (name != null && R.is(name, "object")) {
            params = name;
        }
        for (var key in params) {
            eve("raphael.attr." + key + "." + this.id, this, params[key]);
        }
        for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
            var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
            this.attrs[key] = params[key];
            for (var subkey in par) if (par[has](subkey)) {
                params[subkey] = par[subkey];
            }
        }
        setFillAndStroke(this, params);
        return this;
    };
    /*\
     * Element.toFront
     [ method ]
     **
     * Moves the element so it is the closest to the viewers eyes, on top of other elements.
     = (object) @Element
    \*/
    elproto.toFront = function () {
        if (this.removed) {
            return this;
        }
        if (this.node.parentNode.tagName.toLowerCase() == "a") {
            this.node.parentNode.parentNode.appendChild(this.node.parentNode);
        } else {
            this.node.parentNode.appendChild(this.node);
        }
        var svg = this.paper;
        svg.top != this && R._tofront(this, svg);
        return this;
    };
    /*\
     * Element.toBack
     [ method ]
     **
     * Moves the element so it is the furthest from the viewers eyes, behind other elements.
     = (object) @Element
    \*/
    elproto.toBack = function () {
        if (this.removed) {
            return this;
        }
        var parent = this.node.parentNode;
        if (parent.tagName.toLowerCase() == "a") {
            parent.parentNode.insertBefore(this.node.parentNode, this.node.parentNode.parentNode.firstChild); 
        } else if (parent.firstChild != this.node) {
            parent.insertBefore(this.node, this.node.parentNode.firstChild);
        }
        R._toback(this, this.paper);
        var svg = this.paper;
        return this;
    };
    /*\
     * Element.insertAfter
     [ method ]
     **
     * Inserts current object after the given one.
     = (object) @Element
    \*/
    elproto.insertAfter = function (element) {
        if (this.removed) {
            return this;
        }
        var node = element.node || element[element.length - 1].node;
        if (node.nextSibling) {
            node.parentNode.insertBefore(this.node, node.nextSibling);
        } else {
            node.parentNode.appendChild(this.node);
        }
        R._insertafter(this, element, this.paper);
        return this;
    };
    /*\
     * Element.insertBefore
     [ method ]
     **
     * Inserts current object before the given one.
     = (object) @Element
    \*/
    elproto.insertBefore = function (element) {
        if (this.removed) {
            return this;
        }
        var node = element.node || element[0].node;
        node.parentNode.insertBefore(this.node, node);
        R._insertbefore(this, element, this.paper);
        return this;
    };
    elproto.blur = function (size) {
        // Experimental. No Safari support. Use it on your own risk.
        var t = this;
        if (+size !== 0) {
            var fltr = $("filter"),
                blur = $("feGaussianBlur");
            t.attrs.blur = size;
            fltr.id = R.createUUID();
            $(blur, {stdDeviation: +size || 1.5});
            fltr.appendChild(blur);
            t.paper.defs.appendChild(fltr);
            t._blur = fltr;
            $(t.node, {filter: "url(#" + fltr.id + ")"});
        } else {
            if (t._blur) {
                t._blur.parentNode.removeChild(t._blur);
                delete t._blur;
                delete t.attrs.blur;
            }
            t.node.removeAttribute("filter");
        }
        return t;
    };
    R._engine.circle = function (svg, x, y, r) {
        var el = $("circle");
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {cx: x, cy: y, r: r, fill: "none", stroke: "#000"};
        res.type = "circle";
        $(el, res.attrs);
        return res;
    };
    R._engine.rect = function (svg, x, y, w, h, r) {
        var el = $("rect");
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {x: x, y: y, width: w, height: h, r: r || 0, rx: r || 0, ry: r || 0, fill: "none", stroke: "#000"};
        res.type = "rect";
        $(el, res.attrs);
        return res;
    };
    R._engine.ellipse = function (svg, x, y, rx, ry) {
        var el = $("ellipse");
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {cx: x, cy: y, rx: rx, ry: ry, fill: "none", stroke: "#000"};
        res.type = "ellipse";
        $(el, res.attrs);
        return res;
    };
    R._engine.image = function (svg, src, x, y, w, h) {
        var el = $("image");
        $(el, {x: x, y: y, width: w, height: h, preserveAspectRatio: "none"});
        el.setAttributeNS(xlink, "href", src);
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {x: x, y: y, width: w, height: h, src: src};
        res.type = "image";
        return res;
    };
    R._engine.text = function (svg, x, y, text) {
        var el = $("text");
        svg.canvas && svg.canvas.appendChild(el);
        var res = new Element(el, svg);
        res.attrs = {
            x: x,
            y: y,
            "text-anchor": "middle",
            text: text,
            font: R._availableAttrs.font,
            stroke: "none",
            fill: "#000"
        };
        res.type = "text";
        setFillAndStroke(res, res.attrs);
        return res;
    };
    R._engine.setSize = function (width, height) {
        this.width = width || this.width;
        this.height = height || this.height;
        this.canvas.setAttribute("width", this.width);
        this.canvas.setAttribute("height", this.height);
        if (this._viewBox) {
            this.setViewBox.apply(this, this._viewBox);
        }
        return this;
    };
    R._engine.create = function () {
        var con = R._getContainer.apply(0, arguments),
            container = con && con.container,
            x = con.x,
            y = con.y,
            width = con.width,
            height = con.height;
        if (!container) {
            throw new Error("SVG container not found.");
        }
        var cnvs = $("svg"),
            css = "overflow:hidden;",
            isFloating;
        x = x || 0;
        y = y || 0;
        width = width || 512;
        height = height || 342;
        $(cnvs, {
            height: height,
            version: 1.1,
            width: width,
            xmlns: "http://www.w3.org/2000/svg"
        });
        if (container == 1) {
            cnvs.style.cssText = css + "position:absolute;left:" + x + "px;top:" + y + "px";
            R._g.doc.body.appendChild(cnvs);
            isFloating = 1;
        } else {
            cnvs.style.cssText = css + "position:relative";
            if (container.firstChild) {
                container.insertBefore(cnvs, container.firstChild);
            } else {
                container.appendChild(cnvs);
            }
        }
        container = new R._Paper;
        container.width = width;
        container.height = height;
        container.canvas = cnvs;
        container.clear();
        container._left = container._top = 0;
        isFloating && (container.renderfix = function () {});
        container.renderfix();
        return container;
    };
    R._engine.setViewBox = function (x, y, w, h, fit) {
        eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
        var size = mmax(w / this.width, h / this.height),
            top = this.top,
            aspectRatio = fit ? "xMidYMid meet" : "xMinYMin",
            vb,
            sw;
        if (x == null) {
            if (this._vbSize) {
                size = 1;
            }
            delete this._vbSize;
            vb = "0 0 " + this.width + S + this.height;
        } else {
            this._vbSize = size;
            vb = x + S + y + S + w + S + h;
        }
        $(this.canvas, {
            viewBox: vb,
            preserveAspectRatio: aspectRatio
        });
        while (size && top) {
            sw = "stroke-width" in top.attrs ? top.attrs["stroke-width"] : 1;
            top.attr({"stroke-width": sw});
            top._.dirty = 1;
            top._.dirtyT = 1;
            top = top.prev;
        }
        this._viewBox = [x, y, w, h, !!fit];
        return this;
    };
    /*\
     * Paper.renderfix
     [ method ]
     **
     * Fixes the issue of Firefox and IE9 regarding subpixel rendering. If paper is dependant
     * on other elements after reflow it could shift half pixel which cause for lines to lost their crispness.
     * This method fixes the issue.
     **
       Special thanks to Mariusz Nowak (http://www.medikoo.com/) for this method.
    \*/
    R.prototype.renderfix = function () {
        var cnvs = this.canvas,
            s = cnvs.style,
            pos;
        try {
            pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();
        } catch (e) {
            pos = cnvs.createSVGMatrix();
        }
        var left = -pos.e % 1,
            top = -pos.f % 1;
        if (left || top) {
            if (left) {
                this._left = (this._left + left) % 1;
                s.left = this._left + "px";
            }
            if (top) {
                this._top = (this._top + top) % 1;
                s.top = this._top + "px";
            }
        }
    };
    /*\
     * Paper.clear
     [ method ]
     **
     * Clears the paper, i.e. removes all the elements.
    \*/
    R.prototype.clear = function () {
        R.eve("raphael.clear", this);
        var c = this.canvas;
        while (c.firstChild) {
            c.removeChild(c.firstChild);
        }
        this.bottom = this.top = null;
        (this.desc = $("desc")).appendChild(R._g.doc.createTextNode("Created with Rapha\xebl " + R.version));
        c.appendChild(this.desc);
        c.appendChild(this.defs = $("defs"));
    };
    /*\
     * Paper.remove
     [ method ]
     **
     * Removes the paper from the DOM.
    \*/
    R.prototype.remove = function () {
        eve("raphael.remove", this);
        this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
        for (var i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
    };
    var setproto = R.st;
    for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
        setproto[method] = (function (methodname) {
            return function () {
                var arg = arguments;
                return this.forEach(function (el) {
                    el[methodname].apply(el, arg);
                });
            };
        })(method);
    }
})();

//  \\
//  Raphal - JavaScript Vector Library                                  \\
//  \\
//  VML Module                                                           \\
//  \\
//  Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)    \\
//  Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)              \\
//  Licensed under the MIT (http://raphaeljs.com/license.html) license.  \\
//  \\

(function(){
    if (!R.vml) {
        return;
    }
    var has = "hasOwnProperty",
        Str = String,
        toFloat = parseFloat,
        math = Math,
        round = math.round,
        mmax = math.max,
        mmin = math.min,
        abs = math.abs,
        fillString = "fill",
        separator = /[, ]+/,
        eve = R.eve,
        ms = " progid:DXImageTransform.Microsoft",
        S = " ",
        E = "",
        map = {M: "m", L: "l", C: "c", Z: "x", m: "t", l: "r", c: "v", z: "x"},
        bites = /([clmz]),?([^clmz]*)/gi,
        blurregexp = / progid:\S+Blur\([^\)]+\)/g,
        val = /-?[^,\s-]+/g,
        cssDot = "position:absolute;left:0;top:0;width:1px;height:1px",
        zoom = 21600,
        pathTypes = {path: 1, rect: 1, image: 1},
        ovalTypes = {circle: 1, ellipse: 1},
        path2vml = function (path) {
            var total =  /[ahqstv]/ig,
                command = R._pathToAbsolute;
            Str(path).match(total) && (command = R._path2curve);
            total = /[clmz]/g;
            if (command == R._pathToAbsolute && !Str(path).match(total)) {
                var res = Str(path).replace(bites, function (all, command, args) {
                    var vals = [],
                        isMove = command.toLowerCase() == "m",
                        res = map[command];
                    args.replace(val, function (value) {
                        if (isMove && vals.length == 2) {
                            res += vals + map[command == "m" ? "l" : "L"];
                            vals = [];
                        }
                        vals.push(round(value * zoom));
                    });
                    return res + vals;
                });
                return res;
            }
            var pa = command(path), p, r;
            res = [];
            for (var i = 0, ii = pa.length; i < ii; i++) {
                p = pa[i];
                r = pa[i][0].toLowerCase();
                r == "z" && (r = "x");
                for (var j = 1, jj = p.length; j < jj; j++) {
                    r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
                }
                res.push(r);
            }
            return res.join(S);
        },
        compensation = function (deg, dx, dy) {
            var m = R.matrix();
            m.rotate(-deg, .5, .5);
            return {
                dx: m.x(dx, dy),
                dy: m.y(dx, dy)
            };
        },
        setCoords = function (p, sx, sy, dx, dy, deg) {
            var _ = p._,
                m = p.matrix,
                fillpos = _.fillpos,
                o = p.node,
                s = o.style,
                y = 1,
                flip = "",
                dxdy,
                kx = zoom / sx,
                ky = zoom / sy;
            s.visibility = "hidden";
            if (!sx || !sy) {
                return;
            }
            o.coordsize = abs(kx) + S + abs(ky);
            s.rotation = deg * (sx * sy < 0 ? -1 : 1);
            if (deg) {
                var c = compensation(deg, dx, dy);
                dx = c.dx;
                dy = c.dy;
            }
            sx < 0 && (flip += "x");
            sy < 0 && (flip += " y") && (y = -1);
            s.flip = flip;
            o.coordorigin = (dx * -kx) + S + (dy * -ky);
            if (fillpos || _.fillsize) {
                var fill = o.getElementsByTagName(fillString);
                fill = fill && fill[0];
                o.removeChild(fill);
                if (fillpos) {
                    c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));
                    fill.position = c.dx * y + S + c.dy * y;
                }
                if (_.fillsize) {
                    fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);
                }
                o.appendChild(fill);
            }
            s.visibility = "visible";
        };
    R.toString = function () {
        return  "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl " + this.version;
    };
    var addArrow = function (o, value, isEnd) {
        var values = Str(value).toLowerCase().split("-"),
            se = isEnd ? "end" : "start",
            i = values.length,
            type = "classic",
            w = "medium",
            h = "medium";
        while (i--) {
            switch (values[i]) {
                case "block":
                case "classic":
                case "oval":
                case "diamond":
                case "open":
                case "none":
                    type = values[i];
                    break;
                case "wide":
                case "narrow": h = values[i]; break;
                case "long":
                case "short": w = values[i]; break;
            }
        }
        var stroke = o.node.getElementsByTagName("stroke")[0];
        stroke[se + "arrow"] = type;
        stroke[se + "arrowlength"] = w;
        stroke[se + "arrowwidth"] = h;
    },
    setFillAndStroke = function (o, params) {
        // o.paper.canvas.style.display = "none";
        o.attrs = o.attrs || {};
        var node = o.node,
            a = o.attrs,
            s = node.style,
            xy,
            newpath = pathTypes[o.type] && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r),
            isOval = ovalTypes[o.type] && (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry),
            res = o;


        for (var par in params) if (params[has](par)) {
            a[par] = params[par];
        }
        if (newpath) {
            a.path = R._getPath[o.type](o);
            o._.dirty = 1;
        }
        params.href && (node.href = params.href);
        params.title && (node.title = params.title);
        params.target && (node.target = params.target);
        params.cursor && (s.cursor = params.cursor);
        "blur" in params && o.blur(params.blur);
        if (params.path && o.type == "path" || newpath) {
            node.path = path2vml(~Str(a.path).toLowerCase().indexOf("r") ? R._pathToAbsolute(a.path) : a.path);
            if (o.type == "image") {
                o._.fillpos = [a.x, a.y];
                o._.fillsize = [a.width, a.height];
                setCoords(o, 1, 1, 0, 0, 0);
            }
        }
        "transform" in params && o.transform(params.transform);
        if (isOval) {
            var cx = +a.cx,
                cy = +a.cy,
                rx = +a.rx || +a.r || 0,
                ry = +a.ry || +a.r || 0;
            node.path = R.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x", round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));
            o._.dirty = 1;
        }
        if ("clip-rect" in params) {
            var rect = Str(params["clip-rect"]).split(separator);
            if (rect.length == 4) {
                rect[2] = +rect[2] + (+rect[0]);
                rect[3] = +rect[3] + (+rect[1]);
                var div = node.clipRect || R._g.doc.createElement("div"),
                    dstyle = div.style;
                dstyle.clip = R.format("rect({1}px {2}px {3}px {0}px)", rect);
                if (!node.clipRect) {
                    dstyle.position = "absolute";
                    dstyle.top = 0;
                    dstyle.left = 0;
                    dstyle.width = o.paper.width + "px";
                    dstyle.height = o.paper.height + "px";
                    node.parentNode.insertBefore(div, node);
                    div.appendChild(node);
                    node.clipRect = div;
                }
            }
            if (!params["clip-rect"]) {
                node.clipRect && (node.clipRect.style.clip = "auto");
            }
        }
        if (o.textpath) {
            var textpathStyle = o.textpath.style;
            params.font && (textpathStyle.font = params.font);
            params["font-family"] && (textpathStyle.fontFamily = '"' + params["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g, E) + '"');
            params["font-size"] && (textpathStyle.fontSize = params["font-size"]);
            params["font-weight"] && (textpathStyle.fontWeight = params["font-weight"]);
            params["font-style"] && (textpathStyle.fontStyle = params["font-style"]);
        }
        if ("arrow-start" in params) {
            addArrow(res, params["arrow-start"]);
        }
        if ("arrow-end" in params) {
            addArrow(res, params["arrow-end"], 1);
        }
        if (params.opacity != null || 
            params["stroke-width"] != null ||
            params.fill != null ||
            params.src != null ||
            params.stroke != null ||
            params["stroke-width"] != null ||
            params["stroke-opacity"] != null ||
            params["fill-opacity"] != null ||
            params["stroke-dasharray"] != null ||
            params["stroke-miterlimit"] != null ||
            params["stroke-linejoin"] != null ||
            params["stroke-linecap"] != null) {
            var fill = node.getElementsByTagName(fillString),
                newfill = false;
            fill = fill && fill[0];
            !fill && (newfill = fill = createNode(fillString));
            if (o.type == "image" && params.src) {
                fill.src = params.src;
            }
            params.fill && (fill.on = true);
            if (fill.on == null || params.fill == "none" || params.fill === null) {
                fill.on = false;
            }
            if (fill.on && params.fill) {
                var isURL = Str(params.fill).match(R._ISURL);
                if (isURL) {
                    fill.parentNode == node && node.removeChild(fill);
                    fill.rotate = true;
                    fill.src = isURL[1];
                    fill.type = "tile";
                    var bbox = o.getBBox(1);
                    fill.position = bbox.x + S + bbox.y;
                    o._.fillpos = [bbox.x, bbox.y];

                    R._preload(isURL[1], function () {
                        o._.fillsize = [this.offsetWidth, this.offsetHeight];
                    });
                } else {
                    fill.color = R.getRGB(params.fill).hex;
                    fill.src = E;
                    fill.type = "solid";
                    if (R.getRGB(params.fill).error && (res.type in {circle: 1, ellipse: 1} || Str(params.fill).charAt() != "r") && addGradientFill(res, params.fill, fill)) {
                        a.fill = "none";
                        a.gradient = params.fill;
                        fill.rotate = false;
                    }
                }
            }
            if ("fill-opacity" in params || "opacity" in params) {
                var opacity = ((+a["fill-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);
                opacity = mmin(mmax(opacity, 0), 1);
                fill.opacity = opacity;
                if (fill.src) {
                    fill.color = "none";
                }
            }
            node.appendChild(fill);
            var stroke = (node.getElementsByTagName("stroke") && node.getElementsByTagName("stroke")[0]),
            newstroke = false;
            !stroke && (newstroke = stroke = createNode("stroke"));
            if ((params.stroke && params.stroke != "none") ||
                params["stroke-width"] ||
                params["stroke-opacity"] != null ||
                params["stroke-dasharray"] ||
                params["stroke-miterlimit"] ||
                params["stroke-linejoin"] ||
                params["stroke-linecap"]) {
                stroke.on = true;
            }
            (params.stroke == "none" || params.stroke === null || stroke.on == null || params.stroke == 0 || params["stroke-width"] == 0) && (stroke.on = false);
            var strokeColor = R.getRGB(params.stroke);
            stroke.on && params.stroke && (stroke.color = strokeColor.hex);
            opacity = ((+a["stroke-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);
            var width = (toFloat(params["stroke-width"]) || 1) * .75;
            opacity = mmin(mmax(opacity, 0), 1);
            params["stroke-width"] == null && (width = a["stroke-width"]);
            params["stroke-width"] && (stroke.weight = width);
            width && width < 1 && (opacity *= width) && (stroke.weight = 1);
            stroke.opacity = opacity;
        
            params["stroke-linejoin"] && (stroke.joinstyle = params["stroke-linejoin"] || "miter");
            stroke.miterlimit = params["stroke-miterlimit"] || 8;
            params["stroke-linecap"] && (stroke.endcap = params["stroke-linecap"] == "butt" ? "flat" : params["stroke-linecap"] == "square" ? "square" : "round");
            if ("stroke-dasharray" in params) {
                var dasharray = {
                    "-": "shortdash",
                    ".": "shortdot",
                    "-.": "shortdashdot",
                    "-..": "shortdashdotdot",
                    ". ": "dot",
                    "- ": "dash",
                    "--": "longdash",
                    "- .": "dashdot",
                    "--.": "longdashdot",
                    "--..": "longdashdotdot"
                };
                stroke.dashstyle = dasharray[has](params["stroke-dasharray"]) ? dasharray[params["stroke-dasharray"]] : E;
            }
            newstroke && node.appendChild(stroke);
        }
        if (res.type == "text") {
            res.paper.canvas.style.display = E;
            var span = res.paper.span,
                m = 100,
                fontSize = a.font && a.font.match(/\d+(?:\.\d*)?(?=px)/);
            s = span.style;
            a.font && (s.font = a.font);
            a["font-family"] && (s.fontFamily = a["font-family"]);
            a["font-weight"] && (s.fontWeight = a["font-weight"]);
            a["font-style"] && (s.fontStyle = a["font-style"]);
            fontSize = toFloat(a["font-size"] || fontSize && fontSize[0]) || 10;
            s.fontSize = fontSize * m + "px";
            res.textpath.string && (span.innerHTML = Str(res.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br>"));
            var brect = span.getBoundingClientRect();
            res.W = a.w = (brect.right - brect.left) / m;
            res.H = a.h = (brect.bottom - brect.top) / m;
            // res.paper.canvas.style.display = "none";
            res.X = a.x;
            res.Y = a.y + res.H / 2;

            ("x" in params || "y" in params) && (res.path.v = R.format("m{0},{1}l{2},{1}", round(a.x * zoom), round(a.y * zoom), round(a.x * zoom) + 1));
            var dirtyattrs = ["x", "y", "text", "font", "font-family", "font-weight", "font-style", "font-size"];
            for (var d = 0, dd = dirtyattrs.length; d < dd; d++) if (dirtyattrs[d] in params) {
                res._.dirty = 1;
                break;
            }
        
            // text-anchor emulation
            switch (a["text-anchor"]) {
                case "start":
                    res.textpath.style["v-text-align"] = "left";
                    res.bbx = res.W / 2;
                break;
                case "end":
                    res.textpath.style["v-text-align"] = "right";
                    res.bbx = -res.W / 2;
                break;
                default:
                    res.textpath.style["v-text-align"] = "center";
                    res.bbx = 0;
                break;
            }
            res.textpath.style["v-text-kern"] = true;
        }
        // res.paper.canvas.style.display = E;
    },
    addGradientFill = function (o, gradient, fill) {
        o.attrs = o.attrs || {};
        var attrs = o.attrs,
            pow = Math.pow,
            opacity,
            oindex,
            type = "linear",
            fxfy = ".5 .5";
        o.attrs.gradient = gradient;
        gradient = Str(gradient).replace(R._radial_gradient, function (all, fx, fy) {
            type = "radial";
            if (fx && fy) {
                fx = toFloat(fx);
                fy = toFloat(fy);
                pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);
                fxfy = fx + S + fy;
            }
            return E;
        });
        gradient = gradient.split(/\s*\-\s*/);
        if (type == "linear") {
            var angle = gradient.shift();
            angle = -toFloat(angle);
            if (isNaN(angle)) {
                return null;
            }
        }
        var dots = R._parseDots(gradient);
        if (!dots) {
            return null;
        }
        o = o.shape || o.node;
        if (dots.length) {
            o.removeChild(fill);
            fill.on = true;
            fill.method = "none";
            fill.color = dots[0].color;
            fill.color2 = dots[dots.length - 1].color;
            var clrs = [];
            for (var i = 0, ii = dots.length; i < ii; i++) {
                dots[i].offset && clrs.push(dots[i].offset + S + dots[i].color);
            }
            fill.colors = clrs.length ? clrs.join() : "0% " + fill.color;
            if (type == "radial") {
                fill.type = "gradientTitle";
                fill.focus = "100%";
                fill.focussize = "0 0";
                fill.focusposition = fxfy;
                fill.angle = 0;
            } else {
                // fill.rotate= true;
                fill.type = "gradient";
                fill.angle = (270 - angle) % 360;
            }
            o.appendChild(fill);
        }
        return 1;
    },
    Element = function (node, vml) {
        this[0] = this.node = node;
        node.raphael = true;
        this.id = R._oid++;
        node.raphaelid = this.id;
        this.X = 0;
        this.Y = 0;
        this.attrs = {};
        this.paper = vml;
        this.matrix = R.matrix();
        this._ = {
            transform: [],
            sx: 1,
            sy: 1,
            dx: 0,
            dy: 0,
            deg: 0,
            dirty: 1,
            dirtyT: 1
        };
        !vml.bottom && (vml.bottom = this);
        this.prev = vml.top;
        vml.top && (vml.top.next = this);
        vml.top = this;
        this.next = null;
    };
    var elproto = R.el;

    Element.prototype = elproto;
    elproto.constructor = Element;
    elproto.transform = function (tstr) {
        if (tstr == null) {
            return this._.transform;
        }
        var vbs = this.paper._viewBoxShift,
            vbt = vbs ? "s" + [vbs.scale, vbs.scale] + "-1-1t" + [vbs.dx, vbs.dy] : E,
            oldt;
        if (vbs) {
            oldt = tstr = Str(tstr).replace(/\.{3}|\u2026/g, this._.transform || E);
        }
        R._extractTransform(this, vbt + tstr);
        var matrix = this.matrix.clone(),
            skew = this.skew,
            o = this.node,
            split,
            isGrad = ~Str(this.attrs.fill).indexOf("-"),
            isPatt = !Str(this.attrs.fill).indexOf("url(");
        //matrix.translate(1, 1);
        if (isPatt || isGrad || this.type == "image") {
            skew.matrix = "1 0 0 1";
            skew.offset = "0 0";
            split = matrix.split();
            if ((isGrad && split.noRotation) || !split.isSimple) {
                o.style.filter = matrix.toFilter();
                var bb = this.getBBox(),
                    bbt = this.getBBox(1),
                    dx = bb.x - bbt.x,
                    dy = bb.y - bbt.y;
                o.coordorigin = (dx * -zoom) + S + (dy * -zoom);
                setCoords(this, 1, 1, dx, dy, 0);
            } else {
                o.style.filter = E;
                setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);
            }
        } else {
            o.style.filter = E;
            skew.matrix = Str(matrix);
            skew.offset = matrix.offset();
        }
        oldt && (this._.transform = oldt);
        return this;
    };
    elproto.rotate = function (deg, cx, cy) {
        if (this.removed) {
            return this;
        }
        if (deg == null) {
            return;
        }
        deg = Str(deg).split(separator);
        if (deg.length - 1) {
            cx = toFloat(deg[1]);
            cy = toFloat(deg[2]);
        }
        deg = toFloat(deg[0]);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = this.getBBox(1);
            cx = bbox.x + bbox.width / 2;
            cy = bbox.y + bbox.height / 2;
        }
        this._.dirtyT = 1;
        this.transform(this._.transform.concat([["r", deg, cx, cy]]));
        return this;
    };
    elproto.translate = function (dx, dy) {
        if (this.removed) {
            return this;
        }
        dx = Str(dx).split(separator);
        if (dx.length - 1) {
            dy = toFloat(dx[1]);
        }
        dx = toFloat(dx[0]) || 0;
        dy = +dy || 0;
        if (this._.bbox) {
            this._.bbox.x += dx;
            this._.bbox.y += dy;
        }
        this.transform(this._.transform.concat([["t", dx, dy]]));
        return this;
    };
    elproto.scale = function (sx, sy, cx, cy) {
        if (this.removed) {
            return this;
        }
        sx = Str(sx).split(separator);
        if (sx.length - 1) {
            sy = toFloat(sx[1]);
            cx = toFloat(sx[2]);
            cy = toFloat(sx[3]);
            isNaN(cx) && (cx = null);
            isNaN(cy) && (cy = null);
        }
        sx = toFloat(sx[0]);
        (sy == null) && (sy = sx);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = this.getBBox(1);
        }
        cx = cx == null ? bbox.x + bbox.width / 2 : cx;
        cy = cy == null ? bbox.y + bbox.height / 2 : cy;
    
        this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
        this._.dirtyT = 1;
        return this;
    };
    elproto.hide = function () {
        !this.removed && (this.node.style.display = "none");
        return this;
    };
    elproto.show = function () {
        !this.removed && (this.node.style.display = E);
        return this;
    };
    elproto._getBBox = function () {
        if (this.removed) {
            return {};
        }
        return {
            x: this.X + (this.bbx || 0) - this.W / 2,
            y: this.Y - this.H,
            width: this.W,
            height: this.H
        };
    };
    elproto.remove = function () {
        if (this.removed || !this.node.parentNode) {
            return;
        }
        this.paper.__set__ && this.paper.__set__.exclude(this);
        R.eve.unbind("raphael.*.*." + this.id);
        R._tear(this, this.paper);
        this.node.parentNode.removeChild(this.node);
        this.shape && this.shape.parentNode.removeChild(this.shape);
        for (var i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
        this.removed = true;
    };
    elproto.attr = function (name, value) {
        if (this.removed) {
            return this;
        }
        if (name == null) {
            var res = {};
            for (var a in this.attrs) if (this.attrs[has](a)) {
                res[a] = this.attrs[a];
            }
            res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
            res.transform = this._.transform;
            return res;
        }
        if (value == null && R.is(name, "string")) {
            if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
                return this.attrs.gradient;
            }
            var names = name.split(separator),
                out = {};
            for (var i = 0, ii = names.length; i < ii; i++) {
                name = names[i];
                if (name in this.attrs) {
                    out[name] = this.attrs[name];
                } else if (R.is(this.paper.customAttributes[name], "function")) {
                    out[name] = this.paper.customAttributes[name].def;
                } else {
                    out[name] = R._availableAttrs[name];
                }
            }
            return ii - 1 ? out : out[names[0]];
        }
        if (this.attrs && value == null && R.is(name, "array")) {
            out = {};
            for (i = 0, ii = name.length; i < ii; i++) {
                out[name[i]] = this.attr(name[i]);
            }
            return out;
        }
        var params;
        if (value != null) {
            params = {};
            params[name] = value;
        }
        value == null && R.is(name, "object") && (params = name);
        for (var key in params) {
            eve("raphael.attr." + key + "." + this.id, this, params[key]);
        }
        if (params) {
            for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
                var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
                this.attrs[key] = params[key];
                for (var subkey in par) if (par[has](subkey)) {
                    params[subkey] = par[subkey];
                }
            }
            // this.paper.canvas.style.display = "none";
            if (params.text && this.type == "text") {
                this.textpath.string = params.text;
            }
            setFillAndStroke(this, params);
            // this.paper.canvas.style.display = E;
        }
        return this;
    };
    elproto.toFront = function () {
        !this.removed && this.node.parentNode.appendChild(this.node);
        this.paper && this.paper.top != this && R._tofront(this, this.paper);
        return this;
    };
    elproto.toBack = function () {
        if (this.removed) {
            return this;
        }
        if (this.node.parentNode.firstChild != this.node) {
            this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);
            R._toback(this, this.paper);
        }
        return this;
    };
    elproto.insertAfter = function (element) {
        if (this.removed) {
            return this;
        }
        if (element.constructor == R.st.constructor) {
            element = element[element.length - 1];
        }
        if (element.node.nextSibling) {
            element.node.parentNode.insertBefore(this.node, element.node.nextSibling);
        } else {
            element.node.parentNode.appendChild(this.node);
        }
        R._insertafter(this, element, this.paper);
        return this;
    };
    elproto.insertBefore = function (element) {
        if (this.removed) {
            return this;
        }
        if (element.constructor == R.st.constructor) {
            element = element[0];
        }
        element.node.parentNode.insertBefore(this.node, element.node);
        R._insertbefore(this, element, this.paper);
        return this;
    };
    elproto.blur = function (size) {
        var s = this.node.runtimeStyle,
            f = s.filter;
        f = f.replace(blurregexp, E);
        if (+size !== 0) {
            this.attrs.blur = size;
            s.filter = f + S + ms + ".Blur(pixelradius=" + (+size || 1.5) + ")";
            s.margin = R.format("-{0}px 0 0 -{0}px", round(+size || 1.5));
        } else {
            s.filter = f;
            s.margin = 0;
            delete this.attrs.blur;
        }
        return this;
    };

    R._engine.path = function (pathString, vml) {
        var el = createNode("shape");
        el.style.cssText = cssDot;
        el.coordsize = zoom + S + zoom;
        el.coordorigin = vml.coordorigin;
        var p = new Element(el, vml),
            attr = {fill: "none", stroke: "#000"};
        pathString && (attr.path = pathString);
        p.type = "path";
        p.path = [];
        p.Path = E;
        setFillAndStroke(p, attr);
        vml.canvas.appendChild(el);
        var skew = createNode("skew");
        skew.on = true;
        el.appendChild(skew);
        p.skew = skew;
        p.transform(E);
        return p;
    };
    R._engine.rect = function (vml, x, y, w, h, r) {
        var path = R._rectPath(x, y, w, h, r),
            res = vml.path(path),
            a = res.attrs;
        res.X = a.x = x;
        res.Y = a.y = y;
        res.W = a.width = w;
        res.H = a.height = h;
        a.r = r;
        a.path = path;
        res.type = "rect";
        return res;
    };
    R._engine.ellipse = function (vml, x, y, rx, ry) {
        var res = vml.path(),
            a = res.attrs;
        res.X = x - rx;
        res.Y = y - ry;
        res.W = rx * 2;
        res.H = ry * 2;
        res.type = "ellipse";
        setFillAndStroke(res, {
            cx: x,
            cy: y,
            rx: rx,
            ry: ry
        });
        return res;
    };
    R._engine.circle = function (vml, x, y, r) {
        var res = vml.path(),
            a = res.attrs;
        res.X = x - r;
        res.Y = y - r;
        res.W = res.H = r * 2;
        res.type = "circle";
        setFillAndStroke(res, {
            cx: x,
            cy: y,
            r: r
        });
        return res;
    };
    R._engine.image = function (vml, src, x, y, w, h) {
        var path = R._rectPath(x, y, w, h),
            res = vml.path(path).attr({stroke: "none"}),
            a = res.attrs,
            node = res.node,
            fill = node.getElementsByTagName(fillString)[0];
        a.src = src;
        res.X = a.x = x;
        res.Y = a.y = y;
        res.W = a.width = w;
        res.H = a.height = h;
        a.path = path;
        res.type = "image";
        fill.parentNode == node && node.removeChild(fill);
        fill.rotate = true;
        fill.src = src;
        fill.type = "tile";
        res._.fillpos = [x, y];
        res._.fillsize = [w, h];
        node.appendChild(fill);
        setCoords(res, 1, 1, 0, 0, 0);
        return res;
    };
    R._engine.text = function (vml, x, y, text) {
        var el = createNode("shape"),
            path = createNode("path"),
            o = createNode("textpath");
        x = x || 0;
        y = y || 0;
        text = text || "";
        path.v = R.format("m{0},{1}l{2},{1}", round(x * zoom), round(y * zoom), round(x * zoom) + 1);
        path.textpathok = true;
        o.string = Str(text);
        o.on = true;
        el.style.cssText = cssDot;
        el.coordsize = zoom + S + zoom;
        el.coordorigin = "0 0";
        var p = new Element(el, vml),
            attr = {
                fill: "#000",
                stroke: "none",
                font: R._availableAttrs.font,
                text: text
            };
        p.shape = el;
        p.path = path;
        p.textpath = o;
        p.type = "text";
        p.attrs.text = Str(text);
        p.attrs.x = x;
        p.attrs.y = y;
        p.attrs.w = 1;
        p.attrs.h = 1;
        setFillAndStroke(p, attr);
        el.appendChild(o);
        el.appendChild(path);
        vml.canvas.appendChild(el);
        var skew = createNode("skew");
        skew.on = true;
        el.appendChild(skew);
        p.skew = skew;
        p.transform(E);
        return p;
    };
    R._engine.setSize = function (width, height) {
        var cs = this.canvas.style;
        this.width = width;
        this.height = height;
        width == +width && (width += "px");
        height == +height && (height += "px");
        cs.width = width;
        cs.height = height;
        cs.clip = "rect(0 " + width + " " + height + " 0)";
        if (this._viewBox) {
            R._engine.setViewBox.apply(this, this._viewBox);
        }
        return this;
    };
    R._engine.setViewBox = function (x, y, w, h, fit) {
        R.eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
        var width = this.width,
            height = this.height,
            size = 1 / mmax(w / width, h / height),
            H, W;
        if (fit) {
            H = height / h;
            W = width / w;
            if (w * H < width) {
                x -= (width - w * H) / 2 / H;
            }
            if (h * W < height) {
                y -= (height - h * W) / 2 / W;
            }
        }
        this._viewBox = [x, y, w, h, !!fit];
        this._viewBoxShift = {
            dx: -x,
            dy: -y,
            scale: size
        };
        this.forEach(function (el) {
            el.transform("...");
        });
        return this;
    };
    var createNode;
    R._engine.initWin = function (win) {
            var doc = win.document;
            doc.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
            try {
                !doc.namespaces.rvml && doc.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");
                createNode = function (tagName) {
                    return doc.createElement('<rvml:' + tagName + ' class="rvml">');
                };
            } catch (e) {
                createNode = function (tagName) {
                    return doc.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
                };
            }
        };
    R._engine.initWin(R._g.win);
    R._engine.create = function () {
        var con = R._getContainer.apply(0, arguments),
            container = con.container,
            height = con.height,
            s,
            width = con.width,
            x = con.x,
            y = con.y;
        if (!container) {
            throw new Error("VML container not found.");
        }
        var res = new R._Paper,
            c = res.canvas = R._g.doc.createElement("div"),
            cs = c.style;
        x = x || 0;
        y = y || 0;
        width = width || 512;
        height = height || 342;
        res.width = width;
        res.height = height;
        width == +width && (width += "px");
        height == +height && (height += "px");
        res.coordsize = zoom * 1e3 + S + zoom * 1e3;
        res.coordorigin = "0 0";
        res.span = R._g.doc.createElement("span");
        res.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;";
        c.appendChild(res.span);
        cs.cssText = R.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", width, height);
        if (container == 1) {
            R._g.doc.body.appendChild(c);
            cs.left = x + "px";
            cs.top = y + "px";
            cs.position = "absolute";
        } else {
            if (container.firstChild) {
                container.insertBefore(c, container.firstChild);
            } else {
                container.appendChild(c);
            }
        }
        res.renderfix = function () {};
        return res;
    };
    R.prototype.clear = function () {
        R.eve("raphael.clear", this);
        this.canvas.innerHTML = E;
        this.span = R._g.doc.createElement("span");
        this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
        this.canvas.appendChild(this.span);
        this.bottom = this.top = null;
    };
    R.prototype.remove = function () {
        R.eve("raphael.remove", this);
        this.canvas.parentNode.removeChild(this.canvas);
        for (var i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
        return true;
    };

    var setproto = R.st;
    for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
        setproto[method] = (function (methodname) {
            return function () {
                var arg = arguments;
                return this.forEach(function (el) {
                    el[methodname].apply(el, arg);
                });
            };
        })(method);
    }
})();

    // EXPOSE
    // SVG and VML are appended just before the EXPOSE line
    // Even with AMD, Raphael should be defined globally
    oldRaphael.was ? (g.win.Raphael = R) : (Raphael = R);

    return R;
}));

    return Raphael;
});